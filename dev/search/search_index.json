{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Intro","text":""},{"location":"#_1","title":"Intro","text":"<p>  <p>          </p>   <p>Starlite is a powerful, flexible, highly performant and opinionated ASGI framework, offering first class typing support and a full Pydantic integration.</p> <p>The Starlite framework supports plugins, ships with dependency injection, security primitives, OpenAPI specifications-generation, MessagePack support \u2013 among other common API-framework components such as middleware.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install starlite\n</code></pre>  Extras <p>Brotli Compression Middleware:     <pre><code>pip install starlite[brotli]\n</code></pre></p> <p>Client-side sessions <pre><code>pip install starlite[cryptography]\n</code></pre></p> <p>Server-side sessions with redis / redis caching:     <pre><code>pip install starlite[redis]\n</code></pre></p> <p>Server-side sessions with memcached / memcached caching:     <pre><code>pip install starlite[memcached]\n</code></pre></p> <p>Picologging:     <pre><code>pip install starlite[picologging]\n</code></pre></p> <p>StructLog:     <pre><code>pip install starlite[structlog]\n</code></pre></p> <p>OpenTelemetry:     <pre><code>pip install starlite[openetelemetry]\n</code></pre></p> <p>CLI:     <pre><code>pip install starlite[cli]\n</code></pre></p> <p>Standard installation (includes CLI, picologging and Jinja2 templating):     <pre><code>pip install starlite[standard]\n</code></pre></p> <p>All extras:     <pre><code>pip install starlite[full]\n</code></pre></p>"},{"location":"#minimal-example","title":"Minimal Example","text":"<p>Define your data model using pydantic or any library based on it (for example ormar, beanie, SQLModel):</p> my_app/models/user.py<pre><code>from pydantic import BaseModel, UUID4\n\n\nclass User(BaseModel):\n    first_name: str\n    last_name: str\n    id: UUID4\n</code></pre> <p>You can also use dataclasses (standard library and Pydantic), <code>TypedDict</code>s or <code>msgspec.Struct</code>s:</p> my_app/models/user.py<pre><code>from uuid import UUID\n\n# from pydantic.dataclasses import dataclass\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass User:\n    first_name: str\n    last_name: str\n    id: UUID\n</code></pre> <p>Define a Controller for your data model:</p> Python 3.8+Python 3.9+   my_app/controllers/user.py<pre><code>from typing import List\n\nfrom pydantic import UUID4\nfrom starlite import Controller, Partial, get, post, put, patch, delete\n\nfrom my_app.models import User\n\n\nclass UserController(Controller):\n    path = \"/users\"\n\n    @post()\n    async def create_user(self, data: User) -&gt; User:\n        ...\n\n    @get()\n    async def list_users(self) -&gt; List[User]:\n        ...\n\n    @patch(path=\"/{user_id:uuid}\")\n    async def partial_update_user(self, user_id: UUID4, data: Partial[User]) -&gt; User:\n        ...\n\n    @put(path=\"/{user_id:uuid}\")\n    async def update_user(self, user_id: UUID4, data: User) -&gt; User:\n        ...\n\n    @get(path=\"/{user_id:uuid}\")\n    async def get_user(self, user_id: UUID4) -&gt; User:\n        ...\n\n    @delete(path=\"/{user_id:uuid}\")\n    async def delete_user(self, user_id: UUID4) -&gt; None:\n        ...\n</code></pre>   my_app/controllers/user.py<pre><code>from pydantic import UUID4\nfrom starlite import Controller, Partial, get, post, put, patch, delete\n\nfrom my_app.models import User\n\n\nclass UserController(Controller):\n    path = \"/users\"\n\n    @post()\n    async def create_user(self, data: User) -&gt; User:\n        ...\n\n    @get()\n    async def list_users(self) -&gt; list[User]:\n        ...\n\n    @patch(path=\"/{user_id:uuid}\")\n    async def partial_update_user(self, user_id: UUID4, data: Partial[User]) -&gt; User:\n        ...\n\n    @put(path=\"/{user_id:uuid}\")\n    async def update_user(self, user_id: UUID4, data: User) -&gt; User:\n        ...\n\n    @get(path=\"/{user_id:uuid}\")\n    async def get_user(self, user_id: UUID4) -&gt; User:\n        ...\n\n    @delete(path=\"/{user_id:uuid}\")\n    async def delete_user(self, user_id: UUID4) -&gt; None:\n        ...\n</code></pre>    <p>When instantiating your app, import your controller into your application's entry-point and pass it to Starlite:</p> my_app/main.py<pre><code>from starlite import Starlite\n\nfrom my_app.controllers.user import UserController\n\napp = Starlite(route_handlers=[UserController])\n</code></pre> <p>To run your application, use an ASGI server such as uvicorn:</p> <pre><code>uvicorn my_app.main:app --reload\n</code></pre>"},{"location":"#example-applications","title":"Example Applications","text":"<ul> <li>starlite-pg-redis-docker: In addition to Starlite, this   demonstrates a pattern of application modularity, SQLAlchemy 2.0 ORM, Redis cache connectivity, and more. Like all   Starlite projects, this application is open to contributions, big and small.</li> <li>starlite-hello-world: A bare-minimum application setup. Great   for testing and POC work.</li> </ul>"},{"location":"#about-starlite","title":"About Starlite","text":"<ol> <li>Starlite is a community-driven project. This means not a single author,    but rather a core team of maintainers is leading the project, supported by a community    of contributors. Starlite currently has 5 maintainers and is being very actively developed.</li> <li>Starlite draws inspiration from NestJS - a contemporary TypeScript framework - which places    opinions and patterns at its core.</li> <li>While still allowing for function-based endpoints, Starlite seeks to build on Python's powerful and versatile    OOP, by placing class-based controllers at its core.</li> <li>Starlite is not a microframework. Unlike frameworks such as FastAPI, Starlette or Flask, Starlite includes a lot    of functionalities out of the box needed for a typical modern web application, such as ORM integration,    client- and server-side sessions, caching, OpenTelemetry integration and many more. It's not aiming to be \"the next    Django\" (for example, it will never feature its own ORM), but its scope is not micro either.</li> </ol>"},{"location":"#comparison-with-other-frameworks","title":"Comparison with other frameworks","text":"Starlite FastAPI Starlette Sanic Quart     OpenAPI        Automatic API documentation Swagger, ReDoc, Stoplight Elements Swagger, ReDoc      Data validation        Dependency Injection        Class based routing  (Through extension)      ORM integration SQLAlchemy, Tortoise, Piccolo    (Through extension)   Templating Jinja, Mako Jinja Jinja Jinja Jinja   MessagePack        CORS     (Through extension)   CSRF        Rate-limiting    (Through extension)    JWT        Sessions  Client-side Client-side  Client-side   Authentication JWT / Session based       Caching"},{"location":"#project-governance","title":"Project Governance","text":"<p>From its inception, Starlite was envisaged as a community driven project. We encourage users to become involved with the project - feel free to open issues, chime in on discussions, review pull requests and of course - contribute code.</p> <p>The project is led by a group of maintainers. You can see the list of maintainers in the <code>pyproject.toml</code> file. Additionally, substantial contributors are invited to be members of the <code>starlite-api</code> organization. Our aim is to increase the number of maintainers and have at least 5 active maintainers - this will ensure the long term stability and growth of Starlite in the long run. Contributors who show commitment, contribute great code and show a willingness to become maintainers will be invited to do so. So really feel free to contribute and propose yourself as a maintainer once you contribute substantially.</p>"},{"location":"#contribution-guide","title":"Contribution Guide","text":"<p>Any and all contributions and involvement with the project is welcome. The easiest way to begin contributing is to check out the open issues - and reach out on our discord server or Matrix space.</p>"},{"location":"#license","title":"License","text":"<p>The MIT License (MIT)</p> <p>Copyright (c) 2021, 2022 Starlite-API</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"benchmarks/","title":"Benchmarks","text":""},{"location":"benchmarks/#methodology","title":"Methodology","text":"<ul> <li>Benchmarking is done using the bomardier benchmarking tool.</li> <li>Benchmarks are run on a dedicated machine, with a base Debian 11 installation.</li> <li>Each framework is contained within its own docker container, running on a dedicated CPU core (using the <code>cset shield</code> command and the <code>--cpuset-cpus</code> option for docker)</li> <li>Tests for the frameworks are written to make them as comparable as possible while completing the same tasks (you can see them here)</li> <li>Each application is run using uvicorn with one worker and uvloop</li> <li>Test data has been randomly generated and is being imported from a shared module</li> </ul>"},{"location":"benchmarks/#results","title":"Results","text":"<p>Info</p> <p>If a result is missing for a specific framework that means either</p> <ul> <li>It does not support this functionality (this will be mentioned in the test description)</li> <li>More than 0.1% of responses were dropped / erroneous</li> </ul>"},{"location":"benchmarks/#json","title":"JSON","text":"<p>Serializing a d dictionary into JSON</p>"},{"location":"benchmarks/#files","title":"Files","text":""},{"location":"benchmarks/#path-and-query-parameter-handling","title":"Path and query parameter handling","text":"<p>All responses return \"No Content\"</p> <ul> <li>No params: No path parameters</li> <li>Path params: Single path parameter, coerced into an integer</li> <li>Query params: Single query parameter, coerced into an integer</li> <li>Mixed params: A path and a query parameters, coerced into integers</li> </ul>"},{"location":"benchmarks/#dependency-injection","title":"Dependency injection","text":"<p>(not supported by <code>Starlette</code>)</p> <ul> <li>Resolving 3 nested synchronous dependencies</li> <li>Resolving 3 nested asynchronous dependencies (only supported by <code>Starlite</code> and <code>FastAPI</code>)</li> <li>Resolving 3 nested synchronous, and 3 nested asynchronous dependencies (only supported by <code>Starlite</code> and <code>FastAPI</code>)</li> </ul>"},{"location":"benchmarks/#modifying-responses","title":"Modifying responses","text":"<p>All responses return \"No Content\"</p>"},{"location":"benchmarks/#plaintext","title":"Plaintext","text":""},{"location":"benchmarks/#interpreting-the-results","title":"Interpreting the results","text":"<p>An interpretation of these results should be approached with caution, as is the case for nearly all benchmarks. A high score in a test does not necessarily translate to high performance of your application in your use case. For almost any test you can probably write an app that performs better or worse at a comparable task in your scenario.</p> <p>While trying to design the tests in a way that simulate somewhat realistic scenarios, they can never give an exact representation of how a real world application, where, aside from the workload, many other factors come into play. These tests were mainly written to be used internally for starlite development, to help us locate the source of some performance regression we were experiencing.</p>"},{"location":"migration/","title":"Migrating to Starlite","text":"<p>Migrating from Starlette or FastAPI to Starlite is straightforward, as they are both ASGI frameworks and as such build on the same fundamental principles. The following sections can help to navigate a migration from either framework by introducing Starlite-equivalents to common functionalities.</p>"},{"location":"migration/#from-starlette-fastapi","title":"From Starlette / FastAPI","text":""},{"location":"migration/#routing-decorators","title":"Routing Decorators","text":"<p>Starlite does not include any decorator as part of the <code>Router</code> or <code>Starlite</code> instances. Instead, all routes are declared using route handlers, either as standalone functions or controller methods. The handler can then be registered on an application or router instance.</p> FastAPIStarletteStarlite   <pre><code>from fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(\"/\")\nasync def index() -&gt; dict[str, str]:\n    ...\n</code></pre>   <pre><code>from starlette.applications import Starlette\nfrom starlette.routing import Route\n\n\nasync def index(request):\n    ...\n\n\nroutes = [Route(\"/\", endpoint=index)]\n\napp = Starlette(routes=routes)\n</code></pre>   <pre><code>from starlite import Starlite, get\n\n\n@get(\"/\")\nasync def index() -&gt; dict[str, str]:\n    ...\n\n\napp = Starlite([get])\n</code></pre>     <p>Learn more</p> <p>To learn more about registering routes, check out this chapter in the documentation: registering routes</p>"},{"location":"migration/#routers-and-routes","title":"Routers and Routes","text":"<p>There are a few key differences between Starlite's and Starlette's <code>Router</code> class:</p> <ol> <li>The Starlite version is not an ASGI app</li> <li>The Starlite version does not include decorators: Use route handlers.</li> <li>The Starlite version does not support lifecycle hooks: Those have to be handled on the application layer. See lifecycle hooks</li> </ol> <p>If you are using Starlette's <code>Route</code>s, you will need to replace these with route handlers.</p>"},{"location":"migration/#host-based-routing","title":"Host based routing","text":"<p>Host based routing class is intentionally unsupported. If your application relies on <code>Host</code> you will have to separate the logic into different services and handle this part of request dispatching with a proxy server like nginx or traefik.</p>"},{"location":"migration/#dependency-injection","title":"Dependency Injection","text":"<p>The Starlite dependency injection system is different from the one used by FastAPI. You can read about it in the dependency injection section of the documentation.</p> <p>In FastAPI you declare dependencies either as a list of functions passed to the <code>Router</code> or <code>FastAPI</code> instances, or as a default function argument value wrapped in an instance of the <code>Depends</code> class.</p> <p>In Starlite dependencies are always declared using a dictionary with a string key and the value wrapped in an instance of the <code>Provide</code> class. This also allows to transparently override dependencies on every level of the application, and to easily access dependencies from higher levels.</p> FastAPIStarlite   <pre><code>from fastapi import FastAPI, Depends, APIRouter\n\n\nasync def route_dependency() -&gt; bool:\n    ...\n\n\nasync def nested_dependency() -&gt; str:\n    ...\n\n\nasync def router_dependency() -&gt; int:\n    ...\n\n\nasync def app_dependency(data: str = Depends(nested_dependency)) -&gt; int:\n    ...\n\n\nrouter = APIRouter(dependencies=[Depends(router_dependency)])\napp = FastAPI(dependencies=[Depends(nested_dependency)])\napp.include_router(router)\n\n\n@app.get(\"/\")\nasync def handler(\n    val_route: bool = Depends(route_dependency),\n    val_router: int = Depends(router_dependency),\n    val_nested: str = Depends(nested_dependency),\n    val_app: int = Depends(app_dependency),\n) -&gt; None:\n    ...\n</code></pre>   <pre><code>from starlite import Starlite, Provide, get, Router\n\n\nasync def route_dependency() -&gt; bool:\n    ...\n\n\nasync def nested_dependency() -&gt; str:\n    ...\n\n\nasync def router_dependency() -&gt; int:\n    ...\n\n\nasync def app_dependency(nested: str) -&gt; int:\n    ...\n\n\n@get(\"/\", dependencies={\"val_route\": Provide(route_dependency)})\nasync def handler(\n    val_route: bool, val_router: int, val_nested: str, val_app: int\n) -&gt; None:\n    ...\n\n\nrouter = Router(dependencies={\"val_router\": Provide(router_dependency)})\napp = Starlite(\n    route_handlers=[handler],\n    dependencies={\n        \"val_app\": Provide(app_dependency),\n        \"val_nested\": Provide(nested_dependency),\n    },\n)\n</code></pre>     <p>Learn more</p> <p>To learn more about dependency injection, check out this chapter in the documentation: Dependency injection</p>"},{"location":"migration/#authentication","title":"Authentication","text":"<p>FastAPI promotes a pattern of using dependency injection for authentication. You can do the same in Starlite, but the preferred way of handling this is extending <code>AbstractAuthenticationMiddleware</code>.</p> FastAPIStarlite   <pre><code>from fastapi import FastAPI, Depends, Request\n\n\nasync def authenticate(request: Request) -&gt; None:\n    ...\n\n\napp = FastAPI()\n\n\n@app.get(\"/\", dependencies=[Depends(authenticate)])\nasync def index() -&gt; dict[str, str]:\n    ...\n</code></pre>   <pre><code>from starlite import Starlite, get, ASGIConnection, BaseRouteHandler\n\n\nasync def authenticate(\n    connection: ASGIConnection, route_handler: BaseRouteHandler\n) -&gt; None:\n    ...\n\n\n@get(\"/\", guards=[authenticate])\nasync def index() -&gt; dict[str, str]:\n    ...\n</code></pre>     <p>Learn more</p> <p>To learn more about security and authentication, check out this chapter in the documentation: Security</p>"},{"location":"migration/#dependency-overrides","title":"Dependency overrides","text":"<p>While FastAPI includes a mechanism to override dependencies on an existing application object, Starlite promotes architecular solutions to the issue this is aimed to solve. Therefore, overriding dependencies in Starlite is strictly supported at definition time, i.e. when you're defining handlers, controllers, routers and applications. Dependency overrides are fundamentally the same idea as mocking and should be approached with the same caution and used sparingly instead of being the default.</p> <p>To achieve the same effect there are three general approaches:</p> <ol> <li>Structuring the application with different environments in mind. This could mean for example    connecting to a different database depending on the environment, which in turn is set via    and env-variable. This is sufficient and most cases and designing your application around this    principle is a general good practice since it facilitates configurability and integration-testing    capabilities</li> <li>Isolating tests for unit testing and using <code>create_test_client</code></li> <li>Resort to mocking if none of the above approaches can be made to work</li> </ol>"},{"location":"migration/#middleware","title":"Middleware","text":"<p>Pure ASGI middleware is fully compatible, and can be used with any ASGI framework. Middlewares that make use of FastAPI/Starlette specific middleware features such as Starlette's <code>BaseHTTPMiddleware</code> are not compatible, but can be easily replaced by making use of <code>AbstractMiddleware</code></p>"},{"location":"migration/#from-flask","title":"From Flask","text":""},{"location":"migration/#asgi-vs-wsgi","title":"ASGI vs WSGI","text":"<p>Flask is a WSGI framework, whereas Starlite is built using the modern ASGI standard. A key difference is that ASGI is built with async in mind.</p> <p>While Flask has added support for <code>async/await</code>, it remains synchronous at its core; The async support in Flask is limited to individual endpoints. What this means is that while you can use <code>async def</code> to define endpoints in Flask, they will not run concurrently - requests will still be processed one at a time. Flask handles asynchronous endpoints by creating an event loop for each request, run the endpoint function in it and then return its result.</p> <p>ASGI on the other hand does the exact opposite; It runs everything in a central event loop. Starlite then adds support for synchronous functions by running them in a non-blocking way on the event loop. What this means is that synchronous and asynchronous code both run concurrently.</p>"},{"location":"migration/#routing","title":"Routing","text":"FlaskStarlite   <pre><code>from flask import Flask\n\napp = Flask(__name__)\n\n\n@app.route(\"/\")\ndef index():\n    return \"Index Page\"\n\n\n@app.route(\"/hello\")\ndef hello():\n    return \"Hello, World\"\n</code></pre>   <pre><code>from starlite import Starlite, get\n\n\n@get(\"/\")\ndef index() -&gt; str:\n    return \"Index Page\"\n\n\n@get(\"/hello\")\ndef hello() -&gt; str:\n    return \"Hello, World\"\n\n\napp = Starlite([index, hello])\n</code></pre>"},{"location":"migration/#path-parameters","title":"Path parameters","text":"FlaskStarlite   <pre><code>from flask import Flask\n\napp = Flask(__name__)\n\n\n@app.route(\"/user/&lt;username&gt;\")\ndef show_user_profile(username):\n    return f\"User {username}\"\n\n\n@app.route(\"/post/&lt;int:post_id&gt;\")\ndef show_post(post_id):\n    return f\"Post {post_id}\"\n\n\n@app.route(\"/path/&lt;path:subpath&gt;\")\ndef show_subpath(subpath):\n    return f\"Subpath {subpath}\"\n</code></pre>   <pre><code>from starlite import Starlite, get\nfrom pathlib import Path\n\n\n@get(\"/user/{username:str}\")\ndef show_user_profile(username: str) -&gt; str:\n    return f\"User {username}\"\n\n\n@get(\"/post/{post_id:int}\")\ndef show_post(post_id: int) -&gt; str:\n    return f\"Post {post_id}\"\n\n\n@get(\"/path/{subpath:path}\")\ndef show_subpath(subpath: Path) -&gt; str:\n    return f\"Subpath {subpath}\"\n\n\napp = Starlite([show_user_profile, show_post, show_subpath])\n</code></pre>     <p>Learn more</p> <p>To learn more about path parameters, check out this chapter in the documentation: Path parameters</p>"},{"location":"migration/#request-object","title":"Request object","text":"<p>In Flask, the current request can be accessed through a global <code>request</code> variable. In Starlite, the request can be accessed through an optional parameter in the handler function.</p> FlaskStarlite   <pre><code>from flask import Flask, request\n\napp = Flask(__name__)\n\n\n@app.get(\"/\")\ndef index():\n    print(request.method)\n</code></pre>   <pre><code>from starlite import Starlite, get, Request\n\n\n@get(\"/\")\ndef index(request: Request) -&gt; None:\n    print(request.method)\n</code></pre>"},{"location":"migration/#request-methods","title":"Request methods","text":"Flask Starlite     <code>request.args</code> <code>request.query_params</code>   <code>request.base_url</code> <code>request.base_url</code>   <code>request.authorization</code> <code>request.auth</code>   <code>request.cache_control</code> <code>request.headers.get(\"cache-control\")</code>   <code>request.content_encoding</code> <code>request.headers.get(\"content-encoding\")</code>   <code>request.content_length</code> <code>request.headers.get(\"content-length\")</code>   <code>request.content_md5</code> -   <code>request.content_type</code> <code>request.content_type</code>   <code>request.cookies</code> <code>request.cookies</code>   <code>request.data</code> <code>request.body()</code>   <code>request.date</code> <code>request.headers.get(\"date\")</code>   <code>request.endpoint</code> <code>request.route_handler</code>   <code>request.environ</code> <code>request.scope</code>   <code>request.files</code> Use <code>UploadFile</code>   <code>request.form</code> <code>request.form()</code>, prefer <code>Body</code>   <code>request.get_json</code> <code>request.json()</code>, prefer the <code>data keyword argument</code>   <code>request.headers</code> <code>request.headers</code>   <code>request.host</code> -   <code>request.host_url</code> -   <code>request.if_match</code> <code>request.headers.get(\"if-match\")</code>   <code>request.if_modified_since</code> <code>request.headers.get(\"if_modified_since\")</code>   <code>request.if_none_match</code> <code>request.headers.get(\"if_none_match\")</code>   <code>request.if_range</code> <code>request.headers.get(\"if_range\")</code>   <code>request.if_unmodified_since</code> <code>request.headers.get(\"if_unmodified_since\")</code>   <code>request.method</code> <code>request.method</code>   <code>request.mimetype</code> -   <code>request.mimetype_params</code> -   <code>request.origin</code> -   <code>request.path</code> <code>request.scope[\"path\"]</code>   <code>request.query_string</code> <code>request.scope[\"query_string\"]</code>   <code>request.range</code> <code>request.headers.get(\"range\")</code>   <code>request.referrer</code> <code>request.headers.get(\"referrer\")</code>   <code>request.remote_addr</code> -   <code>request.remote_user</code> -   <code>request.root_path</code> <code>request.scope[\"root_path\"]</code>   <code>request.server</code> <code>request.scope[\"server\"]</code>   <code>request.stream</code> <code>request.stream</code>   <code>request.url</code> <code>request.url</code>   <code>request.url_charset</code> -   <code>request.user_agent</code> <code>request.headers.get(\"user-agent\")</code>   <code>request.user_agent</code> <code>request.headers.get(\"user-agent\")</code>     <p>Read more</p> <p>To learn more about requests,, check out these chapters in the documentation:</p> <ul> <li>Request data</li> <li>Request reference</li> </ul>"},{"location":"migration/#static-files","title":"Static files","text":"<p>Like Flask, Starlite also has capabilities for serving static files, but while Flask will automatically serve files from a <code>static</code> folder, this has to be configured explicitly in Starlite.</p> <pre><code>from starlite import Starlite, StaticFilesConfig\n\napp = Starlite(\n    [], static_files_config=StaticFilesConfig(path=\"/static\", directories=[\"static\"])\n)\n</code></pre>  <p>Read more</p> <p>To learn more about static files, check out this chapter in the documentation: Static files</p>"},{"location":"migration/#templates","title":"Templates","text":"<p>Flask comes with the Jinja templating engine built-in. You can use Jinja with Starlite as well, but you'll need to install it explicitly. You can do by installing Starlite with <code>pip install starlite[jinja]</code>. In addition to Jinja, Starlite supports Mako templates as well.</p> FlaskStarlite   <pre><code>from flask import Flask, render_template\n\napp = Flask(__name__)\n\n\n@app.route(\"/hello/&lt;name&gt;\")\ndef hello(name):\n    return render_template(\"hello.html\", name=name)\n</code></pre>   <pre><code>from starlite import Starlite, get, TemplateConfig, Template\nfrom starlite.contrib.jinja import JinjaTemplateEngine\n\n\n@get(\"/hello/{name:str}\")\ndef hello(name: str) -&gt; Template:\n    return Template(name=\"hello.html\", context={\"name\": name})\n\n\napp = Starlite(\n    [hello],\n    template_config=TemplateConfig(directory=\"templates\", engine=JinjaTemplateEngine),\n)\n</code></pre>     <p>Read more</p> <p>To learn more about templates, check out this chapter in the documentation: Template engines</p>"},{"location":"migration/#setting-cookies-and-headers","title":"Setting cookies and headers","text":"FlaskStarlite   <pre><code>from flask import Flask, make_response\n\napp = Flask(__name__)\n\n\n@app.get(\"/\")\ndef index():\n    response = make_response(\"hello\")\n    response.set_cookie(\"my-cookie\", \"cookie-value\")\n    response.headers[\"my-header\"] = \"header-value\"\n    return response\n</code></pre>   <pre><code>from starlite import Starlite, get, ResponseHeader, Cookie, Response\n\n\n@get(\n    \"/static\",\n    response_headers={\"my-header\": ResponseHeader(value=\"header-value\")},\n    response_cookies=[Cookie(\"my-cookie\", \"cookie-value\")],\n)\ndef static() -&gt; str:\n    # you can set headers and cookies when defining handlers\n    ...\n\n\n@get(\"/dynamic\")\ndef dynamic() -&gt; Response[str]:\n    # or dynamically, by returning an instance of Response\n    return Response(\n        \"hello\",\n        headers={\"my-header\": \"header-value\"},\n        cookies=[Cookie(\"my-cookie\", \"cookie-value\")],\n    )\n</code></pre>     <p>Read more</p> <p>To learn more about response headers and cookies, check out these chapters in the documentation:</p> <ul> <li>Response headers</li> <li>Response cookies</li> </ul>"},{"location":"migration/#redirects","title":"Redirects","text":"<p>For redirects, instead of <code>redirect</code> use <code>Redirect</code>:</p> FlaskStarlite   <pre><code>from flask import Flask, redirect, url_for\n\napp = Flask(__name__)\n\n\n@app.get(\"/\")\ndef index():\n    return \"hello\"\n\n\n@app.get(\"/hello\")\ndef hello():\n    return redirect(url_for(\"index\"))\n</code></pre>   <pre><code>from starlite import Starlite, get, Redirect\n\n\n@get(\"/\")\ndef index() -&gt; str:\n    return \"hello\"\n\n\n@get(\"/hello\")\ndef hello() -&gt; Redirect:\n    return Redirect(path=\"index\")\n\n\napp = Starlite([index, hello])\n</code></pre>"},{"location":"migration/#raising-http-errors","title":"Raising HTTP errors","text":"<p>Instead of using the <code>abort</code> function, raise an <code>HTTPException</code>:</p> FlaskStarlite   <pre><code>from flask import Flask, abort\n\napp = Flask(__name__)\n\n\n@app.get(\"/\")\ndef index():\n    abort(400, \"this did not work\")\n</code></pre>   <pre><code>from starlite import Starlite, get, HTTPException\n\n\n@get(\"/\")\ndef index() -&gt; None:\n    raise HTTPException(status_code=400, detail=\"this did not work\")\n\n\napp = Starlite([index])\n</code></pre>     <p>Learn more</p> <p>To learn more about exceptions, check out this chapter in the documentation: Exceptions</p>"},{"location":"migration/#setting-status-codes","title":"Setting status codes","text":"FlaskStarlite   <pre><code>from flask import Flask\n\napp = Flask(__name__)\n\n\n@app.get(\"/\")\ndef index():\n    return \"not found\", 404\n</code></pre>   <pre><code>from starlite import Starlite, get, Response\n\n\n@get(\"/static\", status_code=404)\ndef static_status() -&gt; str:\n    return \"not found\"\n\n\n@get(\"/dynamic\")\ndef dynamic_status() -&gt; Response[str]:\n    return Response(\"not found\", status_code=404)\n\n\napp = Starlite([static_status, dynamic_status])\n</code></pre>"},{"location":"migration/#serialization","title":"Serialization","text":"<p>Flask uses a mix of explicit conversion (such as <code>jsonify</code>) and inference (i.e. the type of the returned data) to determine how data should be serialized. Starlite instead assumes the data returned is intended to be serialized into JSON and will do so unless told otherwise.</p> FlaskStarlite   <pre><code>from flask import Flask, Response\n\napp = Flask(__name__)\n\n\n@app.get(\"/json\")\ndef get_json():\n    return {\"hello\": \"world\"}\n\n\n@app.get(\"/text\")\ndef get_text():\n    return \"hello, world!\"\n\n\n@app.get(\"/html\")\ndef get_html():\n    return Response(\"&lt;strong&gt;hello, world&lt;/strong&gt;\", mimetype=\"text/html\")\n</code></pre>   <pre><code>from starlite import Starlite, get, MediaType\n\n\n@get(\"/json\")\ndef get_json() -&gt; dict[str, str]:\n    return {\"hello\": \"world\"}\n\n\n@get(\"/text\", media_type=MediaType.TEXT)\ndef get_text() -&gt; str:\n    return \"hello, world\"\n\n\n@get(\"/html\", media_type=MediaType.HTML)\ndef get_html() -&gt; str:\n    return \"&lt;strong&gt;hello, world&lt;/strong&gt;\"\n\n\napp = Starlite([get_json, get_text, get_html])\n</code></pre>"},{"location":"migration/#error-handling","title":"Error handling","text":"FlaskStarlite   <pre><code>from flask import Flask\nfrom werkzeug.exceptions import HTTPException\n\napp = Flask(__name__)\n\n\n@app.errorhandler(HTTPException)\ndef handle_exception(e):\n    ...\n</code></pre>   <pre><code>from starlite import Starlite, HTTPException, Request, Response\n\n\ndef handle_exception(request: Request, exception: Exception) -&gt; Response:\n    ...\n\n\napp = Starlite([], exception_handlers={HTTPException: handle_exception})\n</code></pre>     <p>Learn more</p> <p>To learn more about exception handling, check out this chapter in the documentation: Exception handling</p>"},{"location":"reference/0-api-reference-intro/","title":"API Reference","text":"<p>The API references offer detailed documentation of the public API of <code>Starlite</code>, and semantic versioning guarantees apply to the interfaces defined within. Any undocumented interfaces are subject to change. However, users should feel free to open GitHub discussions / issues, or reach out via our Discord server to discuss the stability of any undocumented interface.</p>"},{"location":"reference/1-app/","title":"The Starlite Application","text":""},{"location":"reference/1-app/#starlite.app.Starlite","title":"starlite.app.Starlite","text":"<p>         Bases: <code>Router</code></p> <p>The Starlite application.</p> <p><code>Starlite</code> is the root level of the app - it has the base path of \"/\" and all root level Controllers, Routers and Route Handlers should be registered on it.</p> <p>Inherits from the Router class</p>"},{"location":"reference/1-app/#starlite.app.Starlite.route_handler_method_view","title":"route_handler_method_view  <code>property</code>","text":"<pre><code>route_handler_method_view: Dict[str, List[str]]\n</code></pre>  <p>Map route handlers to paths.</p> <p>Returns:</p>    Type Description      <code>Dict[str, List[str]]</code>  <p>A dictionary of router handlers and lists of paths as strings</p>"},{"location":"reference/1-app/#starlite.app.Starlite.__init__","title":"__init__","text":"<pre><code>__init__(\n    route_handlers,\n    *,\n    after_exception=None,\n    after_request=None,\n    after_response=None,\n    after_shutdown=None,\n    after_startup=None,\n    allowed_hosts=None,\n    before_request=None,\n    before_send=None,\n    before_shutdown=None,\n    before_startup=None,\n    cache_config=DEFAULT_CACHE_CONFIG,\n    cache_control=None,\n    compression_config=None,\n    cors_config=None,\n    csrf_config=None,\n    debug=False,\n    dependencies=None,\n    etag=None,\n    exception_handlers=None,\n    guards=None,\n    initial_state=None,\n    logging_config=None,\n    middleware=None,\n    on_app_init=None,\n    on_shutdown=None,\n    on_startup=None,\n    openapi_config=DEFAULT_OPENAPI_CONFIG,\n    opt=None,\n    parameters=None,\n    plugins=None,\n    request_class=None,\n    response_class=None,\n    response_cookies=None,\n    response_headers=None,\n    security=None,\n    static_files_config=None,\n    tags=None,\n    template_config=None,\n    type_encoders=None,\n    websocket_class=None\n)\n</code></pre>  <p>Initialize a <code>Starlite</code> application.</p> <p>Parameters:</p>    Name Type Description Default     <code>after_exception</code>  <code>Optional[SingleOrList[AfterExceptionHookHandler]]</code>  <p>An application level exception hook handler or list thereof.This hook is called after an exception occurs. In difference to exception handlers, it is not meant to return a response - only to process the exception (e.g. log it, send it to Sentry etc.).</p>  <code>None</code>    <code>after_request</code>  <code>Optional[AfterRequestHookHandler]</code>  <p>A sync or async function executed after the route handler function returned and the response object has been resolved. Receives the response object.</p>  <code>None</code>    <code>after_response</code>  <code>Optional[AfterResponseHookHandler]</code>  <p>A sync or async function called after the response has been awaited. It receives the Request object and should not return any values.</p>  <code>None</code>    <code>after_shutdown</code>  <code>Optional[SingleOrList[LifeSpanHookHandler]]</code>  <p>An application level life-span hook handler or list thereof. This hook is called during the ASGI shutdown, after all callables in the 'on_shutdown' list have been called.</p>  <code>None</code>    <code>after_startup</code>  <code>Optional[SingleOrList[LifeSpanHookHandler]]</code>  <p>An application level life-span hook handler or list thereof. This hook is called during the ASGI startup, after all callables in the 'on_startup' list have been called.</p>  <code>None</code>    <code>allowed_hosts</code>  <code>Optional[Union[List[str], AllowedHostsConfig]]</code>  <p>A list of allowed hosts - enables the builtin allowed hosts middleware.</p>  <code>None</code>    <code>before_request</code>  <code>Optional[BeforeRequestHookHandler]</code>  <p>A sync or async function called immediately before calling the route handler. Receives the Request instance and any non-<code>None</code> return value is used for the response, bypassing the route handler.</p>  <code>None</code>    <code>before_send</code>  <code>Optional[SingleOrList[BeforeMessageSendHookHandler]]</code>  <p>An application level before send hook handler or list thereof. This hook is called when the ASGI send function is called.</p>  <code>None</code>    <code>before_shutdown</code>  <code>Optional[SingleOrList[LifeSpanHookHandler]]</code>  <p>An application level life-span hook handler or list thereof. This hook is called during the ASGI shutdown, before any callables in the 'on_shutdown' list have been called.</p>  <code>None</code>    <code>before_startup</code>  <code>Optional[SingleOrList[LifeSpanHookHandler]]</code>  <p>An application level life-span hook handler or list thereof. This hook is called during the ASGI startup, before any callables in the 'on_startup' list have been called.</p>  <code>None</code>    <code>cache_config</code>  <code>CacheConfig</code>  <p>Configures caching behavior of the application.</p>  <code>DEFAULT_CACHE_CONFIG</code>    <code>cache_control</code>  <code>Optional[CacheControlHeader]</code>  <p>A <code>cache-control</code> header of type CacheControlHeader to add to route handlers of this app. Can be overridden by route handlers.</p>  <code>None</code>    <code>compression_config</code>  <code>Optional[CompressionConfig]</code>  <p>Configures compression behaviour of the application, this enabled a builtin or user defined Compression middleware.</p>  <code>None</code>    <code>cors_config</code>  <code>Optional[CORSConfig]</code>  <p>If set this enables the builtin CORS middleware.</p>  <code>None</code>    <code>csrf_config</code>  <code>Optional[CSRFConfig]</code>  <p>If set this enables the builtin CSRF middleware.</p>  <code>None</code>    <code>debug</code>  <code>bool</code>  <p>If <code>True</code>, app errors rendered as HTML with a stack trace.</p>  <code>False</code>    <code>dependencies</code>  <code>Optional[Dict[str, Provide]]</code>  <p>A string keyed dictionary of dependency Provider instances.</p>  <code>None</code>    <code>etag</code>  <code>Optional[ETag]</code>  <p>An <code>etag</code> header of type ETag to add to route handlers of this app. Can be overridden by route handlers.</p>  <code>None</code>    <code>exception_handlers</code>  <code>Optional[ExceptionHandlersMap]</code>  <p>A dictionary that maps handler functions to status codes and/or exception types.</p>  <code>None</code>    <code>guards</code>  <code>Optional[List[Guard]]</code>  <p>A list of Guard callables.</p>  <code>None</code>    <code>initial_state</code>  <code>Optional[Union[ImmutableState, Dict[str, Any], Iterable[Tuple[str, Any]]]]</code>  <p>An object from which to initialize the app state.</p>  <code>None</code>    <code>logging_config</code>  <code>Optional[BaseLoggingConfig]</code>  <p>A subclass of BaseLoggingConfig.</p>  <code>None</code>    <code>middleware</code>  <code>Optional[List[Middleware]]</code>  <p>A list of Middleware.</p>  <code>None</code>    <code>on_app_init</code>  <code>Optional[List[OnAppInitHandler]]</code>  <p>A sequence of OnAppInitHandler instances. Handlers receive an instance of AppConfig that will have been initially populated with the parameters passed to Starlite, and must return an instance of same. If more than one handler is registered they are called in the order they are provided.</p>  <code>None</code>    <code>on_shutdown</code>  <code>Optional[List[LifeSpanHandler]]</code>  <p>A list of LifeSpanHandler called during application shutdown.</p>  <code>None</code>    <code>on_startup</code>  <code>Optional[List[LifeSpanHandler]]</code>  <p>A list of LifeSpanHandler called during application startup.</p>  <code>None</code>    <code>openapi_config</code>  <code>Optional[OpenAPIConfig]</code>  <p>Defaults to DEFAULT_OPENAPI_CONFIG</p>  <code>DEFAULT_OPENAPI_CONFIG</code>    <code>opt</code>  <code>Optional[Dict[str, Any]]</code>  <p>A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope.</p>  <code>None</code>    <code>parameters</code>  <code>Optional[ParametersMap]</code>  <p>A mapping of Parameter definitions available to all application paths.</p>  <code>None</code>    <code>plugins</code>  <code>Optional[List[PluginProtocol]]</code>  <p>List of plugins.</p>  <code>None</code>    <code>request_class</code>  <code>Optional[Type[Request]]</code>  <p>An optional subclass of Request to use for http connections.</p>  <code>None</code>    <code>response_class</code>  <code>Optional[ResponseType]</code>  <p>A custom subclass of [starlite.response.Response] to be used as the app's default response.</p>  <code>None</code>    <code>response_cookies</code>  <code>Optional[ResponseCookies]</code>  <p>A list of [Cookie](starlite.datastructures.Cookie] instances.</p>  <code>None</code>    <code>response_headers</code>  <code>Optional[ResponseHeadersMap]</code>  <p>A string keyed dictionary mapping ResponseHeader instances.</p>  <code>None</code>    <code>route_handlers</code>  <code>List[ControllerRouterHandler]</code>  <p>A required list of route handlers, which can include instances of Router, subclasses of Controller or any function decorated by the route handler decorators.</p>  required    <code>security</code>  <code>Optional[List[SecurityRequirement]]</code>  <p>A list of dictionaries that will be added to the schema of all route handlers in the application. See SecurityRequirement for details.</p>  <code>None</code>    <code>static_files_config</code>  <code>Optional[Union[StaticFilesConfig, List[StaticFilesConfig]]]</code>  <p>An instance or list of StaticFilesConfig</p>  <code>None</code>    <code>tags</code>  <code>Optional[List[str]]</code>  <p>A list of string tags that will be appended to the schema of all route handlers under the application.</p>  <code>None</code>    <code>template_config</code>  <code>Optional[TemplateConfig]</code>  <p>An instance of TemplateConfig</p>  <code>None</code>    <code>type_encoders</code>  <code>Optional[TypeEncodersMap]</code>  <p>A mapping of types to callables that transform them into types supported for serialization.</p>  <code>None</code>    <code>websocket_class</code>  <code>Optional[Type[WebSocket]]</code>  <p>An optional subclass of WebSocket to use for websocket connections.</p>  <code>None</code>"},{"location":"reference/1-app/#starlite.app.Starlite.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(scope, receive, send)\n</code></pre>  <p>Application entry point.</p> <p>Lifespan events (startup / shutdown) are sent to the lifespan handler, otherwise the ASGI handler is used</p> <p>Parameters:</p>    Name Type Description Default     <code>scope</code>  <code>Union[Scope, LifeSpanScope]</code>  <p>The ASGI connection scope.</p>  required    <code>receive</code>  <code>Union[Receive, LifeSpanReceive]</code>  <p>The ASGI receive function.</p>  required    <code>send</code>  <code>Union[Send, LifeSpanSend]</code>  <p>The ASGI send function.</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/1-app/#starlite.app.Starlite.get_handler_index_by_name","title":"get_handler_index_by_name","text":"<pre><code>get_handler_index_by_name(name)\n</code></pre>  <p>Receives a route handler name and returns an optional dictionary containing the route handler instance and list of paths sorted lexically.</p> <p>Examples:</p> <pre><code>from starlite import Starlite, get\n\n\n@get(\"/\", name=\"my-handler\")\ndef handler() -&gt; None:\n    pass\n\n\napp = Starlite(route_handlers=[handler])\n\nhandler_index = app.get_handler_index_by_name(\"my-handler\")\n\n# { \"paths\": [\"/\"], \"handler\" ... }\n</code></pre> <p>Parameters:</p>    Name Type Description Default     <code>name</code>  <code>str</code>  <p>A route handler unique name.</p>  required     <p>Returns:</p>    Type Description      <code>Optional[HandlerIndex]</code>  <p>A HandlerIndex instance or None.</p>"},{"location":"reference/1-app/#starlite.app.Starlite.register","title":"register","text":"<pre><code>register(value, add_to_openapi_schema=False)\n</code></pre>  <p>Register a route handler on the app.</p> <p>This method can be used to dynamically add endpoints to an application.</p> <p>Parameters:</p>    Name Type Description Default     <code>value</code>  <code>ControllerRouterHandler</code>  <p>an instance of Router, a subclass of Controller or any function decorated by the route handler decorators.</p>  required    <code>add_to_openapi_schema</code>  <code>bool</code>  <p>Whether to add the registered route to the OpenAPI Schema. This affects only HTTP route handlers.</p>  <code>False</code>     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/1-app/#starlite.app.Starlite.route_reverse","title":"route_reverse","text":"<pre><code>route_reverse(name, **path_parameters)\n</code></pre>  <p>Receives a route handler name, path parameter values and returns url path to the handler with filled path parameters.</p> <p>Examples:</p> <pre><code>from starlite import Starlite, get\n\n\n@get(\"/group/{group_id:int}/user/{user_id:int}\", name=\"get_membership_details\")\ndef get_membership_details(group_id: int, user_id: int) -&gt; None:\n    pass\n\n\napp = Starlite(route_handlers=[get_membership_details])\n\npath = app.route_reverse(\"get_membership_details\", user_id=100, group_id=10)\n\n# /group/10/user/100\n</code></pre> <p>Parameters:</p>    Name Type Description Default     <code>name</code>  <code>str</code>  <p>A route handler unique name.</p>  required    <code>**path_parameters</code>  <code>Any</code>  <p>Actual values for path parameters in the route.</p>  <code>{}</code>     <p>Raises:</p>    Type Description      <code>NoRouteMatchFoundException</code>  <p>If route with 'name' does not exist, path parameters are missing in **path_parameters or have wrong type.</p>    <p>Returns:</p>    Type Description      <code>str</code>  <p>A fully formatted url path.</p>"},{"location":"reference/1-app/#starlite.app.Starlite.url_for_static_asset","title":"url_for_static_asset","text":"<pre><code>url_for_static_asset(name, file_path)\n</code></pre>  <p>Receives a static files handler name, an asset file path and returns resolved url path to the asset.</p> <p>Examples:</p> <pre><code>from starlite import Starlite, StaticFilesConfig\n\napp = Starlite(\n    static_files_config=StaticFilesConfig(directories=[\"css\"], path=\"/static/css\")\n)\n\npath = app.url_for_static_asset(\"css\", \"main.css\")\n\n# /static/css/main.css\n</code></pre> <p>Parameters:</p>    Name Type Description Default     <code>name</code>  <code>str</code>  <p>A static handler unique name.</p>  required    <code>file_path</code>  <code>str</code>  <p>a string containing path to an asset.</p>  required     <p>Raises:</p>    Type Description      <code>NoRouteMatchFoundException</code>  <p>If static files handler with 'name' does not exist.</p>    <p>Returns:</p>    Type Description      <code>str</code>  <p>A url path to the asset.</p>"},{"location":"reference/1-app/#starlite.app.HandlerIndex","title":"starlite.app.HandlerIndex","text":"<p>         Bases: <code>TypedDict</code></p> <p>Map route handler names to a mapping of paths + route handler.</p> <p>It's returned from the 'get_handler_index_by_name' utility method.</p>"},{"location":"reference/1-app/#starlite.app.HandlerIndex.paths","title":"paths  <code>class-attribute</code>","text":"<pre><code>paths: List[str]\n</code></pre>  <p>Full route paths to the route handler.</p>"},{"location":"reference/1-app/#starlite.app.HandlerIndex.handler","title":"handler  <code>class-attribute</code>","text":"<pre><code>handler: RouteHandlerType\n</code></pre>  <p>Route handler instance.</p>"},{"location":"reference/1-app/#starlite.app.HandlerIndex.identifier","title":"identifier  <code>class-attribute</code>","text":"<pre><code>identifier: str\n</code></pre>  <p>Unique identifier of the handler.</p> <p>Either equal to the 'name' attribute or the str value of the handler.</p>"},{"location":"reference/1-app/#starlite.app.DEFAULT_OPENAPI_CONFIG","title":"starlite.app.DEFAULT_OPENAPI_CONFIG  <code>module-attribute</code>","text":"<pre><code>starlite.app.DEFAULT_OPENAPI_CONFIG = OpenAPIConfig(title='Starlite API', version='1.0.0')\n</code></pre>  <p>The default OpenAPI config used if not configuration is explicitly passed to the Starlite instance constructor.</p>"},{"location":"reference/1-app/#starlite.app.DEFAULT_CACHE_CONFIG","title":"starlite.app.DEFAULT_CACHE_CONFIG  <code>module-attribute</code>","text":"<pre><code>starlite.app.DEFAULT_CACHE_CONFIG = CacheConfig()\n</code></pre>  <p>The default cache config used if not configuration is explicitly passed to the Starlite instance constructor.</p>"},{"location":"reference/2-router/","title":"Router","text":""},{"location":"reference/2-router/#starlite.router.Router","title":"starlite.router.Router","text":"<p>The Starlite Router class.</p> <p>A Router instance is used to group controller, routers and route handler functions under a shared path fragment</p>"},{"location":"reference/2-router/#starlite.router.Router.__init__","title":"__init__","text":"<pre><code>__init__(\n    path,\n    *,\n    after_request=None,\n    after_response=None,\n    before_request=None,\n    cache_control=None,\n    dependencies=None,\n    etag=None,\n    exception_handlers=None,\n    guards=None,\n    middleware=None,\n    opt=None,\n    parameters=None,\n    response_class=None,\n    response_cookies=None,\n    response_headers=None,\n    route_handlers,\n    security=None,\n    tags=None,\n    type_encoders=None\n)\n</code></pre>  <p>Initialize a <code>Router</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>after_request</code>  <code>Optional[AfterRequestHookHandler]</code>  <p>A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used.</p>  <code>None</code>    <code>after_response</code>  <code>Optional[AfterResponseHookHandler]</code>  <p>A sync or async function called after the response has been awaited. It receives the Request object and should not return any values.</p>  <code>None</code>    <code>before_request</code>  <code>Optional[BeforeRequestHookHandler]</code>  <p>A sync or async function called immediately before calling the route handler. Receives the <code>starlite.connection.Request</code> instance and any non-<code>None</code> return value is used for the response, bypassing the route handler.</p>  <code>None</code>    <code>cache_control</code>  <code>Optional[CacheControlHeader]</code>  <p>A <code>cache-control</code> header of type CacheControlHeader to add to route handlers of this router. Can be overridden by route handlers.</p>  <code>None</code>    <code>dependencies</code>  <code>Optional[Dict[str, Provide]]</code>  <p>A string keyed dictionary of dependency Provider instances.</p>  <code>None</code>    <code>etag</code>  <code>Optional[ETag]</code>  <p>An <code>etag</code> header of type ETag to add to route handlers of this router. Can be overridden by route handlers.</p>  <code>None</code>    <code>exception_handlers</code>  <code>Optional[ExceptionHandlersMap]</code>  <p>A dictionary that maps handler functions to status codes and/or exception types.</p>  <code>None</code>    <code>guards</code>  <code>Optional[List[Guard]]</code>  <p>A list of Guard callables.</p>  <code>None</code>    <code>middleware</code>  <code>Optional[List[Middleware]]</code>  <p>A list of Middleware.</p>  <code>None</code>    <code>opt</code>  <code>Optional[Dict[str, Any]]</code>  <p>A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope.</p>  <code>None</code>    <code>parameters</code>  <code>Optional[ParametersMap]</code>  <p>A mapping of Parameter definitions available to all application paths.</p>  <code>None</code>    <code>path</code>  <code>str</code>  <p>A path fragment that is prefixed to all route handlers, controllers and other routers associated with the router instance.</p>  required    <code>response_class</code>  <code>Optional[ResponseType]</code>  <p>A custom subclass of [starlite.response.Response] to be used as the default for all route handlers, controllers and other routers associated with the router instance.</p>  <code>None</code>    <code>response_cookies</code>  <code>Optional[ResponseCookies]</code>  <p>A list of [Cookie](starlite.datastructures.Cookie] instances.</p>  <code>None</code>    <code>response_headers</code>  <code>Optional[ResponseHeadersMap]</code>  <p>A string keyed dictionary mapping ResponseHeader instances.</p>  <code>None</code>    <code>route_handlers</code>  <code>List[ControllerRouterHandler]</code>  <p>A required list of route handlers, which can include instances of Router, subclasses of Controller or any function decorated by the route handler decorators.</p>  required    <code>security</code>  <code>Optional[List[SecurityRequirement]]</code>  <p>A list of dictionaries that will be added to the schema of all route handlers under the router.</p>  <code>None</code>    <code>tags</code>  <code>Optional[List[str]]</code>  <p>A list of string tags that will be appended to the schema of all route handlers under the router.</p>  <code>None</code>    <code>type_encoders</code>  <code>Optional[TypeEncodersMap]</code>  <p>A mapping of types to callables that transform them into types supported for serialization.</p>  <code>None</code>"},{"location":"reference/2-router/#starlite.router.Router.register","title":"register","text":"<pre><code>register(value)\n</code></pre>  <p>Register a Controller, Route instance or RouteHandler on the router.</p> <p>Parameters:</p>    Name Type Description Default     <code>value</code>  <code>ControllerRouterHandler</code>  <p>a subclass or instance of Controller, an instance of <code>Router</code> or a function/method that has been decorated by any of the routing decorators, e.g. get, post.</p>  required     <p>Returns:</p>    Type Description      <code>List[BaseRoute]</code>  <p>Collection of handlers added to the router.</p>"},{"location":"reference/3-controller/","title":"Controller","text":""},{"location":"reference/3-controller/#starlite.controller.Controller","title":"starlite.controller.Controller","text":"<p>The Starlite Controller class.</p> <p>Subclass this class to create 'view' like components and utilize OOP.</p>"},{"location":"reference/3-controller/#starlite.controller.Controller.after_request","title":"after_request  <code>class-attribute</code>","text":"<pre><code>after_request: Optional[AfterRequestHookHandler]\n</code></pre>  <p>A sync or async function executed before a Request is passed to any route handler.</p> <p>If this function returns a value, the request will not reach the route handler, and instead this value will be used.</p>"},{"location":"reference/3-controller/#starlite.controller.Controller.after_response","title":"after_response  <code>class-attribute</code>","text":"<pre><code>after_response: Optional[AfterResponseHookHandler]\n</code></pre>  <p>A sync or async function called after the response has been awaited.</p> <p>It receives the Request instance and should not return any values.</p>"},{"location":"reference/3-controller/#starlite.controller.Controller.before_request","title":"before_request  <code>class-attribute</code>","text":"<pre><code>before_request: Optional[BeforeRequestHookHandler]\n</code></pre>  <p>A sync or async function called immediately before calling the route handler.</p> <p>It receives the Request instance and any non-<code>None</code> return value is used for the response, bypassing the route handler.</p>"},{"location":"reference/3-controller/#starlite.controller.Controller.cache_control","title":"cache_control  <code>class-attribute</code>","text":"<pre><code>cache_control: Optional[CacheControlHeader]\n</code></pre>  <p>A CacheControlHeader header to add to route handlers of this controller.</p> <p>Can be overridden by route handlers.</p>"},{"location":"reference/3-controller/#starlite.controller.Controller.dependencies","title":"dependencies  <code>class-attribute</code>","text":"<pre><code>dependencies: Optional[Dependencies]\n</code></pre>  <p>dependencies: A string keyed dictionary of dependency Provider instances.</p>"},{"location":"reference/3-controller/#starlite.controller.Controller.exception_handlers","title":"exception_handlers  <code>class-attribute</code>","text":"<pre><code>exception_handlers: Optional[ExceptionHandlersMap]\n</code></pre>  <p>A dictionary that maps handler functions to status codes and/or exception types.</p>"},{"location":"reference/3-controller/#starlite.controller.Controller.guards","title":"guards  <code>class-attribute</code>","text":"<pre><code>guards: Optional[List[Guard]]\n</code></pre>  <p>A list of Guard callables.</p>"},{"location":"reference/3-controller/#starlite.controller.Controller.middleware","title":"middleware  <code>class-attribute</code>","text":"<pre><code>middleware: Optional[List[Middleware]]\n</code></pre>  <p>A list of Middleware.</p>"},{"location":"reference/3-controller/#starlite.controller.Controller.owner","title":"owner  <code>instance-attribute</code>","text":"<pre><code>owner = owner\n</code></pre>"},{"location":"reference/3-controller/#starlite.controller.Controller.parameters","title":"parameters  <code>class-attribute</code>","text":"<pre><code>parameters: Optional[ParametersMap]\n</code></pre>  <p>A mapping of Parameter definitions available to all application paths.</p>"},{"location":"reference/3-controller/#starlite.controller.Controller.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path = normalize_path(self.path or '/')\n</code></pre>"},{"location":"reference/3-controller/#starlite.controller.Controller.response_class","title":"response_class  <code>class-attribute</code>","text":"<pre><code>response_class: Optional[ResponseType]\n</code></pre>  <p>A custom subclass of [starlite.response.Response] to be used as the default response for all route handlers under the controller.</p>"},{"location":"reference/3-controller/#starlite.controller.Controller.response_cookies","title":"response_cookies  <code>class-attribute</code>","text":"<pre><code>response_cookies: Optional[ResponseCookies]\n</code></pre>  <p>A list of [Cookie](starlite.datastructures.Cookie] instances.</p>"},{"location":"reference/3-controller/#starlite.controller.Controller.response_headers","title":"response_headers  <code>class-attribute</code>","text":"<pre><code>response_headers: Optional[ResponseHeadersMap]\n</code></pre>  <p>A string keyed dictionary mapping ResponseHeader instances.</p>"},{"location":"reference/3-controller/#starlite.controller.Controller.security","title":"security  <code>class-attribute</code>","text":"<pre><code>security: Optional[List[SecurityRequirement]]\n</code></pre>  <p>A list of dictionaries that to the schema of all route handlers under the controller.</p>"},{"location":"reference/3-controller/#starlite.controller.Controller.tags","title":"tags  <code>class-attribute</code>","text":"<pre><code>tags: Optional[List[str]]\n</code></pre>  <p>A list of string tags that will be appended to the schema of all route handlers under the controller.</p>"},{"location":"reference/3-controller/#starlite.controller.Controller.type_encoders","title":"type_encoders  <code>class-attribute</code>","text":"<pre><code>type_encoders: Optional[TypeEncodersMap]\n</code></pre>  <p>A mapping of types to callables that transform them into types supported for serialization.</p>"},{"location":"reference/5-dto/","title":"DTO","text":""},{"location":"reference/5-dto/#starlite.dto.DTO","title":"starlite.dto.DTO","text":"<p>         Bases: <code>GenericModel</code>, <code>Generic[T]</code></p> <p>Data Transfer Object.</p>"},{"location":"reference/5-dto/#starlite.dto.DTO.from_model_instance","title":"from_model_instance  <code>classmethod</code>","text":"<pre><code>from_model_instance(model_instance)\n</code></pre>  <p>Given an instance of the source model, create an instance of the given DTO subclass.</p> <p>Parameters:</p>    Name Type Description Default     <code>model_instance</code>  <code>T</code>  <p>instance of source model.</p>  required     <p>Returns:</p>    Type Description      <code>DTO[T]</code>  <p>Instance of the <code>DTO</code> subclass.</p>"},{"location":"reference/5-dto/#starlite.dto.DTO.from_model_instance_async","title":"from_model_instance_async  <code>async</code> <code>classmethod</code>","text":"<pre><code>from_model_instance_async(model_instance)\n</code></pre>  <p>Given an instance of the source model, create an instance of the given DTO subclass asynchronously.</p> <p>Parameters:</p>    Name Type Description Default     <code>model_instance</code>  <code>T</code>  <p>instance of source model.</p>  required     <p>Returns:</p>    Type Description      <code>DTO[T]</code>  <p>Instance of the <code>DTO</code> subclass.</p>"},{"location":"reference/5-dto/#starlite.dto.DTO.to_model_instance","title":"to_model_instance","text":"<pre><code>to_model_instance()\n</code></pre>  <p>Convert the DTO instance into an instance of the original class from which the DTO was created.</p> <p>Returns:</p>    Type Description      <code>T</code>  <p>Instance of source model type.</p>"},{"location":"reference/5-dto/#starlite.dto.DTOFactory","title":"starlite.dto.DTOFactory","text":"<p>Create <code>DTO</code> type.</p> <p>Pydantic models, <code>TypedDict</code> and dataclasses are natively supported. Other types supported  via plugins.</p>"},{"location":"reference/5-dto/#starlite.dto.DTOFactory.__init__","title":"__init__","text":"<pre><code>__init__(plugins=None)\n</code></pre>  <p>Initialize <code>DTOFactory</code></p> <p>Parameters:</p>    Name Type Description Default     <code>plugins</code>  <code>Optional[List[PluginProtocol]]</code>  <p>Plugins used to support <code>DTO</code> construction from arbitrary types.</p>  <code>None</code>"},{"location":"reference/5-dto/#starlite.dto.DTOFactory.__call__","title":"__call__","text":"<pre><code>__call__(name, source, exclude=None, field_mapping=None, field_definitions=None, base=DTO)\n</code></pre>  <p>Given a supported model class - either pydantic, <code>TypedDict</code>, dataclass or a class supported via plugins, create a DTO pydantic model class.</p> <p>An instance of the factory must first be created, passing any plugins to it. It can then be used to create a DTO by calling the instance like a function. Additionally, it can exclude (drop) attributes specifies in the 'exclude' list and remap field names and/or field types.</p> <p>For example, given a pydantic model</p> <pre><code>class MyClass(BaseModel):\n    first: int\n    second: int\n\n\nMyClassDTO = DTOFactory()(\n    MyClass, exclude=[\"first\"], field_mapping={\"second\": (\"third\", float)}\n)\n</code></pre> <p><code>MyClassDTO</code> is now equal to this:</p> <pre><code>class MyClassDTO(BaseModel):\n    third: float\n</code></pre> <p>It can be used as a regular pydantic model:</p> <pre><code>@post(path=\"/my-path\")\ndef create_obj(data: MyClassDTO) -&gt; MyClass:\n    ...\n</code></pre> <p>This will affect parsing, validation and how OpenAPI schema is generated exactly like when using a pydantic model.</p> <p>Note: Although the value generated is a pydantic factory, because it is being generated programmatically, it's currently not possible to extend editor auto-complete for the DTO properties - it will be typed as a Pydantic BaseModel, but no attributes will be inferred in the editor.</p> <p>Parameters:</p>    Name Type Description Default     <code>name</code>  <code>str</code>  <p>This becomes the name of the generated pydantic model.</p>  required    <code>source</code>  <code>type[T]</code>  <p>A type that is either a subclass of <code>BaseModel</code>, <code>TypedDict</code>, a <code>dataclass</code> or any other type with a plugin registered.</p>  required    <code>exclude</code>  <code>list[str] | None</code>  <p>Names of attributes on <code>source</code>. Named Attributes will not have a field generated on the resultant pydantic model.</p>  <code>None</code>    <code>field_mapping</code>  <code>dict[str, str | tuple[str, Any]] | None</code>  <p>Keys are names of attributes on <code>source</code>. Values are either a <code>str</code> to rename an attribute, or tuple <code>(str, Any)</code> to remap both name and type of the attribute.</p>  <code>None</code>    <code>field_definitions</code>  <code>dict[str, tuple[Any, Any]] | None</code>  <p>Add fields to the model that don't exist on <code>source</code>. These are passed as kwargs to <code>pydantic.create_model()</code>.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>Type[DTO[T]]</code>  <p>Type[DTO[T]]</p>    <p>Raises:</p>    Type Description      <code>[ImproperlyConfiguredException][starlite.exceptions.ImproperlyConfiguredException]</code>  <p>If <code>source</code> is not a pydantic model, <code>TypedDict</code> or dataclass, and there is no plugin registered for its type.</p>"},{"location":"reference/6-enums/","title":"Enums","text":""},{"location":"reference/6-enums/#starlite.enums.HttpMethod","title":"starlite.enums.HttpMethod","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p> <p>An Enum for HTTP methods.</p>"},{"location":"reference/6-enums/#starlite.enums.HttpMethod.DELETE","title":"DELETE  <code>class-attribute</code>","text":"<pre><code>DELETE = 'DELETE'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.HttpMethod.GET","title":"GET  <code>class-attribute</code>","text":"<pre><code>GET = 'GET'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.HttpMethod.HEAD","title":"HEAD  <code>class-attribute</code>","text":"<pre><code>HEAD = 'HEAD'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.HttpMethod.OPTIONS","title":"OPTIONS  <code>class-attribute</code>","text":"<pre><code>OPTIONS = 'OPTIONS'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.HttpMethod.PATCH","title":"PATCH  <code>class-attribute</code>","text":"<pre><code>PATCH = 'PATCH'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.HttpMethod.POST","title":"POST  <code>class-attribute</code>","text":"<pre><code>POST = 'POST'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.HttpMethod.PUT","title":"PUT  <code>class-attribute</code>","text":"<pre><code>PUT = 'PUT'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.MediaType","title":"starlite.enums.MediaType","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p> <p>An Enum for 'Content-Type' header values.</p>"},{"location":"reference/6-enums/#starlite.enums.MediaType.HTML","title":"HTML  <code>class-attribute</code>","text":"<pre><code>HTML = 'text/html'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.MediaType.JSON","title":"JSON  <code>class-attribute</code>","text":"<pre><code>JSON = 'application/json'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.MediaType.TEXT","title":"TEXT  <code>class-attribute</code>","text":"<pre><code>TEXT = 'text/plain'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.MediaType.MESSAGEPACK","title":"MESSAGEPACK  <code>class-attribute</code>","text":"<pre><code>MESSAGEPACK = 'application/x-msgpack'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.MediaType.CSS","title":"CSS  <code>class-attribute</code>","text":"<pre><code>CSS = 'text/css'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.MediaType.XML","title":"XML  <code>class-attribute</code>","text":"<pre><code>XML = 'application/xml'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.OpenAPIMediaType","title":"starlite.enums.OpenAPIMediaType","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p> <p>An Enum for OpenAPI specific response 'Content-Type' header values.</p>"},{"location":"reference/6-enums/#starlite.enums.OpenAPIMediaType.OPENAPI_JSON","title":"OPENAPI_JSON  <code>class-attribute</code>","text":"<pre><code>OPENAPI_JSON = 'application/vnd.oai.openapi+json'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.OpenAPIMediaType.OPENAPI_YAML","title":"OPENAPI_YAML  <code>class-attribute</code>","text":"<pre><code>OPENAPI_YAML = 'application/vnd.oai.openapi'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.RequestEncodingType","title":"starlite.enums.RequestEncodingType","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p> <p>An Enum for request 'Content-Type' header values designating encoding formats.</p>"},{"location":"reference/6-enums/#starlite.enums.RequestEncodingType.JSON","title":"JSON  <code>class-attribute</code>","text":"<pre><code>JSON = 'application/json'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.RequestEncodingType.MULTI_PART","title":"MULTI_PART  <code>class-attribute</code>","text":"<pre><code>MULTI_PART = 'multipart/form-data'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.RequestEncodingType.URL_ENCODED","title":"URL_ENCODED  <code>class-attribute</code>","text":"<pre><code>URL_ENCODED = 'application/x-www-form-urlencoded'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.ScopeType","title":"starlite.enums.ScopeType","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p> <p>An Enum for the 'http' key stored under Scope.</p>  Notes <ul> <li>'asgi' is used by Starlite internally and is not part of the specification.</li> </ul>"},{"location":"reference/6-enums/#starlite.enums.ScopeType.HTTP","title":"HTTP  <code>class-attribute</code>","text":"<pre><code>HTTP = 'http'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.ScopeType.WEBSOCKET","title":"WEBSOCKET  <code>class-attribute</code>","text":"<pre><code>WEBSOCKET = 'websocket'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.ScopeType.ASGI","title":"ASGI  <code>class-attribute</code>","text":"<pre><code>ASGI = 'asgi'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.ParamType","title":"starlite.enums.ParamType","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p> <p>An Enum for the types of parameters a request can receive.</p>"},{"location":"reference/6-enums/#starlite.enums.ParamType.PATH","title":"PATH  <code>class-attribute</code>","text":"<pre><code>PATH = 'path'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.ParamType.QUERY","title":"QUERY  <code>class-attribute</code>","text":"<pre><code>QUERY = 'query'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.ParamType.COOKIE","title":"COOKIE  <code>class-attribute</code>","text":"<pre><code>COOKIE = 'cookie'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.ParamType.HEADER","title":"HEADER  <code>class-attribute</code>","text":"<pre><code>HEADER = 'header'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.CompressionEncoding","title":"starlite.enums.CompressionEncoding","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p> <p>An Enum for supported compression encodings.</p>"},{"location":"reference/6-enums/#starlite.enums.CompressionEncoding.GZIP","title":"GZIP  <code>class-attribute</code>","text":"<pre><code>GZIP = 'gzip'\n</code></pre>"},{"location":"reference/6-enums/#starlite.enums.CompressionEncoding.BROTLI","title":"BROTLI  <code>class-attribute</code>","text":"<pre><code>BROTLI = 'br'\n</code></pre>"},{"location":"reference/cache/0-base-cache/","title":"Cache Backend Protocol","text":""},{"location":"reference/cache/0-base-cache/#starlite.cache.CacheBackendProtocol","title":"starlite.cache.CacheBackendProtocol","text":"<p>         Bases: <code>Protocol</code></p> <p>Protocol for cache backends.</p>"},{"location":"reference/cache/0-base-cache/#starlite.cache.base.CacheBackendProtocol.get","title":"get  <code>async</code>","text":"<pre><code>get(key)\n</code></pre>  <p>Retrieve a value from cache corresponding to the given key.</p> <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>str</code>  <p>name of cached value.</p>  required     <p>Returns:</p>    Type Description      <code>Any</code>  <p>Cached value if existing else <code>None</code>.</p>"},{"location":"reference/cache/0-base-cache/#starlite.cache.base.CacheBackendProtocol.set","title":"set  <code>async</code>","text":"<pre><code>set(key, value, expiration)\n</code></pre>  <p>Set a value in cache for a given key for a duration determined by expiration.</p> <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>str</code>  <p>key to cache <code>value</code> under.</p>  required    <code>value</code>  <code>Any</code>  <p>the value to be cached.</p>  required    <code>expiration</code>  <code>int</code>  <p>expiration of cached value in seconds.</p>  required      Notes <ul> <li>expiration is in seconds.</li> <li>return value is not used by Starlite internally.</li> </ul>  <p>Returns:</p>    Type Description      <code>Any</code>  <p>Any</p>"},{"location":"reference/cache/0-base-cache/#starlite.cache.base.CacheBackendProtocol.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key)\n</code></pre>  <p>Delete a value from the cache and remove the given key.</p> <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>str</code>  <p>key to be deleted from the cache.</p>  required      Notes <ul> <li>return value is not used by Starlite internally.</li> </ul>  <p>Returns:</p>    Type Description      <code>Any</code>  <p>Any</p>"},{"location":"reference/cache/0-base-cache/#starlite.cache.Cache","title":"starlite.cache.Cache","text":"<p>Wrapper for a provided CacheBackend that ensures it is called in an async and thread-safe fashion.</p> <p>This enables the use of normal sync libraries (such as the standard Redis python client) for caching responses.</p>"},{"location":"reference/cache/0-base-cache/#starlite.cache.base.Cache.__init__","title":"__init__","text":"<pre><code>__init__(backend, default_expiration, cache_key_builder)\n</code></pre>  <p>Initialize <code>Cache</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>backend</code>  <code>CacheBackendProtocol</code>  <p>A class instance fulfilling the Starlite CacheBackendProtocol.</p>  required    <code>default_expiration</code>  <code>int</code>  <p>Default value (in seconds) for cache expiration.</p>  required    <code>cache_key_builder</code>  <code>CacheKeyBuilder</code>  <p>A function that receives a request object and returns a unique cache key.</p>  required"},{"location":"reference/cache/0-base-cache/#starlite.cache.base.Cache.get","title":"get  <code>async</code>","text":"<pre><code>get(key)\n</code></pre>  <p>Proxy 'self.backend.get'.</p> <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>str</code>  <p>name of cached value.</p>  required     <p>Returns:</p>    Type Description      <code>Any</code>  <p>Cached value if existing else <code>None</code>.</p>"},{"location":"reference/cache/0-base-cache/#starlite.cache.base.Cache.set","title":"set  <code>async</code>","text":"<pre><code>set(key, value, expiration=None)\n</code></pre>  <p>Proxy 'self.backend.set'.</p> <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>str</code>  <p>key to cache <code>value</code> under.</p>  required    <code>value</code>  <code>Any</code>  <p>the value to be cached.</p>  required    <code>expiration</code>  <code>Optional[int]</code>  <p>expiration of cached value in seconds.</p>  <code>None</code>      Notes <ul> <li>expiration is in seconds.</li> <li>return value is not used by Starlite internally.</li> </ul>  <p>Returns:</p>    Type Description      <code>Any</code>  <p>Any</p>"},{"location":"reference/cache/0-base-cache/#starlite.cache.base.Cache.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key)\n</code></pre>  <p>Proxy 'self.backend.delete'.</p> <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>str</code>  <p>key to be deleted from the cache.</p>  required      Notes <ul> <li>return value is not used by Starlite internally.</li> </ul>  <p>Returns:</p>    Type Description      <code>Any</code>  <p>Any</p>"},{"location":"reference/cache/0-base-cache/#starlite.cache.base.Cache.build_cache_key","title":"build_cache_key","text":"<pre><code>build_cache_key(request, cache_key_builder)\n</code></pre>  <p>Construct a unique cache key from the request instance.</p> <p>Parameters:</p>    Name Type Description Default     <code>request</code>  <code>Request</code>  <p>A Request instance.</p>  required    <code>cache_key_builder</code>  <code>Optional[CacheKeyBuilder]</code>  <p>An optional CacheKeyBuilder function.</p>  required     <p>Returns:</p>    Type Description      <code>str</code>  <p>A unique cache key string.</p>"},{"location":"reference/cache/1-simple-cache/","title":"Simple Cache Backend","text":""},{"location":"reference/cache/1-simple-cache/#starlite.cache.SimpleCacheBackend","title":"starlite.cache.SimpleCacheBackend","text":"<p>         Bases: <code>CacheBackendProtocol</code></p> <p>In-memory cache backend.</p>"},{"location":"reference/cache/1-simple-cache/#starlite.cache.simple_cache_backend.SimpleCacheBackend.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre>  <p>Initialize <code>SimpleCacheBackend</code></p>"},{"location":"reference/cache/1-simple-cache/#starlite.cache.simple_cache_backend.SimpleCacheBackend.get","title":"get  <code>async</code>","text":"<pre><code>get(key)\n</code></pre>  <p>Retrieve value from cache corresponding to the given key.</p> <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>str</code>  <p>name of cached value.</p>  required     <p>Returns:</p>    Type Description      <code>Any</code>  <p>Cached value or <code>None</code>.</p>"},{"location":"reference/cache/1-simple-cache/#starlite.cache.simple_cache_backend.SimpleCacheBackend.set","title":"set  <code>async</code>","text":"<pre><code>set(key, value, expiration)\n</code></pre>  <p>Set a value in cache for a given key with a given expiration in seconds.</p> <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>str</code>  <p>key to cache <code>value</code> under.</p>  required    <code>value</code>  <code>Any</code>  <p>the value to be cached.</p>  required    <code>expiration</code>  <code>int</code>  <p>expiration of cached value in seconds.</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/cache/1-simple-cache/#starlite.cache.simple_cache_backend.SimpleCacheBackend.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key)\n</code></pre>  <p>Remove a value from the cache for a given key.</p> <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>str</code>  <p>key to be deleted from the cache.</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/cache/2-redis-cache/","title":"Redis Cache Backend","text":""},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackend","title":"starlite.cache.redis_cache_backend.RedisCacheBackend","text":"<p>         Bases: <code>CacheBackendProtocol</code></p> <p>Redis-based cache backend.</p>"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackend.__init__","title":"__init__","text":"<pre><code>__init__(config)\n</code></pre>  <p>Initialize <code>RedisCacheBackend</code></p> <p>Parameters:</p>    Name Type Description Default     <code>config</code>  <code>RedisCacheBackendConfig</code>  <p>required configuration to connect to Redis.</p>  required"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackend.get","title":"get  <code>async</code>","text":"<pre><code>get(key)\n</code></pre>  <p>Retrieve a value from cache corresponding to the given key.</p> <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>str</code>  <p>name of cached value.</p>  required     <p>Returns:</p>    Type Description      <code>Any</code>  <p>Cached value if existing else <code>None</code>.</p>"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackend.set","title":"set  <code>async</code>","text":"<pre><code>set(key, value, expiration)\n</code></pre>  <p>Set a value in cache for a given key for a duration determined by expiration.</p> <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>str</code>  <p>key to cache <code>value</code> under.</p>  required    <code>value</code>  <code>Any</code>  <p>the value to be cached.</p>  required    <code>expiration</code>  <code>int</code>  <p>expiration of cached value in seconds.</p>  required      Notes <ul> <li>expiration is in seconds.</li> <li>return value is not used by Starlite internally.</li> </ul>  <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackend.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key)\n</code></pre>  <p>Delete a value from the cache and removes the given key.</p> <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>str</code>  <p>key to be deleted from the cache.</p>  required      Notes <ul> <li>return value is not used by Starlite internally.</li> </ul>  <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackendConfig","title":"starlite.cache.redis_cache_backend.RedisCacheBackendConfig","text":"<p>         Bases: <code>BaseModel</code></p> <p>Redis cache backend configuration.</p>"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackendConfig.url","title":"url  <code>class-attribute</code>","text":"<pre><code>url: str\n</code></pre>  <p>Redis connection URL.</p>"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackendConfig.db","title":"db  <code>class-attribute</code>","text":"<pre><code>db: Optional[int] = None\n</code></pre>  <p>Redis DB ID (optional)</p>"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackendConfig.port","title":"port  <code>class-attribute</code>","text":"<pre><code>port: Optional[int] = None\n</code></pre>  <p>Redis port (optional)</p>"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackendConfig.username","title":"username  <code>class-attribute</code>","text":"<pre><code>username: Optional[str] = None\n</code></pre>  <p>A username to use when connecting to Redis (optional)</p>"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackendConfig.password","title":"password  <code>class-attribute</code>","text":"<pre><code>password: Optional[str] = None\n</code></pre>  <p>A password to use when connecting to Redis (optional)</p>"},{"location":"reference/cache/3-memcached-cache/","title":"Memcached Cache Backend","text":""},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackend","title":"starlite.cache.memcached_cache_backend.MemcachedCacheBackend","text":"<p>         Bases: <code>CacheBackendProtocol</code></p> <p>Memcached-based cache backend.</p>"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackend.__init__","title":"__init__","text":"<pre><code>__init__(config)\n</code></pre>  <p>Initialize <code>MemcachedCacheBackend</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>config</code>  <code>MemcachedCacheBackendConfig</code>  <p>required configuration to connect to memcached.</p>  required"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackend.get","title":"get  <code>async</code>","text":"<pre><code>get(key)\n</code></pre>  <p>Retrieve a value from cache corresponding to the given key.</p> <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>str</code>  <p>name of cached value.</p>  required     <p>Returns:</p>    Type Description      <code>Any</code>  <p>Cached value if existing else <code>None</code>.</p>"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackend.set","title":"set  <code>async</code>","text":"<pre><code>set(key, value, expiration)\n</code></pre>  <p>Set sa value in cache for a given key for a duration determined by expiration.</p> <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>str</code>  <p>key to cache <code>value</code> under.</p>  required    <code>value</code>  <code>Any</code>  <p>the value to be cached.</p>  required    <code>expiration</code>  <code>int</code>  <p>expiration of cached value in seconds.</p>  required      Notes <ul> <li>expiration is in seconds.</li> <li>return value is not used by Starlite internally.</li> </ul>  <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackend.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key)\n</code></pre>  <p>Delete a value from the cache and remove the given key.</p> <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>str</code>  <p>key to be deleted from the cache.</p>  required      Notes <ul> <li>return value is not used by Starlite internally.</li> </ul>  <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackendConfig","title":"starlite.cache.memcached_cache_backend.MemcachedCacheBackendConfig","text":"<p>         Bases: <code>BaseModel</code></p> <p>Memcached cache backend configuration.</p>"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackendConfig.host","title":"host  <code>class-attribute</code>","text":"<pre><code>host: str\n</code></pre>  <p>Memcached host.</p>"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackendConfig.port","title":"port  <code>class-attribute</code>","text":"<pre><code>port: Optional[int] = None\n</code></pre>  <p>memcached port (optional, defaults to 11211)</p>"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackendConfig.pool_size","title":"pool_size  <code>class-attribute</code>","text":"<pre><code>pool_size: Optional[int] = None\n</code></pre>  <p>Maximum number of memcached open connections (optional, defaults to 2)</p>"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackendConfig.pool_minsize","title":"pool_minsize  <code>class-attribute</code>","text":"<pre><code>pool_minsize: Optional[int] = None\n</code></pre>  <p>memcached minimum pool size (optional, by default set to <code>pool_size</code>)</p>"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackendConfig.serialize","title":"serialize  <code>class-attribute</code>","text":"<pre><code>serialize: Callable[[Any], bytes] = pickle.dumps\n</code></pre>  <p>A callable to serialize data that goes into the cache from an object to bytes, defaults to <code>pickle.dumps</code></p>"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackendConfig.deserialize","title":"deserialize  <code>class-attribute</code>","text":"<pre><code>deserialize: Callable[[bytes], Any] = pickle.loads\n</code></pre>  <p>A callable to deserialize data coming from the cache from bytes to an object, defaults to <code>pickle.loads</code></p>"},{"location":"reference/config/0-app-config/","title":"App Config","text":""},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig","title":"starlite.config.app.AppConfig","text":"<p>         Bases: <code>BaseModel</code></p> <p>The parameters provided to the <code>Starlite</code> app are used to instantiate an instance, and then the instance is passed to any callbacks registered to <code>on_app_init</code> in the order they are provided.</p> <p>The final attribute values are used to instantiate the application object.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.after_exception","title":"after_exception  <code>class-attribute</code>","text":"<pre><code>after_exception: SingleOrList[AfterExceptionHookHandler]\n</code></pre>  <p>An application level exception hook handler or list thereof.</p> <p>This hook is called after an exception occurs. In difference to exception handlers, it is not meant to return a response - only to process the exception (e.g. log it, send it to Sentry etc.).</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.after_request","title":"after_request  <code>class-attribute</code>","text":"<pre><code>after_request: Optional[AfterRequestHookHandler]\n</code></pre>  <p>A sync or async function executed after the route handler function returned and the response object has been resolved.</p> <p>Receives the response object which may be any subclass of Response.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.after_response","title":"after_response  <code>class-attribute</code>","text":"<pre><code>after_response: Optional[AfterResponseHookHandler]\n</code></pre>  <p>A sync or async function called after the response has been awaited. It receives the.</p> <p>Request object and should not return any values.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.after_shutdown","title":"after_shutdown  <code>class-attribute</code>","text":"<pre><code>after_shutdown: SingleOrList[LifeSpanHookHandler]\n</code></pre>  <p>An application level life-span hook handler or list thereof.</p> <p>This hook is called during the ASGI shutdown, after all callables in the 'on_shutdown' list have been called.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.after_startup","title":"after_startup  <code>class-attribute</code>","text":"<pre><code>after_startup: SingleOrList[LifeSpanHookHandler]\n</code></pre>  <p>An application level life-span hook handler or list thereof.</p> <p>This hook is called during the ASGI startup, after all callables in the 'on_startup' list have been called.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.allowed_hosts","title":"allowed_hosts  <code>class-attribute</code>","text":"<pre><code>allowed_hosts: Optional[Union[List[str], AllowedHostsConfig]]\n</code></pre>  <p>If set enables the builtin allowed hosts middleware.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.before_request","title":"before_request  <code>class-attribute</code>","text":"<pre><code>before_request: Optional[BeforeRequestHookHandler]\n</code></pre>  <p>A sync or async function called immediately before calling the route handler. Receives the.</p> <p>Request instance and any non-<code>None</code> return value is used for the response, bypassing the route handler.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.before_send","title":"before_send  <code>class-attribute</code>","text":"<pre><code>before_send: SingleOrList[BeforeMessageSendHookHandler]\n</code></pre>  <p>An application level before send hook handler or list thereof.</p> <p>This hook is called when the ASGI send function is called.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.before_shutdown","title":"before_shutdown  <code>class-attribute</code>","text":"<pre><code>before_shutdown: SingleOrList[LifeSpanHookHandler]\n</code></pre>  <p>An application level life-span hook handler or list thereof.</p> <p>This hook is called during the ASGI shutdown, before any callables in the 'on_shutdown' list have been called.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.before_startup","title":"before_startup  <code>class-attribute</code>","text":"<pre><code>before_startup: SingleOrList[LifeSpanHookHandler]\n</code></pre>  <p>An application level life-span hook handler or list thereof.</p> <p>This hook is called during the ASGI startup, before any callables in the 'on_startup' list have been called.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.cache_config","title":"cache_config  <code>class-attribute</code>","text":"<pre><code>cache_config: CacheConfig\n</code></pre>  <p>Configures caching behavior of the application.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.cache_control","title":"cache_control  <code>class-attribute</code>","text":"<pre><code>cache_control: Optional[CacheControlHeader]\n</code></pre>  <p>A <code>cache-control</code> header of type CacheControlHeader to add to route handlers of this app.</p> <p>Can be overridden by route handlers.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.compression_config","title":"compression_config  <code>class-attribute</code>","text":"<pre><code>compression_config: Optional[CompressionConfig]\n</code></pre>  <p>Configures compression behaviour of the application, this enabled a builtin or user defined Compression middleware.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.cors_config","title":"cors_config  <code>class-attribute</code>","text":"<pre><code>cors_config: Optional[CORSConfig]\n</code></pre>  <p>If set this enables the builtin CORS middleware.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.csrf_config","title":"csrf_config  <code>class-attribute</code>","text":"<pre><code>csrf_config: Optional[CSRFConfig]\n</code></pre>  <p>If set this enables the builtin CSRF middleware.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.debug","title":"debug  <code>class-attribute</code>","text":"<pre><code>debug: bool\n</code></pre>  <p>If <code>True</code>, app errors rendered as HTML with a stack trace.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.dependencies","title":"dependencies  <code>class-attribute</code>","text":"<pre><code>dependencies: Dict[str, Provide]\n</code></pre>  <p>A string keyed dictionary of dependency Provider instances.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.etag","title":"etag  <code>class-attribute</code>","text":"<pre><code>etag: Optional[ETag]\n</code></pre>  <p>An <code>etag</code> header of type ETag to add to route handlers of this app.</p> <p>Can be overridden by route handlers.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.exception_handlers","title":"exception_handlers  <code>class-attribute</code>","text":"<pre><code>exception_handlers: ExceptionHandlersMap\n</code></pre>  <p>A dictionary that maps handler functions to status codes and/or exception types.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.guards","title":"guards  <code>class-attribute</code>","text":"<pre><code>guards: List[Guard]\n</code></pre>  <p>A list of Guard callables.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.logging_config","title":"logging_config  <code>class-attribute</code>","text":"<pre><code>logging_config: Optional[BaseLoggingConfig]\n</code></pre>  <p>An instance of BaseLoggingConfig subclass.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.middleware","title":"middleware  <code>class-attribute</code>","text":"<pre><code>middleware: List[Middleware]\n</code></pre>  <p>A list of Middleware.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.on_shutdown","title":"on_shutdown  <code>class-attribute</code>","text":"<pre><code>on_shutdown: List[LifeSpanHandler]\n</code></pre>  <p>A list of LifeSpanHandler called during application shutdown.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.on_startup","title":"on_startup  <code>class-attribute</code>","text":"<pre><code>on_startup: List[LifeSpanHandler]\n</code></pre>  <p>A list of LifeSpanHandler called during application startup.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.openapi_config","title":"openapi_config  <code>class-attribute</code>","text":"<pre><code>openapi_config: Optional[OpenAPIConfig]\n</code></pre>  <p>Defaults to DEFAULT_OPENAPI_CONFIG</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.opt","title":"opt  <code>class-attribute</code>","text":"<pre><code>opt: Dict[str, Any]\n</code></pre>  <p>A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope.</p> <p>Can be overridden by routers and router handlers.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.parameters","title":"parameters  <code>class-attribute</code>","text":"<pre><code>parameters: ParametersMap\n</code></pre>  <p>A mapping of Parameter definitions available to all application paths.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.plugins","title":"plugins  <code>class-attribute</code>","text":"<pre><code>plugins: List[PluginProtocol]\n</code></pre>  <p>List of PluginProtocol.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.request_class","title":"request_class  <code>class-attribute</code>","text":"<pre><code>request_class: Optional[Type[Request]]\n</code></pre>  <p>An optional subclass of Request to use for http connections.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.response_class","title":"response_class  <code>class-attribute</code>","text":"<pre><code>response_class: Optional[ResponseType]\n</code></pre>  <p>A custom subclass of [starlite.response.Response] to be used as the app's default response.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.response_cookies","title":"response_cookies  <code>class-attribute</code>","text":"<pre><code>response_cookies: ResponseCookies\n</code></pre>  <p>A list of [Cookie](starlite.datastructures.Cookie] instances.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.response_headers","title":"response_headers  <code>class-attribute</code>","text":"<pre><code>response_headers: ResponseHeadersMap\n</code></pre>  <p>A string keyed dictionary mapping ResponseHeader instances.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.route_handlers","title":"route_handlers  <code>class-attribute</code>","text":"<pre><code>route_handlers: List[ControllerRouterHandler]\n</code></pre>  <p>A required list of route handlers, which can include instances of Router, subclasses of.</p> <p>Controller or any function decorated by the route handler decorators.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.security","title":"security  <code>class-attribute</code>","text":"<pre><code>security: List[SecurityRequirement]\n</code></pre>  <p>A list of dictionaries that will be added to the schema of all route handlers in the application. See.</p> <p>SecurityRequirement for details.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.static_files_config","title":"static_files_config  <code>class-attribute</code>","text":"<pre><code>static_files_config: SingleOrList[StaticFilesConfig]\n</code></pre>  <p>An instance or list of StaticFilesConfig.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.tags","title":"tags  <code>class-attribute</code>","text":"<pre><code>tags: List[str]\n</code></pre>  <p>A list of string tags that will be appended to the schema of all route handlers under the application.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.template_config","title":"template_config  <code>class-attribute</code>","text":"<pre><code>template_config: Optional[TemplateConfig]\n</code></pre>  <p>An instance of TemplateConfig.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.type_encoders","title":"type_encoders  <code>class-attribute</code>","text":"<pre><code>type_encoders: Optional[TypeEncodersMap] = None\n</code></pre>  <p>A mapping of types to callables that transform them into types supported for serialization.</p>"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.websocket_class","title":"websocket_class  <code>class-attribute</code>","text":"<pre><code>websocket_class: Optional[Type[WebSocket]]\n</code></pre>  <p>An optional subclass of WebSocket to use for websocket connections.</p>"},{"location":"reference/config/1-cache-config/","title":"Cache Config","text":""},{"location":"reference/config/1-cache-config/#starlite.config.cache.CacheConfig","title":"starlite.config.cache.CacheConfig","text":"<p>         Bases: <code>BaseModel</code></p> <p>Configuration for response caching.</p> <p>To enable response caching, pass an instance of this class to the Starlite constructor using the 'cache_config' key.</p>"},{"location":"reference/config/1-cache-config/#starlite.config.cache.CacheConfig.backend","title":"backend  <code>class-attribute</code>","text":"<pre><code>backend: Optional[CacheBackendProtocol] = None\n</code></pre>  <p>Instance conforming to CacheBackendProtocol, default.</p> <p>SimpleCacheBackend()</p>"},{"location":"reference/config/1-cache-config/#starlite.config.cache.CacheConfig.expiration","title":"expiration  <code>class-attribute</code>","text":"<pre><code>expiration: int = 60\n</code></pre>  <p>Default cache expiration in seconds.</p>"},{"location":"reference/config/1-cache-config/#starlite.config.cache.CacheConfig.cache_key_builder","title":"cache_key_builder  <code>class-attribute</code>","text":"<pre><code>cache_key_builder: CacheKeyBuilder = default_cache_key_builder\n</code></pre>  <p>CacheKeyBuilder,</p> <p>default_cache_key_builder if not provided</p>"},{"location":"reference/config/1-cache-config/#starlite.config.cache.CacheConfig.to_cache","title":"to_cache","text":"<pre><code>to_cache()\n</code></pre>  <p>Create a cache wrapper from the config.</p> <p>Returns:</p>    Type Description      <code>Cache</code>  <p>An instance of Cache</p>"},{"location":"reference/config/1-cache-config/#starlite.config.cache.default_cache_key_builder","title":"starlite.config.cache.default_cache_key_builder","text":"<pre><code>starlite.config.cache.default_cache_key_builder(request)\n</code></pre>  <p>Given a request object, returns a cache key by combining the path with the sorted query params.</p> <p>Parameters:</p>    Name Type Description Default     <code>request</code>  <code>Request</code>  <p>request used to generate cache key.</p>  required     <p>Returns:</p>    Name Type Description     <code>str</code>  <code>str</code>  <p>combination of url path and query parameters</p>"},{"location":"reference/config/2-cors-config/","title":"CORS Config","text":""},{"location":"reference/config/2-cors-config/#starlite.config.cors.CORSConfig","title":"starlite.config.cors.CORSConfig","text":"<p>         Bases: <code>BaseModel</code></p> <p>Configuration for CORS (Cross-Origin Resource Sharing).</p> <p>To enable CORS, pass an instance of this class to the Starlite constructor using the 'cors_config' key.</p>"},{"location":"reference/config/2-cors-config/#starlite.config.cors.CORSConfig.allow_origins","title":"allow_origins  <code>class-attribute</code>","text":"<pre><code>allow_origins: List[str] = ['*']\n</code></pre>  <p>List of origins that are allowed.</p> <p>Can use '' in any component of the path, e.g. 'domain.'. Sets the 'Access-Control-Allow-Origin' header.</p>"},{"location":"reference/config/2-cors-config/#starlite.config.cors.CORSConfig.allow_methods","title":"allow_methods  <code>class-attribute</code>","text":"<pre><code>allow_methods: List[Union[Literal['*'], Method]] = ['*']\n</code></pre>  <p>List of allowed HTTP methods.</p> <p>Sets the 'Access-Control-Allow-Methods' header.</p>"},{"location":"reference/config/2-cors-config/#starlite.config.cors.CORSConfig.allow_headers","title":"allow_headers  <code>class-attribute</code>","text":"<pre><code>allow_headers: List[str] = ['*']\n</code></pre>  <p>List of allowed headers.</p> <p>Sets the 'Access-Control-Allow-Headers' header.</p>"},{"location":"reference/config/2-cors-config/#starlite.config.cors.CORSConfig.allow_credentials","title":"allow_credentials  <code>class-attribute</code>","text":"<pre><code>allow_credentials: bool = False\n</code></pre>  <p>Boolean dictating whether or not to set the 'Access-Control-Allow-Credentials' header.</p>"},{"location":"reference/config/2-cors-config/#starlite.config.cors.CORSConfig.allow_origin_regex","title":"allow_origin_regex  <code>class-attribute</code>","text":"<pre><code>allow_origin_regex: Optional[str] = None\n</code></pre>  <p>Regex to match origins against.</p>"},{"location":"reference/config/2-cors-config/#starlite.config.cors.CORSConfig.expose_headers","title":"expose_headers  <code>class-attribute</code>","text":"<pre><code>expose_headers: List[str] = []\n</code></pre>  <p>List of headers that are exposed via the 'Access-Control-Expose-Headers' header.</p>"},{"location":"reference/config/2-cors-config/#starlite.config.cors.CORSConfig.max_age","title":"max_age  <code>class-attribute</code>","text":"<pre><code>max_age: int = 600\n</code></pre>  <p>Response caching TTL in seconds, defaults to 600.</p> <p>Sets the 'Access-Control-Max-Age' header.</p>"},{"location":"reference/config/3-csrf-config/","title":"CSRF Config","text":""},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig","title":"starlite.config.csrf.CSRFConfig","text":"<p>         Bases: <code>BaseModel</code></p> <p>Configuration for CSRF (Cross Site Request Forgery) protection.</p> <p>To enable CSRF protection, pass an instance of this class to the Starlite constructor using the 'csrf_config' key.</p>"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.cookie_domain","title":"cookie_domain  <code>class-attribute</code>","text":"<pre><code>cookie_domain: Optional[str] = None\n</code></pre>  <p>Specifies which hosts can receive the cookie.</p>"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.cookie_httponly","title":"cookie_httponly  <code>class-attribute</code>","text":"<pre><code>cookie_httponly: bool = False\n</code></pre>  <p>A boolean value indicating whether to set the <code>HttpOnly</code> attribute on the cookie.</p>"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.cookie_name","title":"cookie_name  <code>class-attribute</code>","text":"<pre><code>cookie_name: str = 'csrftoken'\n</code></pre>  <p>The CSRF cookie name.</p>"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.cookie_path","title":"cookie_path  <code>class-attribute</code>","text":"<pre><code>cookie_path: str = '/'\n</code></pre>  <p>The CSRF cookie path.</p>"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.cookie_samesite","title":"cookie_samesite  <code>class-attribute</code>","text":"<pre><code>cookie_samesite: Literal['lax', 'strict', 'none'] = 'lax'\n</code></pre>  <p>The value to set in the <code>SameSite</code> attribute of the cookie.</p>"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.cookie_secure","title":"cookie_secure  <code>class-attribute</code>","text":"<pre><code>cookie_secure: bool = False\n</code></pre>  <p>A boolean value indicating whether to set the <code>Secure</code> attribute on the cookie.</p>"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.exclude","title":"exclude  <code>class-attribute</code>","text":"<pre><code>exclude: Optional[Union[str, List[str]]] = None\n</code></pre>  <p>A pattern or list of patterns to skip in the CSRF middleware.</p>"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.exclude_from_csrf_key","title":"exclude_from_csrf_key  <code>class-attribute</code>","text":"<pre><code>exclude_from_csrf_key: str = 'exclude_from_csrf'\n</code></pre>  <p>An identifier to use on routes to disable CSRF for a particular route.</p>"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.header_name","title":"header_name  <code>class-attribute</code>","text":"<pre><code>header_name: str = 'x-csrftoken'\n</code></pre>  <p>The header that will be expected in each request.</p>"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.safe_methods","title":"safe_methods  <code>class-attribute</code>","text":"<pre><code>safe_methods: Set[Method] = {'GET', 'HEAD'}\n</code></pre>  <p>A set of \"safe methods\" that can set the cookie.</p>"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.secret","title":"secret  <code>class-attribute</code>","text":"<pre><code>secret: str\n</code></pre>  <p>A string that is used to create an HMAC to sign the CSRF token.</p>"},{"location":"reference/config/4-compression-config/","title":"Compression Config","text":""},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig","title":"starlite.config.compression.CompressionConfig","text":"<p>         Bases: <code>BaseModel</code></p> <p>Configuration for response compression.</p> <p>To enable response compression, pass an instance of this class to the Starlite constructor using the 'compression_config' key.</p>"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.backend","title":"backend  <code>class-attribute</code>","text":"<pre><code>backend: Literal['gzip', 'brotli']\n</code></pre>  <p>Literal of \"gzip\" or \"brotli\".</p>"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.brotli_gzip_fallback","title":"brotli_gzip_fallback  <code>class-attribute</code>","text":"<pre><code>brotli_gzip_fallback: bool = True\n</code></pre>  <p>Use GZIP if Brotli is not supported.</p>"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.brotli_lgblock","title":"brotli_lgblock  <code>class-attribute</code>","text":"<pre><code>brotli_lgblock: Literal[0, 16, 17, 18, 19, 20, 21, 22, 23, 24] = 0\n</code></pre>  <p>Base 2 logarithm of the maximum input block size.</p> <p>Range is 16 to 24. If set to 0, the value will be set based on the quality. Defaults to 0.</p>"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.brotli_lgwin","title":"brotli_lgwin  <code>class-attribute</code>","text":"<pre><code>brotli_lgwin: conint(ge=10, le=24) = 22\n</code></pre>  <p>Base 2 logarithm of size.</p> <p>Range is 10 to 24. Defaults to 22.</p>"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.brotli_mode","title":"brotli_mode  <code>class-attribute</code>","text":"<pre><code>brotli_mode: Literal['generic', 'text', 'font'] = 'text'\n</code></pre>  <p>MODE_GENERIC, MODE_TEXT (for UTF-8 format text input, default) or MODE_FONT (for WOFF 2.0).</p>"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.brotli_quality","title":"brotli_quality  <code>class-attribute</code>","text":"<pre><code>brotli_quality: conint(ge=0, le=11) = 5\n</code></pre>  <p>Range [0-11], Controls the compression-speed vs compression-density tradeoff.</p> <p>The higher the quality, the slower the compression.</p>"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.exclude","title":"exclude  <code>class-attribute</code>","text":"<pre><code>exclude: Optional[Union[str, List[str]]] = None\n</code></pre>  <p>A pattern or list of patterns to skip in the compression middleware.</p>"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.exclude_opt_key","title":"exclude_opt_key  <code>class-attribute</code>","text":"<pre><code>exclude_opt_key: Optional[str] = None\n</code></pre>  <p>An identifier to use on routes to disable compression for a particular route.</p>"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.gzip_compress_level","title":"gzip_compress_level  <code>class-attribute</code>","text":"<pre><code>gzip_compress_level: conint(ge=0, le=9) = 9\n</code></pre>  <p>Range [0-9], see official docs.</p>"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.middleware_class","title":"middleware_class  <code>class-attribute</code>","text":"<pre><code>middleware_class: Type[CompressionMiddleware] = CompressionMiddleware\n</code></pre>  <p>Middleware class to use, should be a subclass of CompressionMiddleware.</p>"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.minimum_size","title":"minimum_size  <code>class-attribute</code>","text":"<pre><code>minimum_size: conint(gt=0) = 500\n</code></pre>  <p>Minimum response size (bytes) to enable compression, affects all backends.</p>"},{"location":"reference/config/5-openapi-config/","title":"OpenAPI Config","text":""},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig","title":"starlite.config.openapi.OpenAPIConfig","text":"<p>         Bases: <code>BaseModel</code></p> <p>Configuration for OpenAPI.</p> <p>To enable OpenAPI schema generation and serving, pass an instance of this class to the Starlite constructor using the 'openapi_config' kwargs.</p>"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.by_alias","title":"by_alias  <code>class-attribute</code>","text":"<pre><code>by_alias: bool = True\n</code></pre>  <p>Render pydantic model schema using field aliases, if defined.</p>"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.contact","title":"contact  <code>class-attribute</code>","text":"<pre><code>contact: Optional[Contact] = None\n</code></pre>  <p>API contact information, should be an Contact instance.</p>"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.create_examples","title":"create_examples  <code>class-attribute</code>","text":"<pre><code>create_examples: bool = False\n</code></pre>  <p>Generate examples using the pydantic-factories library.</p>"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.description","title":"description  <code>class-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>  <p>API description.</p>"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.enabled_endpoints","title":"enabled_endpoints  <code>class-attribute</code>","text":"<pre><code>enabled_endpoints: Set[str] = {'redoc', 'swagger', 'elements', 'openapi.json', 'openapi.yaml'}\n</code></pre>  <p>A set of the enabled documentation sites and schema download endpoints.</p>"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.external_docs","title":"external_docs  <code>class-attribute</code>","text":"<pre><code>external_docs: Optional[ExternalDocumentation] = None\n</code></pre>  <p>Links to external documentation.</p> <p>Should be an instance of ExternalDocumentation.</p>"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.license","title":"license  <code>class-attribute</code>","text":"<pre><code>license: Optional[License] = None\n</code></pre>  <p>API Licensing information.</p> <p>Should be an instance of License.</p>"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.openapi_controller","title":"openapi_controller  <code>class-attribute</code>","text":"<pre><code>openapi_controller: Type[OpenAPIController] = OpenAPIController\n</code></pre>  <p>Controller for generating OpenAPI routes.</p> <p>Must be subclass of OpenAPIController.</p>"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.root_schema_site","title":"root_schema_site  <code>class-attribute</code>","text":"<pre><code>root_schema_site: Literal['redoc', 'swagger', 'elements'] = 'redoc'\n</code></pre>  <p>The static schema generator to use for the \"root\" path of <code>/schema/</code>.</p>"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.security","title":"security  <code>class-attribute</code>","text":"<pre><code>security: Optional[List[SecurityRequirement]] = None\n</code></pre>  <p>API Security requirements information.</p> <p>Should be an instance of SecurityRequirement.</p>"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.servers","title":"servers  <code>class-attribute</code>","text":"<pre><code>servers: List[Server] = [Server(url='/')]\n</code></pre>  <p>A list of Server instances.</p>"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.summary","title":"summary  <code>class-attribute</code>","text":"<pre><code>summary: Optional[str] = None\n</code></pre>  <p>A summary text.</p>"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.tags","title":"tags  <code>class-attribute</code>","text":"<pre><code>tags: Optional[List[Tag]] = None\n</code></pre>  <p>A list of Tag instances.</p>"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.terms_of_service","title":"terms_of_service  <code>class-attribute</code>","text":"<pre><code>terms_of_service: Optional[AnyUrl] = None\n</code></pre>  <p>URL to page that contains terms of service.</p>"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.title","title":"title  <code>class-attribute</code>","text":"<pre><code>title: str\n</code></pre>  <p>Title of API documentation.</p>"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.use_handler_docstrings","title":"use_handler_docstrings  <code>class-attribute</code>","text":"<pre><code>use_handler_docstrings: bool = False\n</code></pre>  <p>Draw operation description from route handler docstring if not otherwise provided.</p>"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.version","title":"version  <code>class-attribute</code>","text":"<pre><code>version: str\n</code></pre>  <p>API version, e.g. '1.0.0'.</p>"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.webhooks","title":"webhooks  <code>class-attribute</code>","text":"<pre><code>webhooks: Optional[Dict[str, Union[PathItem, Reference]]] = None\n</code></pre>  <p>A mapping of key to either PathItem or.</p> <p>Reference objects.</p>"},{"location":"reference/config/6-static-files-config/","title":"Static-Files Config","text":""},{"location":"reference/config/6-static-files-config/#starlite.config.static_files.StaticFilesConfig","title":"starlite.config.static_files.StaticFilesConfig","text":"<p>         Bases: <code>BaseModel</code></p> <p>Configuration for static file service.</p> <p>To enable static files, pass an instance of this class to the Starlite constructor using the 'static_files_config' key.</p>"},{"location":"reference/config/6-static-files-config/#starlite.config.static_files.StaticFilesConfig.directories","title":"directories  <code>class-attribute</code>","text":"<pre><code>directories: List[DirectoryPath]\n</code></pre>  <p>A list of directories to serve files from.</p>"},{"location":"reference/config/6-static-files-config/#starlite.config.static_files.StaticFilesConfig.exception_handlers","title":"exception_handlers  <code>class-attribute</code>","text":"<pre><code>exception_handlers: Optional[ExceptionHandlersMap] = None\n</code></pre>  <p>A dictionary that maps handler functions to status codes and/or exception types.</p>"},{"location":"reference/config/6-static-files-config/#starlite.config.static_files.StaticFilesConfig.file_system","title":"file_system  <code>class-attribute</code>","text":"<pre><code>file_system: Any = BaseLocalFileSystem()\n</code></pre>  <p>The file_system spec to use for serving files.</p>  Notes <ul> <li>A file_system is a class that adheres to the     FileSystemProtocol.</li> <li>You can use any of the file systems exported from the     fsspec library for this purpose.</li> </ul>"},{"location":"reference/config/6-static-files-config/#starlite.config.static_files.StaticFilesConfig.guards","title":"guards  <code>class-attribute</code>","text":"<pre><code>guards: Optional[List[Guard]] = None\n</code></pre>  <p>A list of Guard callables.</p>"},{"location":"reference/config/6-static-files-config/#starlite.config.static_files.StaticFilesConfig.html_mode","title":"html_mode  <code>class-attribute</code>","text":"<pre><code>html_mode: bool = False\n</code></pre>  <p>Flag dictating whether serving html.</p> <p>If true, the default file will be 'index.html'.</p>"},{"location":"reference/config/6-static-files-config/#starlite.config.static_files.StaticFilesConfig.name","title":"name  <code>class-attribute</code>","text":"<pre><code>name: Optional[str] = None\n</code></pre>  <p>An optional string identifying the static files handler.</p>"},{"location":"reference/config/6-static-files-config/#starlite.config.static_files.StaticFilesConfig.opt","title":"opt  <code>class-attribute</code>","text":"<pre><code>opt: Optional[Dict[str, Any]] = None\n</code></pre>  <p>A string key dictionary of arbitrary values that will be added to the static files handler.</p>"},{"location":"reference/config/6-static-files-config/#starlite.config.static_files.StaticFilesConfig.path","title":"path  <code>class-attribute</code>","text":"<pre><code>path: constr(min_length=1)\n</code></pre>  <p>Path to serve static files from.</p> <p>Note that the path cannot contain path parameters.</p>"},{"location":"reference/config/6-static-files-config/#starlite.config.static_files.StaticFilesConfig.send_as_attachment","title":"send_as_attachment  <code>class-attribute</code>","text":"<pre><code>send_as_attachment: bool = False\n</code></pre>  <p>Whether to send the file as an attachment.</p>"},{"location":"reference/config/7-template-config/","title":"Template Config","text":""},{"location":"reference/config/7-template-config/#starlite.config.template.TemplateConfig","title":"starlite.config.template.TemplateConfig","text":"<p>         Bases: <code>Generic[T]</code>, <code>GenericModel</code></p> <p>Configuration for Templating.</p> <p>To enable templating, pass an instance of this class to the Starlite constructor using the 'template_config' key.</p>"},{"location":"reference/config/7-template-config/#starlite.config.template.TemplateConfig.directory","title":"directory  <code>class-attribute</code>","text":"<pre><code>directory: Optional[Union[DirectoryPath, List[DirectoryPath]]] = None\n</code></pre>  <p>A directory or list of directories from which to serve templates.</p>"},{"location":"reference/config/7-template-config/#starlite.config.template.TemplateConfig.engine","title":"engine  <code>class-attribute</code>","text":"<pre><code>engine: Union[Type[T], T]\n</code></pre>  <p>A template engine adhering to the TemplateEngineProtocol.</p>"},{"location":"reference/config/7-template-config/#starlite.config.template.TemplateConfig.engine_callback","title":"engine_callback  <code>class-attribute</code>","text":"<pre><code>engine_callback: Optional[Callable[[T], None]] = None\n</code></pre>  <p>A callback function that allows modifying the instantiated templating protocol.</p>"},{"location":"reference/config/7-template-config/#starlite.config.template.TemplateConfig.engine_instance","title":"engine_instance  <code>property</code>","text":"<pre><code>engine_instance: T\n</code></pre>  <p>Return the template engine instance.</p>"},{"location":"reference/config/7-template-config/#starlite.config.template.TemplateConfig.to_engine","title":"to_engine","text":"<pre><code>to_engine()\n</code></pre>  <p>Instantiate the template engine.</p>"},{"location":"reference/config/8-logging-config/","title":"Logging Config","text":""},{"location":"reference/config/8-logging-config/#starlite.config.logging.BaseLoggingConfig","title":"starlite.config.logging.BaseLoggingConfig","text":"<p>         Bases: <code>ABC</code></p> <p>Abstract class that should be extended by logging configs.</p>"},{"location":"reference/config/8-logging-config/#starlite.config.logging.BaseLoggingConfig.configure","title":"configure  <code>abstractmethod</code>","text":"<pre><code>configure()\n</code></pre>  <p>Return logger with the given configuration.</p> <p>Returns:</p>    Type Description      <code>GetLogger</code>  <p>A 'logging.getLogger' like function.</p>"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig","title":"starlite.config.logging.LoggingConfig","text":"<p>         Bases: <code>BaseLoggingConfig</code>, <code>BaseModel</code></p> <p>Configuration class for standard logging.</p>  Notes <ul> <li>If 'picologging' is installed it will be used by default.</li> </ul>"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig.disable_existing_loggers","title":"disable_existing_loggers  <code>class-attribute</code>","text":"<pre><code>disable_existing_loggers: bool = False\n</code></pre>  <p>Whether any existing non-root loggers are to be disabled.</p>"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig.filters","title":"filters  <code>class-attribute</code>","text":"<pre><code>filters: Optional[Dict[str, Dict[str, Any]]] = None\n</code></pre>  <p>A dict in which each key is a filter id and each value is a dict describing how to configure the corresponding Filter instance.</p>"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig.formatters","title":"formatters  <code>class-attribute</code>","text":"<pre><code>formatters: Dict[str, Dict[str, Any]] = {\n    \"standard\": {\"format\": \"%(levelname)s - %(asctime)s - %(name)s - %(module)s - %(message)s\"}\n}\n</code></pre>"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig.handlers","title":"handlers  <code>class-attribute</code>","text":"<pre><code>handlers: Dict[str, Dict[str, Any]] = Field(default_factory=get_default_handlers)\n</code></pre>  <p>A dict in which each key is a handler id and each value is a dict describing how to configure the corresponding Handler instance.</p>"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig.incremental","title":"incremental  <code>class-attribute</code>","text":"<pre><code>incremental: bool = False\n</code></pre>  <p>Whether the configuration is to be interpreted as incremental to the existing configuration.</p>  Notes <ul> <li>This option is ignored for 'picologging'</li> </ul>"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig.loggers","title":"loggers  <code>class-attribute</code>","text":"<pre><code>loggers: Dict[str, Dict[str, Any]] = {\n    \"starlite\": {\"level\": \"INFO\", \"handlers\": [\"queue_listener\"], \"propagate\": False}\n}\n</code></pre>  <p>A dict in which each key is a logger name and each value is a dict describing how to configure the corresponding Logger instance.</p>"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig.propagate","title":"propagate  <code>class-attribute</code>","text":"<pre><code>propagate: bool = True\n</code></pre>  <p>If messages must propagate to handlers higher up the logger hierarchy from this logger.</p>"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig.root","title":"root  <code>class-attribute</code>","text":"<pre><code>root: Dict[str, Union[Dict[str, Any], List[Any], str]] = {\n    \"handlers\": [\"queue_listener\"],\n    \"level\": \"INFO\",\n}\n</code></pre>  <p>This will be the configuration for the root logger.</p> <p>Processing of the configuration will be as for any logger, except that the propagate setting will not be applicable.</p>"},{"location":"reference/config/8-logging-config/#starlite.config.logging.StructLoggingConfig","title":"starlite.config.logging.StructLoggingConfig","text":"<p>         Bases: <code>BaseLoggingConfig</code>, <code>BaseModel</code></p> <p>Configuration class for structlog.</p>  Notes <ul> <li>requires 'structlog' to be installed.</li> </ul>"},{"location":"reference/config/8-logging-config/#starlite.config.logging.StructLoggingConfig.cache_logger_on_first_use","title":"cache_logger_on_first_use  <code>class-attribute</code>","text":"<pre><code>cache_logger_on_first_use: bool = True\n</code></pre>  <p>Whether to cache the logger configuration and reuse.</p>"},{"location":"reference/config/8-logging-config/#starlite.config.logging.StructLoggingConfig.context_class","title":"context_class  <code>class-attribute</code>","text":"<pre><code>context_class: Optional[Dict[str, Any]] = None\n</code></pre>  <p>Context class (a 'contextvar' context) for the logger.</p>"},{"location":"reference/config/8-logging-config/#starlite.config.logging.StructLoggingConfig.logger_factory","title":"logger_factory  <code>class-attribute</code>","text":"<pre><code>logger_factory: Optional[Callable[..., WrappedLogger]] = Field(\n    default_factory=default_logger_factory\n)\n</code></pre>  <p>Logger factory to use.</p>"},{"location":"reference/config/8-logging-config/#starlite.config.logging.StructLoggingConfig.processors","title":"processors  <code>class-attribute</code>","text":"<pre><code>processors: Optional[List[Processor]] = Field(default_factory=default_structlog_processors)\n</code></pre>  <p>Iterable of structlog logging processors.</p>"},{"location":"reference/config/8-logging-config/#starlite.config.logging.StructLoggingConfig.wrapper_class","title":"wrapper_class  <code>class-attribute</code>","text":"<pre><code>wrapper_class: Optional[Type[BindableLogger]] = Field(default_factory=default_wrapper_class)\n</code></pre>  <p>Structlog bindable logger.</p>"},{"location":"reference/config/9-allowed-hosts-config/","title":"Allowed Hosts Config","text":""},{"location":"reference/config/9-allowed-hosts-config/#starlite.config.AllowedHostsConfig","title":"starlite.config.AllowedHostsConfig","text":"<p>         Bases: <code>BaseModel</code></p> <p>Configuration for allowed hosts protection.</p> <p>To enable allowed hosts protection, pass an instance of this class to the Starlite constructor using the 'allowed_hosts' key.</p>"},{"location":"reference/config/9-allowed-hosts-config/#starlite.config.allowed_hosts.AllowedHostsConfig.allowed_hosts","title":"allowed_hosts  <code>class-attribute</code>","text":"<pre><code>allowed_hosts: List[str] = ['*']\n</code></pre>  <p>A list of trusted hosts.</p> <p>Use '' to allow all hosts, or prefix domains with '.' to allow all sub domains.</p>"},{"location":"reference/config/9-allowed-hosts-config/#starlite.config.allowed_hosts.AllowedHostsConfig.exclude","title":"exclude  <code>class-attribute</code>","text":"<pre><code>exclude: Optional[Union[str, List[str]]] = None\n</code></pre>  <p>A pattern or list of patterns to skip in the Allowed Hosts middleware.</p>"},{"location":"reference/config/9-allowed-hosts-config/#starlite.config.allowed_hosts.AllowedHostsConfig.exclude_opt_key","title":"exclude_opt_key  <code>class-attribute</code>","text":"<pre><code>exclude_opt_key: Optional[str] = None\n</code></pre>  <p>An identifier to use on routes to disable hosts check for a particular route.</p>"},{"location":"reference/config/9-allowed-hosts-config/#starlite.config.allowed_hosts.AllowedHostsConfig.scopes","title":"scopes  <code>class-attribute</code>","text":"<pre><code>scopes: Optional[Scopes] = None\n</code></pre>  <p>ASGI scopes processed by the middleware, if None both 'http' and 'websocket' will be processed.</p>"},{"location":"reference/config/9-allowed-hosts-config/#starlite.config.allowed_hosts.AllowedHostsConfig.www_redirect","title":"www_redirect  <code>class-attribute</code>","text":"<pre><code>www_redirect: bool = True\n</code></pre>  <p>A boolean dictating whether to redirect requests that start with 'www.' and otherwise match a trusted host.</p>"},{"location":"reference/connection/0-asgi-connection/","title":"ASGI Connection","text":""},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.User","title":"starlite.connection.base.User  <code>module-attribute</code>","text":"<pre><code>starlite.connection.base.User = TypeVar('User')\n</code></pre>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.Auth","title":"starlite.connection.base.Auth  <code>module-attribute</code>","text":"<pre><code>starlite.connection.base.Auth = TypeVar('Auth')\n</code></pre>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.Handler","title":"starlite.connection.base.Handler  <code>module-attribute</code>","text":"<pre><code>starlite.connection.base.Handler = TypeVar('Handler')\n</code></pre>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection","title":"starlite.connection.base.ASGIConnection","text":"<p>         Bases: <code>Generic[Handler, User, Auth]</code></p> <p>The base ASGI connection container.</p>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.app","title":"app  <code>property</code>","text":"<pre><code>app: Starlite\n</code></pre>  <p>Return the <code>app</code> for this connection.</p> <p>Returns:</p>    Type Description      <code>Starlite</code>  <p>The Starlite application instance</p>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.auth","title":"auth  <code>property</code>","text":"<pre><code>auth: Auth\n</code></pre>  <p>Return the <code>auth</code> data of this connection's <code>Scope</code>.</p> <p>Raises:</p>    Type Description      <code>ImproperlyConfiguredException</code>  <p>If 'auth' is not set in scope via an 'AuthMiddleware', raises an exception</p>    <p>Returns:</p>    Type Description      <code>Auth</code>  <p>A type correlating to the generic variable Auth.</p>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.base_url","title":"base_url  <code>property</code>","text":"<pre><code>base_url: URL\n</code></pre>  <p>Return the base URL of this connection's <code>Scope</code>.</p> <p>Returns:</p>    Type Description      <code>URL</code>  <p>A URL instance constructed from the request's scope, representing only the base part</p>    <code>URL</code>  <p>(host + domain + prefix) of the request.</p>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.cache","title":"cache  <code>property</code>","text":"<pre><code>cache: Cache\n</code></pre>  <p>Return the <code>Cache</code> for this connection.</p> <p>Returns:</p>    Type Description      <code>Cache</code>  <p>A 'Cache' instance.</p>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.client","title":"client  <code>property</code>","text":"<pre><code>client: Optional[Address]\n</code></pre>  <p>Return the <code>client</code> data of this connection's <code>Scope</code>.</p> <p>Returns:</p>    Type Description      <code>Optional[Address]</code>  <p>A two tuple of the host name and port number.</p>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.cookies","title":"cookies  <code>property</code>","text":"<pre><code>cookies: Dict[str, str]\n</code></pre>  <p>Return the <code>cookies</code> of this connection's <code>Scope</code>.</p> <p>Returns:</p>    Type Description      <code>Dict[str, str]</code>  <p>Returns any cookies stored in the header as a parsed dictionary.</p>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.headers","title":"headers  <code>property</code>","text":"<pre><code>headers: Headers\n</code></pre>  <p>Return the headers of this connection's <code>Scope</code>.</p> <p>Returns:</p>    Type Description      <code>Headers</code>  <p>A Headers instance with the request's scope[\"headers\"] value.</p>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.logger","title":"logger  <code>property</code>","text":"<pre><code>logger: Logger\n</code></pre>  <p>Return the <code>Logger</code> instance for this connection.</p> <p>Returns:</p>    Type Description      <code>Logger</code>  <p>A 'Logger' instance.</p>    <p>Raises:</p>    Type Description      <code>ImproperlyConfiguredException</code>  <p>if 'log_config' has not been passed to the Starlite constructor.</p>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.path_params","title":"path_params  <code>property</code>","text":"<pre><code>path_params: Dict[str, Any]\n</code></pre>  <p>Return the <code>path_params</code> of this connection's <code>Scope</code>.</p> <p>Returns:</p>    Type Description      <code>Dict[str, Any]</code>  <p>A string keyed dictionary of path parameter values.</p>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.query_params","title":"query_params  <code>property</code>","text":"<pre><code>query_params: MultiDict\n</code></pre>  <p>Return the query parameters of this connection's <code>Scope</code>.</p> <p>Returns:</p>    Type Description      <code>MultiDict</code>  <p>A normalized dict of query parameters. Multiple values for the same key are returned as a list.</p>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.receive","title":"receive  <code>instance-attribute</code>","text":"<pre><code>receive = receive\n</code></pre>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.route_handler","title":"route_handler  <code>property</code>","text":"<pre><code>route_handler: Handler\n</code></pre>  <p>Return the <code>route_handler</code> for this connection.</p> <p>Returns:</p>    Type Description      <code>Handler</code>  <p>The target route handler instance.</p>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.scope","title":"scope  <code>instance-attribute</code>","text":"<pre><code>scope = scope\n</code></pre>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.send","title":"send  <code>instance-attribute</code>","text":"<pre><code>send = send\n</code></pre>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.session","title":"session  <code>property</code>","text":"<pre><code>session: Dict[str, Any]\n</code></pre>  <p>Return the session for this connection if a session was previously set in the <code>Scope</code></p> <p>Returns:</p>    Type Description      <code>Dict[str, Any]</code>  <p>A dictionary representing the session value - if existing.</p>    <p>Raises:</p>    Type Description      <code>ImproperlyConfiguredException</code>  <p>if session is not set in scope.</p>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.state","title":"state  <code>property</code>","text":"<pre><code>state: State\n</code></pre>  <p>Return the <code>State</code> of this connection.</p> <p>Returns:</p>    Type Description      <code>State</code>  <p>A State instance constructed from the scope[\"state\"] value.</p>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.url","title":"url  <code>property</code>","text":"<pre><code>url: URL\n</code></pre>  <p>Return the URL of this connection's <code>Scope</code>.</p> <p>Returns:</p>    Type Description      <code>URL</code>  <p>A URL instance constructed from the request's scope.</p>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.user","title":"user  <code>property</code>","text":"<pre><code>user: User\n</code></pre>  <p>Return the <code>user</code> data of this connection's <code>Scope</code>.</p> <p>Raises:</p>    Type Description      <code>ImproperlyConfiguredException</code>  <p>If 'user' is not set in scope via an 'AuthMiddleware', raises an exception</p>    <p>Returns:</p>    Type Description      <code>User</code>  <p>A type correlating to the generic variable User.</p>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.__init__","title":"__init__","text":"<pre><code>__init__(scope, receive=empty_receive, send=empty_send)\n</code></pre>  <p>Initialize <code>ASGIConnection</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>scope</code>  <code>Scope</code>  <p>The ASGI connection scope.</p>  required    <code>receive</code>  <code>Receive</code>  <p>The ASGI receive function.</p>  <code>empty_receive</code>    <code>send</code>  <code>Send</code>  <p>The ASGI send function.</p>  <code>empty_send</code>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.clear_session","title":"clear_session","text":"<pre><code>clear_session()\n</code></pre>  <p>Remove the session from the connection's <code>Scope</code>.</p> <p>If the Starlite SessionMiddleware is enabled, this will cause the session data to be cleared.</p> <p>Returns:</p>    Type Description      <code>None</code>  <p>None.</p>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.set_session","title":"set_session","text":"<pre><code>set_session(value)\n</code></pre>  <p>Set the session in the connection's <code>Scope</code>.</p> <p>If the Starlite SessionMiddleware is enabled, the session will be added to the response as a cookie header.</p> <p>Parameters:</p>    Name Type Description Default     <code>value</code>  <code>Union[Dict[str, Any], BaseModel, EmptyType]</code>  <p>Dictionary or pydantic model instance for the session data.</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None.</p>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.url_for","title":"url_for","text":"<pre><code>url_for(name, **path_parameters)\n</code></pre>  <p>Return the url for a given route handler name.</p> <p>Parameters:</p>    Name Type Description Default     <code>name</code>  <code>str</code>  <p>The 'name' of the request route handler.</p>  required    <code>**path_parameters</code>  <code>Dict[str, Any]</code>  <p>Values for path parameters in the route</p>  <code>{}</code>     <p>Raises:</p>    Type Description      <code>NoRouteMatchFoundException</code>  <p>If route with 'name' does not exist, path parameters are missing or have a wrong type.</p>    <p>Returns:</p>    Type Description      <code>str</code>  <p>A string representing the absolute url of the route handler.</p>"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.url_for_static_asset","title":"url_for_static_asset","text":"<pre><code>url_for_static_asset(name, file_path)\n</code></pre>  <p>Receives a static files handler name, an asset file path and returns resolved absolute url to the asset.</p> <p>Parameters:</p>    Name Type Description Default     <code>name</code>  <code>str</code>  <p>A static handler unique name.</p>  required    <code>file_path</code>  <code>str</code>  <p>a string containing path to an asset.</p>  required     <p>Raises:</p>    Type Description      <code>NoRouteMatchFoundException</code>  <p>If static files handler with 'name' does not exist.</p>    <p>Returns:</p>    Type Description      <code>str</code>  <p>A string representing absolute url to the asset.</p>"},{"location":"reference/connection/1-request/","title":"Request","text":""},{"location":"reference/connection/1-request/#starlite.connection.request.Request","title":"starlite.connection.request.Request","text":"<p>         Bases: <code>Generic[User, Auth]</code>, <code>ASGIConnection[HTTPRouteHandler, User, Auth]</code></p> <p>The Starlite Request class.</p>"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.content_type","title":"content_type  <code>property</code>","text":"<pre><code>content_type: Tuple[str, Dict[str, str]]\n</code></pre>  <p>Parse the request's 'Content-Type' header, returning the header value and any options as a dictionary.</p> <p>Returns:</p>    Type Description      <code>Tuple[str, Dict[str, str]]</code>  <p>A tuple with the parsed value and a dictionary containing any options send in it.</p>"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.method","title":"method  <code>property</code>","text":"<pre><code>method: Method\n</code></pre>  <p>Return the request method.</p> <p>Returns:</p>    Type Description      <code>Method</code>  <p>The request Method</p>"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.receive","title":"receive  <code>class-attribute</code>","text":"<pre><code>receive: Receive\n</code></pre>  <p>The ASGI receive function.</p>"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.scope","title":"scope  <code>class-attribute</code>","text":"<pre><code>scope: HTTPScope\n</code></pre>  <p>The ASGI scope attached to the connection.</p>"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.send","title":"send  <code>class-attribute</code>","text":"<pre><code>send: Send\n</code></pre>  <p>The ASGI send function.</p>"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.__init__","title":"__init__","text":"<pre><code>__init__(scope, receive=empty_receive, send=empty_send)\n</code></pre>  <p>Initialize <code>Request</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>scope</code>  <code>Scope</code>  <p>The ASGI connection scope.</p>  required    <code>receive</code>  <code>Receive</code>  <p>The ASGI receive function.</p>  <code>empty_receive</code>    <code>send</code>  <code>Send</code>  <p>The ASGI send function.</p>  <code>empty_send</code>"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.body","title":"body  <code>async</code>","text":"<pre><code>body()\n</code></pre>  <p>Return the body of the request.</p> <p>Returns:</p>    Type Description      <code>bytes</code>  <p>A byte-string representing the body of the request.</p>"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.form","title":"form  <code>async</code>","text":"<pre><code>form()\n</code></pre>  <p>Retrieve form data from the request. If the request is either a 'multipart/form-data' or an 'application/x-www-form- urlencoded', return a FormMultiDict instance populated with the values sent in the request, otherwise, an empty instance.</p> <p>Returns:</p>    Type Description      <code>FormMultiDict</code>  <p>A FormMultiDict instance</p>"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.json","title":"json  <code>async</code>","text":"<pre><code>json()\n</code></pre>  <p>Retrieve the json request body from the request.</p> <p>Returns:</p>    Type Description      <code>Any</code>  <p>An arbitrary value</p>"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.msgpack","title":"msgpack  <code>async</code>","text":"<pre><code>msgpack()\n</code></pre>  <p>Retrieve the MessagePack request body from the request.</p> <p>Returns:</p>    Type Description      <code>Any</code>  <p>An arbitrary value</p>"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.send_push_promise","title":"send_push_promise  <code>async</code>","text":"<pre><code>send_push_promise(path)\n</code></pre>  <p>Send a push promise.</p> <p>This method requires the <code>http.response.push</code> extension to be sent from the ASGI server.</p> <p>Parameters:</p>    Name Type Description Default     <code>path</code>  <code>str</code>  <p>Path to send the promise to.</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.stream","title":"stream  <code>async</code>","text":"<pre><code>stream()\n</code></pre>  <p>Return an async generator that streams chunks of bytes.</p> <p>Returns:</p>    Type Description      <code>AsyncGenerator[bytes, None]</code>  <p>An async generator.</p>    <p>Raises:</p>    Type Description      <code>RuntimeError</code>  <p>if the stream is already consumed</p>"},{"location":"reference/connection/2-websocket/","title":"WebSocket","text":""},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket","title":"starlite.connection.websocket.WebSocket","text":"<p>         Bases: <code>Generic[User, Auth]</code>, <code>ASGIConnection[WebsocketRouteHandler, User, Auth]</code></p> <p>The Starlite WebSocket class.</p>"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.receive","title":"receive  <code>class-attribute</code>","text":"<pre><code>receive: Receive\n</code></pre>  <p>The ASGI receive function.</p>"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.scope","title":"scope  <code>class-attribute</code>","text":"<pre><code>scope: WebSocketScope\n</code></pre>  <p>The ASGI scope attached to the connection.</p>"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.send","title":"send  <code>class-attribute</code>","text":"<pre><code>send: Send\n</code></pre>  <p>The ASGI send function.</p>"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.__init__","title":"__init__","text":"<pre><code>__init__(scope, receive=empty_receive, send=empty_send)\n</code></pre>  <p>Initialize <code>WebSocket</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>scope</code>  <code>Scope</code>  <p>The ASGI connection scope.</p>  required    <code>receive</code>  <code>Receive</code>  <p>The ASGI receive function.</p>  <code>empty_receive</code>    <code>send</code>  <code>Send</code>  <p>The ASGI send function.</p>  <code>empty_send</code>"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.accept","title":"accept  <code>async</code>","text":"<pre><code>accept(subprotocols=None, headers=None)\n</code></pre>  <p>Accept the incoming connection. This method should be called before receiving data.</p> <p>Parameters:</p>    Name Type Description Default     <code>subprotocols</code>  <code>Optional[str]</code>  <p>Websocket sub-protocol to use.</p>  <code>None</code>    <code>headers</code>  <code>Optional[Union[Headers, Dict[str, Any], List[Tuple[bytes, bytes]]]]</code>  <p>Headers to set on the data sent.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.close","title":"close  <code>async</code>","text":"<pre><code>close(code=WS_1000_NORMAL_CLOSURE, reason=None)\n</code></pre>  <p>Send an 'websocket.close' event.</p> <p>Parameters:</p>    Name Type Description Default     <code>code</code>  <code>int</code>  <p>Status code.</p>  <code>WS_1000_NORMAL_CLOSURE</code>    <code>reason</code>  <code>Optional[str]</code>  <p>Reason for closing the connection</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.receive_bytes","title":"receive_bytes  <code>async</code>","text":"<pre><code>receive_bytes()\n</code></pre>  <p>Receive data as bytes.</p> <p>Returns:</p>    Type Description      <code>bytes</code>  <p>A byte-string.</p>"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.receive_data","title":"receive_data  <code>async</code>","text":"<pre><code>receive_data(mode)\n</code></pre>  <p>Receive an 'websocket.receive' event and returns the data stored on it.</p> <p>Parameters:</p>    Name Type Description Default     <code>mode</code>  <code>Literal['binary', 'text']</code>  <p>The respective event key to use.</p>  required     <p>Returns:</p>    Type Description      <code>Union[str, bytes]</code>  <p>The event's data.</p>"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.receive_json","title":"receive_json  <code>async</code>","text":"<pre><code>receive_json(mode='text')\n</code></pre>  <p>Receive data and loads it into JSON using orson.</p> <p>Parameters:</p>    Name Type Description Default     <code>mode</code>  <code>Literal['text', 'binary']</code>  <p>Either 'text' or 'binary'.</p>  <code>'text'</code>     <p>Returns:</p>    Type Description      <code>Any</code>  <p>An arbitrary value</p>"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.receive_text","title":"receive_text  <code>async</code>","text":"<pre><code>receive_text()\n</code></pre>  <p>Receive data as text.</p> <p>Returns:</p>    Type Description      <code>str</code>  <p>A string.</p>"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.send_bytes","title":"send_bytes  <code>async</code>","text":"<pre><code>send_bytes(data, encoding='utf-8')\n</code></pre>  <p>Send data using the 'bytes' key of the send event.</p> <p>Parameters:</p>    Name Type Description Default     <code>data</code>  <code>Union[str, bytes]</code>  <p>Data to send</p>  required    <code>encoding</code>  <code>str</code>  <p>Encoding to use for binary data.</p>  <code>'utf-8'</code>     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.send_data","title":"send_data  <code>async</code>","text":"<pre><code>send_data(data, mode='text', encoding='utf-8')\n</code></pre>  <p>Send a 'websocket.send' event.</p> <p>Parameters:</p>    Name Type Description Default     <code>data</code>  <code>Union[str, bytes]</code>  <p>Data to send.</p>  required    <code>mode</code>  <code>Literal['text', 'binary']</code>  <p>The respective event key to use.</p>  <code>'text'</code>    <code>encoding</code>  <code>str</code>  <p>Encoding to use when converting bytes / str.</p>  <code>'utf-8'</code>     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.send_json","title":"send_json  <code>async</code>","text":"<pre><code>send_json(data, mode='text', encoding='utf-8', serializer=default_serializer)\n</code></pre>  <p>Send data as JSON.</p> <p>Parameters:</p>    Name Type Description Default     <code>data</code>  <code>Any</code>  <p>A value to serialize.</p>  required    <code>mode</code>  <code>Literal['text', 'binary']</code>  <p>Either 'text' or 'binary'.</p>  <code>'text'</code>    <code>encoding</code>  <code>str</code>  <p>Encoding to use for binary data.</p>  <code>'utf-8'</code>    <code>serializer</code>  <code>Serializer</code>  <p>A serializer function.</p>  <code>default_serializer</code>     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.send_text","title":"send_text  <code>async</code>","text":"<pre><code>send_text(data, encoding='utf-8')\n</code></pre>  <p>Send data using the 'text' key of the send event.</p> <p>Parameters:</p>    Name Type Description Default     <code>data</code>  <code>Union[str, bytes]</code>  <p>Data to send</p>  required    <code>encoding</code>  <code>str</code>  <p>Encoding to use for binary data.</p>  <code>'utf-8'</code>     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/contrib/jinja/","title":"Jinja Template Engine","text":""},{"location":"reference/contrib/jinja/#starlite.contrib.jinja.JinjaTemplateEngine","title":"starlite.contrib.jinja.JinjaTemplateEngine","text":"<p>         Bases: <code>TemplateEngineProtocol[JinjaTemplate]</code></p> <p>The engine instance.</p>"},{"location":"reference/contrib/jinja/#starlite.contrib.jinja.JinjaTemplateEngine.__init__","title":"__init__","text":"<pre><code>__init__(directory)\n</code></pre>  <p>Jinja2 based TemplateEngine.</p> <p>Parameters:</p>    Name Type Description Default     <code>directory</code>  <code>Union[DirectoryPath, List[DirectoryPath]]</code>  <p>Direct path or list of directory paths from which to serve templates.</p>  required"},{"location":"reference/contrib/jinja/#starlite.contrib.jinja.JinjaTemplateEngine.get_template","title":"get_template","text":"<pre><code>get_template(template_name)\n</code></pre>  <p>Retrieve a template by matching its name (dotted path) with files in the directory or directories provided.</p> <p>Parameters:</p>    Name Type Description Default     <code>template_name</code>  <code>str</code>  <p>A dotted path</p>  required     <p>Returns:</p>    Type Description      <code>JinjaTemplate</code>  <p>JinjaTemplate instance</p>    <p>Raises:</p>    Type Description      <code>[TemplateNotFoundException][starlite.exceptions.TemplateNotFoundException]</code>  <p>if no template is found.</p>"},{"location":"reference/contrib/jinja/#starlite.contrib.jinja.JinjaTemplateEngine.register_template_callable","title":"register_template_callable","text":"<pre><code>register_template_callable(key, template_callable)\n</code></pre>  <p>Register a callable on the template engine.</p> <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>str</code>  <p>The callable key, i.e. the value to use inside the template to call the callable.</p>  required    <code>template_callable</code>  <code>Callable[[Dict[str, Any]], Any]</code>  <p>A callable to register.</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/contrib/jwt/","title":"JWT Security Backend","text":""},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.JWTAuth","title":"starlite.contrib.jwt.JWTAuth","text":"<p>         Bases: <code>Generic[UserType]</code>, <code>AbstractSecurityConfig[UserType, Token]</code></p> <p>JWT Authentication Configuration.</p> <p>This class is the main entry point to the library, and it includes methods to create the middleware, provide login functionality, and create OpenAPI documentation.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTAuth.algorithm","title":"algorithm  <code>class-attribute</code>","text":"<pre><code>algorithm: str = 'HS256'\n</code></pre>  <p>Algorithm to use for JWT hashing.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTAuth.auth_header","title":"auth_header  <code>class-attribute</code>","text":"<pre><code>auth_header: str = 'Authorization'\n</code></pre>  <p>Request header key from which to retrieve the token.</p> <p>E.g. 'Authorization' or 'X-Api-Key'.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTAuth.authentication_middleware_class","title":"authentication_middleware_class  <code>class-attribute</code>","text":"<pre><code>authentication_middleware_class: Type[JWTAuthenticationMiddleware] = JWTAuthenticationMiddleware\n</code></pre>  <p>The authentication middleware class to use.</p> <p>Must inherit from JWTAuthenticationMiddleware</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTAuth.default_token_expiration","title":"default_token_expiration  <code>class-attribute</code>","text":"<pre><code>default_token_expiration: timedelta = timedelta(days=1)\n</code></pre>  <p>The default value for token expiration.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTAuth.description","title":"description  <code>class-attribute</code>","text":"<pre><code>description: str = 'JWT api-key authentication and authorization.'\n</code></pre>  <p>Description for the OpenAPI security scheme.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTAuth.middleware","title":"middleware  <code>property</code>","text":"<pre><code>middleware: DefineMiddleware\n</code></pre>  <p>Create <code>JWTAuthenticationMiddleware</code> wrapped in Starlite's <code>DefineMiddleware</code>.</p> <p>Returns:</p>    Type Description      <code>DefineMiddleware</code>  <p>An instance of DefineMiddleware.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTAuth.openapi_components","title":"openapi_components  <code>property</code>","text":"<pre><code>openapi_components: Components\n</code></pre>  <p>Create OpenAPI documentation for the JWT auth schema used.</p> <p>Returns:</p>    Type Description      <code>Components</code>  <p>An Components instance.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTAuth.openapi_security_scheme_name","title":"openapi_security_scheme_name  <code>class-attribute</code>","text":"<pre><code>openapi_security_scheme_name: str = 'BearerToken'\n</code></pre>  <p>The value to use for the OpenAPI security scheme and security requirements.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTAuth.security_requirement","title":"security_requirement  <code>property</code>","text":"<pre><code>security_requirement: SecurityRequirement\n</code></pre>  <p>Return OpenAPI 3.1.</p> <p>SecurityRequirement</p> <p>Returns:</p>    Type Description      <code>SecurityRequirement</code>  <p>An OpenAPI 3.1 SecurityRequirement dictionary.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTAuth.token_secret","title":"token_secret  <code>class-attribute</code>","text":"<pre><code>token_secret: str\n</code></pre>  <p>Key with which to generate the token hash.</p>  Notes <ul> <li>This value should be kept as a secret and the standard practice is to inject it into the environment.</li> </ul>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTAuth.login","title":"login","text":"<pre><code>login(\n    identifier,\n    *,\n    response_body=None,\n    response_media_type=MediaType.JSON,\n    response_status_code=HTTP_201_CREATED,\n    token_expiration=None,\n    token_issuer=None,\n    token_audience=None,\n    token_unique_jwt_id=None\n)\n</code></pre>  <p>Create a response with a JWT header. Calls the 'JWTAuth.store_token_handler' to persist the token 'sub'.</p> <p>Parameters:</p>    Name Type Description Default     <code>identifier</code>  <code>str</code>  <p>Unique identifier of the token subject. Usually this is a user ID or equivalent kind of value.</p>  required    <code>response_body</code>  <code>Optional[Any]</code>  <p>An optional response body to send.</p>  <code>None</code>    <code>response_media_type</code>  <code>Union[str, MediaType]</code>  <p>An optional 'Content-Type'. Defaults to 'application/json'.</p>  <code>MediaType.JSON</code>    <code>response_status_code</code>  <code>int</code>  <p>An optional status code for the response. Defaults to '201 Created'.</p>  <code>HTTP_201_CREATED</code>    <code>token_expiration</code>  <code>Optional[timedelta]</code>  <p>An optional timedelta for the token expiration.</p>  <code>None</code>    <code>token_issuer</code>  <code>Optional[str]</code>  <p>An optional value of the token 'iss' field.</p>  <code>None</code>    <code>token_audience</code>  <code>Optional[str]</code>  <p>An optional value for the token 'aud' field.</p>  <code>None</code>    <code>token_unique_jwt_id</code>  <code>Optional[str]</code>  <p>An optional value for the token 'jti' field.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>Response[Any]</code>  <p>A Response instance.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.JWTCookieAuth","title":"starlite.contrib.jwt.JWTCookieAuth","text":"<p>         Bases: <code>Generic[UserType]</code>, <code>JWTAuth[UserType]</code></p> <p>JWT Cookie Authentication Configuration.</p> <p>This class is an alternate entry point to the library, and it includes all the functionality of the <code>JWTAuth</code> class and adds support for passing JWT tokens <code>HttpOnly</code> cookies.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTCookieAuth.authentication_middleware_class","title":"authentication_middleware_class  <code>class-attribute</code>","text":"<pre><code>authentication_middleware_class: Type[\n    JWTCookieAuthenticationMiddleware\n] = JWTCookieAuthenticationMiddleware\n</code></pre>  <p>The authentication middleware class to use.</p> <p>Must inherit from JWTCookieAuthenticationMiddleware</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTCookieAuth.description","title":"description  <code>class-attribute</code>","text":"<pre><code>description: str = 'JWT cookie-based authentication and authorization.'\n</code></pre>  <p>Description for the OpenAPI security scheme.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTCookieAuth.domain","title":"domain  <code>class-attribute</code>","text":"<pre><code>domain: Optional[str] = None\n</code></pre>  <p>Domain for which the cookie is valid.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTCookieAuth.key","title":"key  <code>class-attribute</code>","text":"<pre><code>key: str = 'token'\n</code></pre>  <p>Key for the cookie.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTCookieAuth.middleware","title":"middleware  <code>property</code>","text":"<pre><code>middleware: DefineMiddleware\n</code></pre>  <p>Create <code>JWTCookieAuthenticationMiddleware</code> wrapped in Starlite's <code>DefineMiddleware</code>.</p> <p>Returns:</p>    Type Description      <code>DefineMiddleware</code>  <p>An instance of DefineMiddleware.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTCookieAuth.openapi_components","title":"openapi_components  <code>property</code>","text":"<pre><code>openapi_components: Components\n</code></pre>  <p>Create OpenAPI documentation for the JWT Cookie auth scheme.</p> <p>Returns:</p>    Type Description      <code>Components</code>  <p>An Components instance.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTCookieAuth.path","title":"path  <code>class-attribute</code>","text":"<pre><code>path: str = '/'\n</code></pre>  <p>Path fragment that must exist in the request url for the cookie to be valid.</p> <p>Defaults to '/'.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTCookieAuth.samesite","title":"samesite  <code>class-attribute</code>","text":"<pre><code>samesite: Literal['lax', 'strict', 'none'] = 'lax'\n</code></pre>  <p>Controls whether or not a cookie is sent with cross-site requests.</p> <p>Defaults to 'lax'.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTCookieAuth.secure","title":"secure  <code>class-attribute</code>","text":"<pre><code>secure: Optional[bool] = None\n</code></pre>  <p>Https is required for the cookie.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTCookieAuth.login","title":"login","text":"<pre><code>login(\n    identifier,\n    *,\n    response_body=None,\n    response_media_type=MediaType.JSON,\n    response_status_code=HTTP_201_CREATED,\n    token_expiration=None,\n    token_issuer=None,\n    token_audience=None,\n    token_unique_jwt_id=None\n)\n</code></pre>  <p>Create a response with a JWT header. Calls the 'JWTAuth.store_token_handler' to persist the token 'sub'.</p> <p>Parameters:</p>    Name Type Description Default     <code>identifier</code>  <code>str</code>  <p>Unique identifier of the token subject. Usually this is a user ID or equivalent kind of value.</p>  required    <code>response_body</code>  <code>Optional[Any]</code>  <p>An optional response body to send.</p>  <code>None</code>    <code>response_media_type</code>  <code>Union[str, MediaType]</code>  <p>An optional 'Content-Type'. Defaults to 'application/json'.</p>  <code>MediaType.JSON</code>    <code>response_status_code</code>  <code>int</code>  <p>An optional status code for the response. Defaults to '201 Created'.</p>  <code>HTTP_201_CREATED</code>    <code>token_expiration</code>  <code>Optional[timedelta]</code>  <p>An optional timedelta for the token expiration.</p>  <code>None</code>    <code>token_issuer</code>  <code>Optional[str]</code>  <p>An optional value of the token 'iss' field.</p>  <code>None</code>    <code>token_audience</code>  <code>Optional[str]</code>  <p>An optional value for the token 'aud' field.</p>  <code>None</code>    <code>token_unique_jwt_id</code>  <code>Optional[str]</code>  <p>An optional value for the token 'jti' field.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>Response[Any]</code>  <p>A Response instance.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.OAuth2PasswordBearerAuth","title":"starlite.contrib.jwt.OAuth2PasswordBearerAuth","text":"<p>         Bases: <code>Generic[UserType]</code>, <code>JWTCookieAuth[UserType]</code></p> <p>OAUTH2 Schema for Password Bearer Authentication.</p> <p>This class implements an OAUTH2 authentication flow entry point to the library, and it includes all the functionality of the <code>JWTAuth</code> class and adds support for passing JWT tokens <code>HttpOnly</code> cookies.</p> <p><code>token_url</code> is the only additional argument that is required, and it should point at your login route</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.OAuth2PasswordBearerAuth.description","title":"description  <code>class-attribute</code>","text":"<pre><code>description: str = 'OAUTH2 password bearer authentication and authorization.'\n</code></pre>  <p>Description for the OpenAPI security scheme.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.OAuth2PasswordBearerAuth.oauth_scopes","title":"oauth_scopes  <code>class-attribute</code>","text":"<pre><code>oauth_scopes: Optional[Dict[str, str]] = None\n</code></pre>  <p>Oauth Scopes available for the token.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.OAuth2PasswordBearerAuth.openapi_components","title":"openapi_components  <code>property</code>","text":"<pre><code>openapi_components: Components\n</code></pre>  <p>Create OpenAPI documentation for the OAUTH2 Password bearer auth scheme.</p> <p>Returns:</p>    Type Description      <code>Components</code>  <p>An Components instance.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.OAuth2PasswordBearerAuth.token_url","title":"token_url  <code>class-attribute</code>","text":"<pre><code>token_url: str\n</code></pre>  <p>The URL for retrieving a new token.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.Token","title":"starlite.contrib.jwt.Token","text":"<p>         Bases: <code>BaseModel</code></p> <p>JWT Token DTO.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_token.Token.exp","title":"exp  <code>class-attribute</code>","text":"<pre><code>exp: datetime\n</code></pre>  <p>Expiration - datetime for token expiration.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_token.Token.iat","title":"iat  <code>class-attribute</code>","text":"<pre><code>iat: datetime = Field(default_factory=lambda : _normalize_datetime(datetime.now(timezone.utc)))\n</code></pre>  <p>Issued at - should always be current now.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_token.Token.sub","title":"sub  <code>class-attribute</code>","text":"<pre><code>sub: constr(min_length=1)\n</code></pre>  <p>Subject - usually a unique identifier of the user or equivalent entity.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_token.Token.iss","title":"iss  <code>class-attribute</code>","text":"<pre><code>iss: Optional[str] = None\n</code></pre>  <p>Issuer - optional unique identifier for the issuer.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_token.Token.aud","title":"aud  <code>class-attribute</code>","text":"<pre><code>aud: Optional[str] = None\n</code></pre>  <p>Audience - intended audience.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_token.Token.jti","title":"jti  <code>class-attribute</code>","text":"<pre><code>jti: Optional[str] = None\n</code></pre>  <p>JWT ID - a unique identifier of the JWT between different issuers.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_token.Token.decode","title":"decode  <code>staticmethod</code>","text":"<pre><code>decode(encoded_token, secret, algorithm)\n</code></pre>  <p>Decode a passed in token string and returns a Token instance.</p> <p>Parameters:</p>    Name Type Description Default     <code>encoded_token</code>  <code>str</code>  <p>A base64 string containing an encoded JWT.</p>  required    <code>secret</code>  <code>Union[str, Dict[str, str]]</code>  <p>The secret with which the JWT is encoded. It may optionally be an individual JWK or JWS set dict</p>  required    <code>algorithm</code>  <code>str</code>  <p>The algorithm used to encode the JWT.</p>  required     <p>Returns:</p>    Type Description      <code>Token</code>  <p>A decoded Token instance.</p>    <p>Raises:</p>    Type Description      <code>[NotAuthorizedException][starlite.exceptions.NotAuthorizedException]</code>  <p>If token is invalid.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_token.Token.encode","title":"encode","text":"<pre><code>encode(secret, algorithm)\n</code></pre>  <p>Encode the token instance into a string.</p> <p>Parameters:</p>    Name Type Description Default     <code>secret</code>  <code>str</code>  <p>The secret with which the JWT is encoded.</p>  required    <code>algorithm</code>  <code>str</code>  <p>The algorithm used to encode the JWT.</p>  required     <p>Returns:</p>    Type Description      <code>str</code>  <p>An encoded token string.</p>    <p>Raises:</p>    Type Description      <code>[ImproperlyConfiguredException][starlite.exceptions.ImproperlyConfiguredException]</code>  <p>If encoding fails.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.JWTAuthenticationMiddleware","title":"starlite.contrib.jwt.JWTAuthenticationMiddleware","text":"<p>         Bases: <code>AbstractAuthenticationMiddleware</code></p> <p>JWT Authentication middleware.</p> <p>This class provides JWT authentication functionalities.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.middleware.JWTAuthenticationMiddleware.__init__","title":"__init__","text":"<pre><code>__init__(\n    app,\n    algorithm,\n    auth_header,\n    exclude,\n    exclude_opt_key,\n    retrieve_user_handler,\n    scopes,\n    token_secret,\n)\n</code></pre>  <p>Check incoming requests for an encoded token in the auth header specified, and if present retrieve the user from persistence using the provided function.</p> <p>Parameters:</p>    Name Type Description Default     <code>algorithm</code>  <code>str</code>  <p>JWT hashing algorithm to use.</p>  required    <code>app</code>  <code>ASGIApp</code>  <p>An ASGIApp, this value is the next ASGI handler to call in the middleware stack.</p>  required    <code>auth_header</code>  <code>str</code>  <p>Request header key from which to retrieve the token. E.g. 'Authorization' or 'X-Api-Key'.</p>  required    <code>exclude</code>  <code>Optional[Union[str, List[str]]]</code>  <p>A pattern or list of patterns to skip.</p>  required    <code>exclude_opt_key</code>  <code>str</code>  <p>An identifier to use on routes to disable authentication for a particular route.</p>  required    <code>retrieve_user_handler</code>  <code>AsyncCallable[[Token, ASGIConnection[Any, Any, Any]], Awaitable[Any]]</code>  <p>A function that receives an instance of 'Token' and returns a user, which can be any arbitrary value.</p>  required    <code>scopes</code>  <code>Scopes</code>  <p>ASGI scopes processed by the authentication middleware.</p>  required    <code>token_secret</code>  <code>str</code>  <p>Secret for decoding the JWT token. This value should be equivalent to the secret used to encode it.</p>  required"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.JWTCookieAuthenticationMiddleware","title":"starlite.contrib.jwt.JWTCookieAuthenticationMiddleware","text":"<p>         Bases: <code>JWTAuthenticationMiddleware</code></p> <p>Cookie based JWT authentication middleware.</p>"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.middleware.JWTCookieAuthenticationMiddleware.__init__","title":"__init__","text":"<pre><code>__init__(\n    algorithm,\n    app,\n    auth_cookie_key,\n    auth_header,\n    exclude,\n    exclude_opt_key,\n    retrieve_user_handler,\n    scopes,\n    token_secret,\n)\n</code></pre>  <p>Check incoming requests for an encoded token in the auth header or cookie name specified, and if present retrieves the user from persistence using the provided function.</p> <p>Parameters:</p>    Name Type Description Default     <code>algorithm</code>  <code>str</code>  <p>JWT hashing algorithm to use.</p>  required    <code>app</code>  <code>ASGIApp</code>  <p>An ASGIApp, this value is the next ASGI handler to call in the middleware stack.</p>  required    <code>auth_cookie_key</code>  <code>str</code>  <p>Cookie name from which to retrieve the token. E.g. 'token' or 'accessToken'.</p>  required    <code>auth_header</code>  <code>str</code>  <p>Request header key from which to retrieve the token. E.g. 'Authorization' or 'X-Api-Key'.</p>  required    <code>exclude</code>  <code>Optional[Union[str, List[str]]]</code>  <p>A pattern or list of patterns to skip.</p>  required    <code>exclude_opt_key</code>  <code>str</code>  <p>An identifier to use on routes to disable authentication for a particular route.</p>  required    <code>retrieve_user_handler</code>  <code>AsyncCallable[[Token, ASGIConnection[Any, Any, Any]], Awaitable[Any]]</code>  <p>A function that receives an instance of 'Token' and returns a user, which can be any arbitrary value.</p>  required    <code>scopes</code>  <code>Scopes</code>  <p>ASGI scopes processed by the authentication middleware.</p>  required    <code>token_secret</code>  <code>str</code>  <p>Secret for decoding the JWT token. This value should be equivalent to the secret used to encode it.</p>  required"},{"location":"reference/contrib/mako/","title":"Mako Template Engine","text":""},{"location":"reference/contrib/mako/#starlite.contrib.mako.MakoTemplateEngine","title":"starlite.contrib.mako.MakoTemplateEngine","text":"<p>         Bases: <code>TemplateEngineProtocol[MakoTemplate]</code></p> <p>Mako based TemplateEngine.</p>"},{"location":"reference/contrib/mako/#starlite.contrib.mako.MakoTemplateEngine.__init__","title":"__init__","text":"<pre><code>__init__(directory)\n</code></pre>  <p>Initialize template engine.</p> <p>Parameters:</p>    Name Type Description Default     <code>directory</code>  <code>Union[DirectoryPath, List[DirectoryPath]]</code>  <p>Direct path or list of directory paths from which to serve templates.</p>  required"},{"location":"reference/contrib/mako/#starlite.contrib.mako.MakoTemplateEngine.get_template","title":"get_template","text":"<pre><code>get_template(template_name)\n</code></pre>  <p>Retrieve a template by matching its name (dotted path) with files in the directory or directories provided.</p> <p>Parameters:</p>    Name Type Description Default     <code>template_name</code>  <code>str</code>  <p>A dotted path</p>  required     <p>Returns:</p>    Type Description      <code>MakoTemplate</code>  <p>MakoTemplate instance</p>    <p>Raises:</p>    Type Description      <code>[TemplateNotFoundException][starlite.exceptions.TemplateNotFoundException]</code>  <p>if no template is found.</p>"},{"location":"reference/contrib/mako/#starlite.contrib.mako.MakoTemplateEngine.register_template_callable","title":"register_template_callable","text":"<pre><code>register_template_callable(key, template_callable)\n</code></pre>  <p>Register a callable on the template engine.</p> <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>str</code>  <p>The callable key, i.e. the value to use inside the template to call the callable.</p>  required    <code>template_callable</code>  <code>Callable[[Dict[str, Any]], Any]</code>  <p>A callable to register.</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/contrib/opentelemetry/","title":"OpenTelemetry","text":""},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.OpenTelemetryConfig","title":"starlite.contrib.opentelemetry.OpenTelemetryConfig","text":"<p>         Bases: <code>BaseModel</code></p> <p>Configuration class for the OpenTelemetry middleware.</p> <p>Consult the OpenTelemetry ASGI documentation for more info about the configuration options.</p>"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.config.OpenTelemetryConfig.client_request_hook_handler","title":"client_request_hook_handler  <code>class-attribute</code>","text":"<pre><code>client_request_hook_handler: Optional[OpenTelemetryHookHandler] = None\n</code></pre>  <p>Optional callback which is called with the internal span and an ASGI scope which is sent as a dictionary for when the method receive is called.</p>"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.config.OpenTelemetryConfig.client_response_hook_handler","title":"client_response_hook_handler  <code>class-attribute</code>","text":"<pre><code>client_response_hook_handler: Optional[OpenTelemetryHookHandler] = None\n</code></pre>  <p>Optional callback which is called with the internal span and an ASGI event which is sent as a dictionary for when the method send is called.</p>"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.config.OpenTelemetryConfig.exclude","title":"exclude  <code>class-attribute</code>","text":"<pre><code>exclude: Optional[Union[str, List[str]]] = None\n</code></pre>  <p>A pattern or list of patterns to skip in the Allowed Hosts middleware.</p>"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.config.OpenTelemetryConfig.exclude_opt_key","title":"exclude_opt_key  <code>class-attribute</code>","text":"<pre><code>exclude_opt_key: Optional[str] = None\n</code></pre>  <p>An identifier to use on routes to disable hosts check for a particular route.</p>"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.config.OpenTelemetryConfig.exclude_urls_env_key","title":"exclude_urls_env_key  <code>class-attribute</code>","text":"<pre><code>exclude_urls_env_key: str = 'STARLITE'\n</code></pre>  <p>Key to use when checking whether a list of excluded urls is passed via ENV.</p> <p>OpenTelemetry supports excluding urls by passing an env in the format '{exclude_urls_env_key}_EXCLUDED_URLS'. With the default being 'STARLITE_EXCLUDED_URLS'.</p>"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.config.OpenTelemetryConfig.meter","title":"meter  <code>class-attribute</code>","text":"<pre><code>meter: Optional[Meter] = None\n</code></pre>  <p>Optional meter to use.</p> <p>If omitted the provided meter provider or the global one will be used.</p>"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.config.OpenTelemetryConfig.meter_provider","title":"meter_provider  <code>class-attribute</code>","text":"<pre><code>meter_provider: Optional[MeterProvider] = None\n</code></pre>  <p>Optional meter provider to use.</p> <p>If omitted the current globally configured one is used.</p>"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.config.OpenTelemetryConfig.middleware","title":"middleware  <code>property</code>","text":"<pre><code>middleware: DefineMiddleware\n</code></pre>  <p>Create an instance of DefineMiddleware that wraps with.</p> <p>OpenTelemetry InstrumentationMiddleware or a subclass of this middleware.</p> <p>Returns:</p>    Type Description      <code>DefineMiddleware</code>  <p>An instance of <code>DefineMiddleware</code>.</p>"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.config.OpenTelemetryConfig.scope_span_details_extractor","title":"scope_span_details_extractor  <code>class-attribute</code>","text":"<pre><code>scope_span_details_extractor: Callable[[Scope], Tuple[str, dict]] = get_route_details_from_scope\n</code></pre>  <p>Callback which should return a string and a tuple, representing the desired default span name and a dictionary with any additional span attributes to set.</p>"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.config.OpenTelemetryConfig.scopes","title":"scopes  <code>class-attribute</code>","text":"<pre><code>scopes: Optional[Scopes] = None\n</code></pre>  <p>ASGI scopes processed by the middleware, if None both 'http' and 'websocket' will be processed.</p>"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.config.OpenTelemetryConfig.server_request_hook_handler","title":"server_request_hook_handler  <code>class-attribute</code>","text":"<pre><code>server_request_hook_handler: Optional[OpenTelemetryHookHandler] = None\n</code></pre>  <p>Optional callback which is called with the server span and ASGI scope object for every incoming request.</p>"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.config.OpenTelemetryConfig.tracer_provider","title":"tracer_provider  <code>class-attribute</code>","text":"<pre><code>tracer_provider: Optional[TracerProvider] = None\n</code></pre>  <p>Optional tracer provider to use.</p> <p>If omitted the current globally configured one is used.</p>"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.OpenTelemetryInstrumentationMiddleware","title":"starlite.contrib.opentelemetry.OpenTelemetryInstrumentationMiddleware","text":"<p>         Bases: <code>AbstractMiddleware</code></p> <p>OpenTelemetry Middleware.</p>"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.middleware.OpenTelemetryInstrumentationMiddleware.__init__","title":"__init__","text":"<pre><code>__init__(app, config)\n</code></pre>  <p>Middleware that adds OpenTelemetry instrumentation to the application.</p> <p>Parameters:</p>    Name Type Description Default     <code>app</code>  <code>ASGIApp</code>  <p>The 'next' ASGI app to call.</p>  required    <code>config</code>  <code>OpenTelemetryConfig</code>  <p>An instance of OpenTelemetryConfig</p>  required"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.get_route_details_from_scope","title":"starlite.contrib.opentelemetry.get_route_details_from_scope","text":"<pre><code>starlite.contrib.opentelemetry.get_route_details_from_scope(scope)\n</code></pre>  <p>Retrieve the span name and attributes from the ASGI scope.</p> <p>Parameters:</p>    Name Type Description Default     <code>scope</code>  <code>Scope</code>  <p>The ASGI scope instance.</p>  required     <p>Returns:</p>    Type Description      <code>Tuple[str, Dict[Any, str]]</code>  <p>A tuple of the span name and a dict of attrs.</p>"},{"location":"reference/datastructures/0-state/","title":"State","text":""},{"location":"reference/datastructures/0-state/#starlite.datastructures.ImmutableState","title":"starlite.datastructures.ImmutableState","text":"<p>         Bases: <code>Mapping[str, Any]</code></p> <p>An object meant to store arbitrary state.</p> <p>It can be accessed using dot notation while exposing dict like functionalities.</p>"},{"location":"reference/datastructures/0-state/#starlite.datastructures.state.ImmutableState.__init__","title":"__init__","text":"<pre><code>__init__(state, deep_copy=True)\n</code></pre>  <p>Initialize an <code>ImmutableState</code> instance.</p> <p>Parameters:</p>    Name Type Description Default     <code>state</code>  <code>Union[ImmutableState, Dict[str, Any], Iterable[Tuple[str, Any]]]</code>  <p>An object to initialize the state from. Can be a dict, an instance of 'ImmutableState', or a tuple of key value paris.</p>  required    <code>deep_copy</code>  <code>bool</code>  <p>Whether to 'deepcopy' the passed in state.</p>  <code>True</code>     <p>Examples:</p> <pre><code>from starlite import ImmutableState\n\nstate_dict = {\"first\": 1, \"second\": 2, \"third\": 3, \"fourth\": 4}\nstate = ImmutableState(state_dict)\n\n# state implements the Mapping type:\nassert len(state) == 3\nassert \"first\" in state\nassert not \"fourth\" in state\nassert state[\"first\"] == 1\nassert [(k, v) for k, v in state.items()] == [(\"first\", 1), (\"second\", 2), (\"third\", 3)]\n\n# state implements __bool__\nassert state  # state is true when it has values.\nassert not State()  # state is empty when it has no values.\n\n# it has a 'dict' method to retrieve a shallow copy of the underlying dict\ninner_dict = state.dict()\nassert inner_dict == state_dict\n\n# you can also retrieve a mutable State by calling 'mutable_copy'\nmutable_state = state.mutable_copy()\ndel state[\"first\"]\nassert \"first\" not in state\n</code></pre>"},{"location":"reference/datastructures/0-state/#starlite.datastructures.state.ImmutableState.dict","title":"dict","text":"<pre><code>dict()\n</code></pre>  <p>Return a shallow copy of the wrapped dict.</p> <p>Returns:</p>    Type Description      <code>Dict[str, Any]</code>  <p>A dict</p>"},{"location":"reference/datastructures/0-state/#starlite.datastructures.state.ImmutableState.mutable_copy","title":"mutable_copy","text":"<pre><code>mutable_copy()\n</code></pre>  <p>Return a mutable copy of the state object.</p> <p>Returns:</p>    Type Description      <code>State</code>  <p>A <code>State</code></p>"},{"location":"reference/datastructures/0-state/#starlite.datastructures.State","title":"starlite.datastructures.State","text":"<p>         Bases: <code>ImmutableState</code>, <code>MutableMapping[str, Any]</code></p> <p>An object meant to store arbitrary state.</p> <p>It can be accessed using dot notation while exposing dict like functionalities.</p>"},{"location":"reference/datastructures/0-state/#starlite.datastructures.state.State.__init__","title":"__init__","text":"<pre><code>__init__(state=None, deep_copy=False)\n</code></pre>  <p>Initialize a <code>State</code> instance with an optional value.</p> <p>Parameters:</p>    Name Type Description Default     <code>state</code>  <code>Optional[Union[ImmutableState, Dict[str, Any], Iterable[Tuple[str, Any]]]]</code>  <p>An object to initialize the state from. Can be a dict, an instance of 'ImmutableState', or a tuple of key value paris.</p>  <code>None</code>    <code>deep_copy</code>  <code>bool</code>  <p>Whether to 'deepcopy' the passed in state.</p>  <code>False</code>     <p>Examples:</p> <pre><code>from starlite import State\n\nstate_dict = {\"first\": 1, \"second\": 2, \"third\": 3, \"fourth\": 4}\nstate = State(state_dict)\n\n# state can be accessed using '.' notation\nassert state.fourth == 4\ndel state.fourth\n\n# state implements the Mapping type:\nassert len(state) == 3\nassert \"first\" in state\nassert not \"fourth\" in state\nassert state[\"first\"] == 1\nassert [(k, v) for k, v in state.items()] == [(\"first\", 1), (\"second\", 2), (\"third\", 3)]\n\nstate[\"fourth\"] = 4\nassert \"fourth\" in state\ndel state[\"fourth\"]\n\n# state implements __bool__\nassert state  # state is true when it has values.\nassert not State()  # state is empty when it has no values.\n\n# it has shallow copy\ncopied_state = state.copy()\ndel copied_state.first\nassert state.first\n\n# it has a 'dict' method to retrieve a shallow copy of the underlying dict\ninner_dict = state.dict()\nassert inner_dict == state_dict\n\n# you can get an immutable copy of the state by calling 'immutable_immutable_copy'\nimmutable_copy = state.immutable_copy()\ndel immutable_copy.first  #  raises AttributeError\n</code></pre>"},{"location":"reference/datastructures/0-state/#starlite.datastructures.state.State.copy","title":"copy","text":"<pre><code>copy()\n</code></pre>  <p>Return a shallow copy of the state object.</p> <p>Returns:</p>    Type Description      <code>State</code>  <p>A <code>State</code></p>"},{"location":"reference/datastructures/0-state/#starlite.datastructures.state.State.immutable_copy","title":"immutable_copy","text":"<pre><code>immutable_copy()\n</code></pre>  <p>Return a shallow copy of the state object, setting it to be frozen.</p> <p>Returns:</p>    Type Description      <code>ImmutableState</code>  <p>A <code>State</code></p>"},{"location":"reference/datastructures/1-cookie/","title":"Cookie","text":""},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.Cookie","title":"starlite.datastructures.Cookie  <code>dataclass</code>","text":"<p>Container class for defining a cookie using the 'Set-Cookie' header.</p> <p>See: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie for more details regarding this header.</p>"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.description","title":"description  <code>class-attribute</code>","text":"<pre><code>description: Optional[str] = None\n</code></pre>  <p>Description of the response cookie header for OpenAPI documentation.</p>"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.documentation_only","title":"documentation_only  <code>class-attribute</code>","text":"<pre><code>documentation_only: bool = False\n</code></pre>  <p>Defines the Cookie instance as for OpenAPI documentation purpose only.</p>"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.domain","title":"domain  <code>class-attribute</code>","text":"<pre><code>domain: Optional[str] = None\n</code></pre>  <p>Domain for which the cookie is valid.</p>"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.expires","title":"expires  <code>class-attribute</code>","text":"<pre><code>expires: Optional[int] = None\n</code></pre>  <p>Expiration date as unix MS timestamp.</p>"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.httponly","title":"httponly  <code>class-attribute</code>","text":"<pre><code>httponly: Optional[bool] = None\n</code></pre>  <p>Forbids javascript to access the cookie via 'Document.cookie'.</p>"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.key","title":"key  <code>class-attribute</code>","text":"<pre><code>key: str\n</code></pre>  <p>Key for the cookie.</p>"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.max_age","title":"max_age  <code>class-attribute</code>","text":"<pre><code>max_age: Optional[int] = None\n</code></pre>  <p>Maximal age of the cookie before its invalidated.</p>"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.path","title":"path  <code>class-attribute</code>","text":"<pre><code>path: str = '/'\n</code></pre>  <p>Path fragment that must exist in the request url for the cookie to be valid.</p> <p>Defaults to '/'.</p>"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.samesite","title":"samesite  <code>class-attribute</code>","text":"<pre><code>samesite: Literal['lax', 'strict', 'none'] = 'lax'\n</code></pre>  <p>Controls whether or not a cookie is sent with cross-site requests.</p> <p>Defaults to 'lax'.</p>"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.secure","title":"secure  <code>class-attribute</code>","text":"<pre><code>secure: Optional[bool] = None\n</code></pre>  <p>Https is required for the cookie.</p>"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.value","title":"value  <code>class-attribute</code>","text":"<pre><code>value: Optional[str] = None\n</code></pre>  <p>Value for the cookie, if none given defaults to empty string.</p>"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.to_header","title":"to_header","text":"<pre><code>to_header(**kwargs)\n</code></pre>  <p>Return a string representation suitable to be sent as HTTP headers.</p> <p>Parameters:</p>    Name Type Description Default     <code>**kwargs</code>  <code>Any</code>  <p>Any kwargs to pass to the simple cookie output method.</p>  <code>{}</code>"},{"location":"reference/datastructures/2-provide/","title":"Provide","text":""},{"location":"reference/datastructures/2-provide/#starlite.datastructures.Provide","title":"starlite.datastructures.Provide","text":"<p>A wrapper class for dependency injection.</p>"},{"location":"reference/datastructures/2-provide/#starlite.datastructures.provide.Provide.__init__","title":"__init__","text":"<pre><code>__init__(dependency, use_cache=False, sync_to_thread=False)\n</code></pre>  <p>Initialize <code>Provide</code></p> <p>Parameters:</p>    Name Type Description Default     <code>dependency</code>  <code>AnyCallable</code>  <p>Callable to inject, can be a function, method or class.</p>  required    <code>use_cache</code>  <code>bool</code>  <p>Cache the dependency return value. Defaults to False.</p>  <code>False</code>    <code>sync_to_thread</code>  <code>bool</code>  <p>Run sync code in an async thread. Defaults to False.</p>  <code>False</code>"},{"location":"reference/datastructures/3-headers/","title":"Headers","text":""},{"location":"reference/datastructures/3-headers/#starlite.datastructures.Headers","title":"starlite.datastructures.Headers","text":"<p>         Bases: <code>CIMultiDictProxy[str]</code>, <code>MultiMixin[str]</code></p> <p>An immutable, case-insensitive for HTTP headers.</p>  Notes <ul> <li>This class inherits from multidict.</li> </ul>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.Headers.__init__","title":"__init__","text":"<pre><code>__init__(headers=None)\n</code></pre>  <p>Initialize <code>Headers</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>headers</code>  <code>Optional[Union[Mapping[str, str], RawHeaders, MultiMapping]]</code>  <p>Initial value.</p>  <code>None</code>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.Headers.from_scope","title":"from_scope  <code>classmethod</code>","text":"<pre><code>from_scope(scope)\n</code></pre>  <p>Create headers from a send-message.</p> <p>Parameters:</p>    Name Type Description Default     <code>scope</code>  <code>HeaderScope</code>  <p>The ASGI connection scope.</p>  required     <p>Returns:</p>    Type Description      <code>Headers</code>  <p>Headers</p>    <p>Raises:</p>    Type Description      <code>ValueError</code>  <p>If the message does not have a <code>headers</code> key</p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.MutableScopeHeaders","title":"starlite.datastructures.MutableScopeHeaders","text":"<p>         Bases: <code>MutableMapping</code></p> <p>A case-insensitive, multidict-like structure that can be used to mutate headers within a.</p> <p>Scope</p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.MutableScopeHeaders.__init__","title":"__init__","text":"<pre><code>__init__(scope=None)\n</code></pre>  <p>Initialize <code>MutableScopeHeaders</code> from a <code>HeaderScope</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>scope</code>  <code>Optional[HeaderScope]</code>  <p>The ASGI connection scope.</p>  <code>None</code>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.MutableScopeHeaders.add","title":"add","text":"<pre><code>add(key, value)\n</code></pre>  <p>Add a header to the scope.</p>  Notes <ul> <li>This method keeps duplicates.</li> </ul>  <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>str</code>  <p>Header key.</p>  required    <code>value</code>  <code>str</code>  <p>Header value.</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None.</p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.MutableScopeHeaders.getall","title":"getall","text":"<pre><code>getall(key, default=None)\n</code></pre>  <p>Get all values of a header.</p> <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>str</code>  <p>Header key.</p>  required    <code>default</code>  <code>Optional[List[str]]</code>  <p>Default value to return if <code>name</code> is not found.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>List[str]</code>  <p>A list of strings.</p>    <p>Raises:</p>    Type Description      <code>KeyError</code>  <p>if no header for <code>name</code> was found and <code>default</code> is not given.</p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.MutableScopeHeaders.extend_header_value","title":"extend_header_value","text":"<pre><code>extend_header_value(key, value)\n</code></pre>  <p>Extend a multivalued header.</p>  Notes <ul> <li>A multivalues header is a header that can take a comma separated list.</li> <li>If the header previously did not exist, it will be added.</li> </ul>  <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>str</code>  <p>Header key.</p>  required    <code>value</code>  <code>str</code>  <p>Header value to add,</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.ResponseHeader","title":"starlite.datastructures.ResponseHeader","text":"<p>         Bases: <code>Header</code></p> <p>Container type for a response header.</p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.response_header.ResponseHeader.documentation_only","title":"documentation_only  <code>class-attribute</code>","text":"<pre><code>documentation_only: bool = False\n</code></pre>  <p>Defines the ResponseHeader instance as for OpenAPI documentation purpose only.</p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.response_header.ResponseHeader.value","title":"value  <code>class-attribute</code>","text":"<pre><code>value: Any = None\n</code></pre>  <p>Value to set for the response header.</p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.Header","title":"starlite.datastructures.headers.Header","text":"<p>         Bases: <code>BaseModel</code>, <code>ABC</code></p> <p>An abstract type for HTTP headers.</p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.Header.documentation_only","title":"documentation_only  <code>class-attribute</code>","text":"<pre><code>documentation_only: bool = False\n</code></pre>  <p>Defines the header instance as for OpenAPI documentation purpose only.</p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.CacheControlHeader","title":"starlite.datastructures.CacheControlHeader","text":"<p>         Bases: <code>Header</code></p> <p>A <code>cache-control</code> header.</p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.max_age","title":"max_age  <code>class-attribute</code>","text":"<pre><code>max_age: Optional[int] = None\n</code></pre>  <p>Accessor for the <code>max-age</code> directive.</p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.s_maxage","title":"s_maxage  <code>class-attribute</code>","text":"<pre><code>s_maxage: Optional[int] = None\n</code></pre>  <p>Accessor for the <code>s-maxage</code> directive.</p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.no_cache","title":"no_cache  <code>class-attribute</code>","text":"<pre><code>no_cache: Optional[bool] = None\n</code></pre>  <p>Accessor for the <code>no-cache</code> directive.</p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.no_store","title":"no_store  <code>class-attribute</code>","text":"<pre><code>no_store: Optional[bool] = None\n</code></pre>  <p>Accessor for the <code>no-store</code> directive.</p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.private","title":"private  <code>class-attribute</code>","text":"<pre><code>private: Optional[bool] = None\n</code></pre>  <p>Accessor for the <code>private</code> directive.</p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.public","title":"public  <code>class-attribute</code>","text":"<pre><code>public: Optional[bool] = None\n</code></pre>  <p>Accessor for the <code>public</code> directive.</p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.no_transform","title":"no_transform  <code>class-attribute</code>","text":"<pre><code>no_transform: Optional[bool] = None\n</code></pre>  <p>Accessor for the <code>no-transform</code> directive.</p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.must_revalidate","title":"must_revalidate  <code>class-attribute</code>","text":"<pre><code>must_revalidate: Optional[bool] = None\n</code></pre>  <p>Accessor for the <code>must-revalidate</code> directive.</p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.proxy_revalidate","title":"proxy_revalidate  <code>class-attribute</code>","text":"<pre><code>proxy_revalidate: Optional[bool] = None\n</code></pre>  <p>Accessor for the <code>proxy-revalidate</code> directive.</p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.must_understand","title":"must_understand  <code>class-attribute</code>","text":"<pre><code>must_understand: Optional[bool] = None\n</code></pre>  <p>Accessor for the <code>must-understand</code> directive.</p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.immutable","title":"immutable  <code>class-attribute</code>","text":"<pre><code>immutable: Optional[bool] = None\n</code></pre>  <p>Accessor for the <code>immutable</code> directive.</p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.stale_while_revalidate","title":"stale_while_revalidate  <code>class-attribute</code>","text":"<pre><code>stale_while_revalidate: Optional[int] = None\n</code></pre>  <p>Accessor for the <code>stale-while-revalidate</code> directive.</p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.from_header","title":"from_header  <code>classmethod</code>","text":"<pre><code>from_header(header_value)\n</code></pre>  <p>Create a <code>CacheControlHeader</code> instance from the header value.</p> <p>Parameters:</p>    Name Type Description Default     <code>header_value</code>  <code>str</code>  <p>the header value as string</p>  required     <p>Returns:</p>    Type Description      <code>CacheControlHeader</code>  <p>An instance of <code>CacheControlHeader</code></p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.prevent_storing","title":"prevent_storing  <code>classmethod</code>","text":"<pre><code>prevent_storing()\n</code></pre>  <p>Create a <code>cache-control</code> header with the <code>no-store</code> directive which indicates that any caches of any kind (private or shared) should not store this response.</p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.ETag","title":"starlite.datastructures.ETag","text":"<p>         Bases: <code>Header</code></p> <p>An <code>etag</code> header.</p>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.ETag.value","title":"value  <code>class-attribute</code>","text":"<pre><code>value: Annotated[Optional[str], Field(regex=^[ -~]+$)] = None\n</code></pre>"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.ETag.weak","title":"weak  <code>class-attribute</code>","text":"<pre><code>weak: bool = False\n</code></pre>"},{"location":"reference/datastructures/4-background/","title":"Background","text":""},{"location":"reference/datastructures/4-background/#starlite.datastructures.BackgroundTask","title":"starlite.datastructures.BackgroundTask","text":"<p>A container for a 'background' task function.</p> <p>Background tasks are called once a Response finishes.</p>"},{"location":"reference/datastructures/4-background/#starlite.datastructures.background_tasks.BackgroundTask.__init__","title":"__init__","text":"<pre><code>__init__(fn, *args, **kwargs)\n</code></pre>  <p>Initialize <code>BackgroundTask</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>fn</code>  <code>Callable[P, Any]</code>  <p>A sync or async function to call as the background task.</p>  required    <code>*args</code>  <code>P.args</code>  <p>Args to pass to the func.</p>  <code>()</code>    <code>**kwargs</code>  <code>P.kwargs</code>  <p>Kwargs to pass to the func</p>  <code>{}</code>"},{"location":"reference/datastructures/4-background/#starlite.datastructures.BackgroundTasks","title":"starlite.datastructures.BackgroundTasks","text":"<p>A container for multiple 'background' task functions.</p> <p>Background tasks are called once a Response finishes.</p>"},{"location":"reference/datastructures/4-background/#starlite.datastructures.background_tasks.BackgroundTasks.__init__","title":"__init__","text":"<pre><code>__init__(tasks, run_in_task_group=False)\n</code></pre>  <p>Initialize <code>BackgroundTasks</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>tasks</code>  <code>Iterable[BackgroundTask]</code>  <p>An iterable of BackgroundTask instances.</p>  required    <code>run_in_task_group</code>  <code>bool</code>  <p>If you set this value to <code>True</code> than the tasks will run concurrently, using an anyio.task_group. Note: this will not preserve execution order.</p>  <code>False</code>"},{"location":"reference/datastructures/5-response-containers/","title":"Response Containers","text":""},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.ResponseContainer","title":"starlite.datastructures.ResponseContainer","text":"<p>         Bases: <code>ABC</code>, <code>GenericModel</code>, <code>Generic[R]</code></p> <p>Generic response container.</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.ResponseContainer.background","title":"background  <code>class-attribute</code>","text":"<pre><code>background: Optional[Union[BackgroundTask, BackgroundTasks]] = None\n</code></pre>  <p>A BackgroundTask instance or.</p> <p>BackgroundTasks to execute after the response is finished. Defaults to None.</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.ResponseContainer.cookies","title":"cookies  <code>class-attribute</code>","text":"<pre><code>cookies: List[Cookie] = []\n</code></pre>  <p>A list of Cookie instances to be set under the response 'Set-Cookie' header.</p> <p>Defaults to None.</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.ResponseContainer.encoding","title":"encoding  <code>class-attribute</code>","text":"<pre><code>encoding: str = 'utf-8'\n</code></pre>  <p>The encoding to be used for the response headers.</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.ResponseContainer.headers","title":"headers  <code>class-attribute</code>","text":"<pre><code>headers: Dict[str, Any] = {}\n</code></pre>  <p>A string/string dictionary of response headers.</p> <p>Header keys are insensitive. Defaults to None.</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.ResponseContainer.media_type","title":"media_type  <code>class-attribute</code>","text":"<pre><code>media_type: Optional[Union[MediaType, str]] = None\n</code></pre>  <p>If defined, overrides the media type configured in the route decorator.</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.ResponseContainer.to_response","title":"to_response  <code>abstractmethod</code>","text":"<pre><code>to_response(headers, media_type, status_code, app, request)\n</code></pre>  <p>Abstract method that should be implemented by subclasses.</p> <p>Parameters:</p>    Name Type Description Default     <code>headers</code>  <code>Dict[str, Any]</code>  <p>A dictionary of headers.</p>  required    <code>media_type</code>  <code>Union[MediaType, str]</code>  <p>A string or member of the MediaType enum.</p>  required    <code>status_code</code>  <code>int</code>  <p>A response status code.</p>  required    <code>app</code>  <code>Starlite</code>  <p>The Starlite application instance.</p>  required    <code>request</code>  <code>Request</code>  <p>A Request instance.</p>  required     <p>Returns:</p>    Type Description      <code>R</code>  <p>A Response Object</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.File","title":"starlite.datastructures.File","text":"<p>         Bases: <code>ResponseContainer[FileResponse]</code></p> <p>Container type for returning File responses.</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.File.chunk_size","title":"chunk_size  <code>class-attribute</code>","text":"<pre><code>chunk_size: int = DEFAULT_CHUNK_SIZE\n</code></pre>  <p>The size of chunks to use when streaming the file.</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.File.content_disposition_type","title":"content_disposition_type  <code>class-attribute</code>","text":"<pre><code>content_disposition_type: Literal['attachment', 'inline'] = 'attachment'\n</code></pre>  <p>The type of the 'Content-Disposition'.</p> <p>Either 'inline' or 'attachment'.</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.File.etag","title":"etag  <code>class-attribute</code>","text":"<pre><code>etag: Optional[ETag] = None\n</code></pre>  <p>An optional ETag instance.</p> <p>If not provided, an etag will be automatically generated.</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.File.file_info","title":"file_info  <code>class-attribute</code>","text":"<pre><code>file_info: Optional[FileInfo] = None\n</code></pre>  <p>The output of calling <code>file_system.info(..)</code>, equivalent to providing a <code>stat_result</code>.</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.File.file_system","title":"file_system  <code>class-attribute</code>","text":"<pre><code>file_system: Any = BaseLocalFileSystem()\n</code></pre>  <p>The file_system spec to use loading the file.</p>  Notes <ul> <li>A file_system is a class that adheres to the     FileSystemProtocol.</li> <li>You can use any of the file systems exported from the     fsspec library for this purpose.</li> </ul>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.File.filename","title":"filename  <code>class-attribute</code>","text":"<pre><code>filename: Optional[str] = None\n</code></pre>  <p>An optional filename to set in the header.</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.File.path","title":"path  <code>class-attribute</code>","text":"<pre><code>path: FilePath\n</code></pre>  <p>Path to the file to send.</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.File.stat_result","title":"stat_result  <code>class-attribute</code>","text":"<pre><code>stat_result: Optional[os.stat_result] = None\n</code></pre>  <p>An optional result of calling 'os.stat'.</p> <p>If not provided, this will be done by the response constructor.</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.File.to_response","title":"to_response","text":"<pre><code>to_response(headers, media_type, status_code, app, request)\n</code></pre>  <p>Create a FileResponse instance.</p> <p>Parameters:</p>    Name Type Description Default     <code>headers</code>  <code>Dict[str, Any]</code>  <p>A dictionary of headers.</p>  required    <code>media_type</code>  <code>Optional[Union[MediaType, str]]</code>  <p>A string or member of the MediaType enum.</p>  required    <code>status_code</code>  <code>int</code>  <p>A response status code.</p>  required    <code>app</code>  <code>Starlite</code>  <p>The Starlite application instance.</p>  required    <code>request</code>  <code>Request</code>  <p>A Request instance.</p>  required     <p>Returns:</p>    Type Description      <code>FileResponse</code>  <p>A FileResponse instance</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.File.to_response","title":"to_response","text":"<pre><code>to_response(headers, media_type, status_code, app, request)\n</code></pre>  <p>Create a FileResponse instance.</p> <p>Parameters:</p>    Name Type Description Default     <code>headers</code>  <code>Dict[str, Any]</code>  <p>A dictionary of headers.</p>  required    <code>media_type</code>  <code>Optional[Union[MediaType, str]]</code>  <p>A string or member of the MediaType enum.</p>  required    <code>status_code</code>  <code>int</code>  <p>A response status code.</p>  required    <code>app</code>  <code>Starlite</code>  <p>The Starlite application instance.</p>  required    <code>request</code>  <code>Request</code>  <p>A Request instance.</p>  required     <p>Returns:</p>    Type Description      <code>FileResponse</code>  <p>A FileResponse instance</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.Redirect","title":"starlite.datastructures.Redirect","text":"<p>         Bases: <code>ResponseContainer[RedirectResponse]</code></p> <p>Container type for returning Redirect responses.</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.Redirect.path","title":"path  <code>class-attribute</code>","text":"<pre><code>path: str\n</code></pre>  <p>Redirection path.</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.Redirect.to_response","title":"to_response","text":"<pre><code>to_response(headers, media_type, status_code, app, request)\n</code></pre>  <p>Create a RedirectResponse instance.</p> <p>Parameters:</p>    Name Type Description Default     <code>headers</code>  <code>Dict[str, Any]</code>  <p>A dictionary of headers.</p>  required    <code>media_type</code>  <code>Union[MediaType, str]</code>  <p>A string or member of the MediaType enum.</p>  required    <code>status_code</code>  <code>Literal[301, 302, 303, 307, 308]</code>  <p>A response status code.</p>  required    <code>app</code>  <code>Starlite</code>  <p>The Starlite application instance.</p>  required    <code>request</code>  <code>Request</code>  <p>A Request instance.</p>  required     <p>Returns:</p>    Type Description      <code>RedirectResponse</code>  <p>A RedirectResponse instance</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.Stream","title":"starlite.datastructures.Stream","text":"<p>         Bases: <code>ResponseContainer[StreamingResponse]</code></p> <p>Container type for returning Stream responses.</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.Stream.iterator","title":"iterator  <code>class-attribute</code>","text":"<pre><code>iterator: Union[StreamType[Union[str, bytes]], Callable[[], StreamType[Union[str, bytes]]]]\n</code></pre>  <p>Iterator, Iterable,Generator or async Iterator, Iterable or Generator returning chunks to stream.</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.Stream.to_response","title":"to_response","text":"<pre><code>to_response(headers, media_type, status_code, app, request)\n</code></pre>  <p>Create a StreamingResponse instance.</p> <p>Parameters:</p>    Name Type Description Default     <code>headers</code>  <code>Dict[str, Any]</code>  <p>A dictionary of headers.</p>  required    <code>media_type</code>  <code>Union[MediaType, str]</code>  <p>A string or member of the MediaType enum.</p>  required    <code>status_code</code>  <code>int</code>  <p>A response status code.</p>  required    <code>app</code>  <code>Starlite</code>  <p>The Starlite application instance.</p>  required    <code>request</code>  <code>Request</code>  <p>A Request instance.</p>  required     <p>Returns:</p>    Type Description      <code>StreamingResponse</code>  <p>A StreamingResponse instance</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.Template","title":"starlite.datastructures.Template","text":"<p>         Bases: <code>ResponseContainer[TemplateResponse]</code></p> <p>Container type for returning Template responses.</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.Template.context","title":"context  <code>class-attribute</code>","text":"<pre><code>context: Dict[str, Any] = {}\n</code></pre>  <p>A dictionary of key/value pairs to be passed to the temple engine's render method.</p> <p>Defaults to None.</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.Template.name","title":"name  <code>class-attribute</code>","text":"<pre><code>name: str\n</code></pre>  <p>Path-like name for the template to be rendered, e.g. \"index.html\".</p>"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.Template.to_response","title":"to_response","text":"<pre><code>to_response(headers, media_type, status_code, app, request)\n</code></pre>  <p>Create a TemplateResponse instance.</p> <p>Parameters:</p>    Name Type Description Default     <code>headers</code>  <code>Dict[str, Any]</code>  <p>A dictionary of headers.</p>  required    <code>media_type</code>  <code>Union[MediaType, str]</code>  <p>A string or member of the MediaType enum.</p>  required    <code>status_code</code>  <code>int</code>  <p>A response status code.</p>  required    <code>app</code>  <code>Starlite</code>  <p>The Starlite application instance.</p>  required    <code>request</code>  <code>Request</code>  <p>A Request instance.</p>  required     <p>Raises:</p>    Type Description      <code>[ImproperlyConfiguredException][starlite.exceptions.ImproperlyConfiguredException]</code>  <p>if app.template_engine is not configured.</p>    <p>Returns:</p>    Type Description      <code>TemplateResponse</code>  <p>A TemplateResponse instance</p>"},{"location":"reference/datastructures/6-upload-file/","title":"Upload File","text":""},{"location":"reference/datastructures/6-upload-file/#starlite.datastructures.UploadFile","title":"starlite.datastructures.UploadFile","text":"<p>Representation of a file upload, modifying the pydantic schema.</p>"},{"location":"reference/datastructures/6-upload-file/#starlite.datastructures.upload_file.UploadFile.rolled_to_disk","title":"rolled_to_disk  <code>property</code>","text":"<pre><code>rolled_to_disk: bool\n</code></pre>  <p>Determine whether the spooled file exceeded the rolled-to-disk threshold and is no longer in memory.</p> <p>Returns:</p>    Type Description      <code>bool</code>  <p>A boolean flag</p>"},{"location":"reference/datastructures/6-upload-file/#starlite.datastructures.upload_file.UploadFile.__init__","title":"__init__","text":"<pre><code>__init__(content_type, filename, file_data=None, headers=None, max_spool_size=ONE_MEGABYTE)\n</code></pre>  <p>Upload file in-memory container.</p> <p>Parameters:</p>    Name Type Description Default     <code>content_type</code>  <code>str</code>  <p>Content type for the file.</p>  required    <code>filename</code>  <code>str</code>  <p>The filename.</p>  required    <code>file_data</code>  <code>Optional[bytes]</code>  <p>File data.</p>  <code>None</code>    <code>headers</code>  <code>Optional[Dict[str, str]]</code>  <p>Any attached headers.</p>  <code>None</code>    <code>max_spool_size</code>  <code>int</code>  <p>The size above which the temporary file will be rolled to disk.</p>  <code>ONE_MEGABYTE</code>"},{"location":"reference/datastructures/6-upload-file/#starlite.datastructures.upload_file.UploadFile.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre>  <p>Async proxy for file close.</p> <p>Returns:</p>    Type Description      <code>None</code>  <p>None.</p>"},{"location":"reference/datastructures/6-upload-file/#starlite.datastructures.upload_file.UploadFile.read","title":"read  <code>async</code>","text":"<pre><code>read(size=-1)\n</code></pre>  <p>Proxy for data reading.</p> <p>Parameters:</p>    Name Type Description Default     <code>size</code>  <code>int</code>  <p>position from which to read.</p>  <code>-1</code>     <p>Returns:</p>    Type Description      <code>bytes</code>  <p>Byte string.</p>"},{"location":"reference/datastructures/6-upload-file/#starlite.datastructures.upload_file.UploadFile.seek","title":"seek  <code>async</code>","text":"<pre><code>seek(offset)\n</code></pre>  <p>Async proxy for file seek.</p> <p>Parameters:</p>    Name Type Description Default     <code>offset</code>  <code>int</code>  <p>start position..</p>  required     <p>Returns:</p>    Type Description      <code>int</code>  <p>None.</p>"},{"location":"reference/datastructures/6-upload-file/#starlite.datastructures.upload_file.UploadFile.write","title":"write  <code>async</code>","text":"<pre><code>write(data)\n</code></pre>  <p>Proxy for data writing.</p> <p>Parameters:</p>    Name Type Description Default     <code>data</code>  <code>bytes</code>  <p>Byte string to write.</p>  required     <p>Returns:</p>    Type Description      <code>int</code>  <p>None</p>"},{"location":"reference/datastructures/7-multi-dicts/","title":"Multi-Dicts","text":""},{"location":"reference/datastructures/7-multi-dicts/#starlite.datastructures.multi_dicts.MultiMixin","title":"starlite.datastructures.multi_dicts.MultiMixin","text":"<p>         Bases: <code>Generic[T]</code>, <code>MultiMapping[T]</code>, <code>ABC</code></p> <p>Mixin providing common methods for multi dicts, used by.</p> <p>ImmutableMultiDict and MultiDict</p>"},{"location":"reference/datastructures/7-multi-dicts/#starlite.datastructures.multi_dicts.MultiMixin.multi_items","title":"multi_items","text":"<pre><code>multi_items()\n</code></pre>  <p>Get all keys and values, including duplicates.</p> <p>Returns:</p>    Type Description      <code>Generator[Tuple[str, T], None, None]</code>  <p>A list of tuples containing key-value pairs</p>"},{"location":"reference/datastructures/7-multi-dicts/#starlite.datastructures.multi_dicts.MultiMixin.dict","title":"dict","text":"<pre><code>dict()\n</code></pre>  <p>Return the multi-dict as a dict of lists.</p> <p>Returns:</p>    Type Description      <code>Dict[str, List[Any]]</code>  <p>A dict of lists</p>"},{"location":"reference/datastructures/7-multi-dicts/#starlite.datastructures.MultiDict","title":"starlite.datastructures.MultiDict","text":"<p>         Bases: <code>BaseMultiDict[T]</code>, <code>MultiMixin[T]</code>, <code>Generic[T]</code></p> <p>MultiDict, using MultiDict.</p>"},{"location":"reference/datastructures/7-multi-dicts/#starlite.datastructures.ImmutableMultiDict","title":"starlite.datastructures.ImmutableMultiDict","text":"<p>         Bases: <code>MultiDictProxy[T]</code>, <code>MultiMixin[T]</code>, <code>Generic[T]</code></p> <p>Immutable MultiDict, using.</p> <p>MultiDictProxy.</p>"},{"location":"reference/datastructures/7-multi-dicts/#starlite.datastructures.FormMultiDict","title":"starlite.datastructures.FormMultiDict","text":"<p>         Bases: <code>ImmutableMultiDict[Any]</code></p> <p>MultiDict for form data.</p>"},{"location":"reference/datastructures/7-multi-dicts/#starlite.datastructures.multi_dicts.FormMultiDict.close","title":"close  <code>async</code>","text":"<pre><code>close()\n</code></pre>  <p>Close all files in the multi-dict.</p> <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/datastructures/8-url/","title":"URL","text":""},{"location":"reference/datastructures/8-url/#starlite.datastructures.URL","title":"starlite.datastructures.URL","text":"<p>Representation and modification utilities of a URL.</p>"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.fragment","title":"fragment  <code>class-attribute</code>","text":"<pre><code>fragment: str\n</code></pre>  <p>Fragment component.</p>"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.hostname","title":"hostname  <code>class-attribute</code>","text":"<pre><code>hostname: Optional[str]\n</code></pre>  <p>Hostname if specified.</p>"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.netloc","title":"netloc  <code>class-attribute</code>","text":"<pre><code>netloc: str\n</code></pre>  <p>Network location.</p>"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.password","title":"password  <code>class-attribute</code>","text":"<pre><code>password: Optional[str]\n</code></pre>  <p>Password if specified.</p>"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.path","title":"path  <code>class-attribute</code>","text":"<pre><code>path: str\n</code></pre>  <p>Hierarchical path.</p>"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.port","title":"port  <code>class-attribute</code>","text":"<pre><code>port: Optional[int]\n</code></pre>  <p>Port if specified.</p>"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.query","title":"query  <code>class-attribute</code>","text":"<pre><code>query: str\n</code></pre>  <p>Query string.</p>"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.scheme","title":"scheme  <code>class-attribute</code>","text":"<pre><code>scheme: str\n</code></pre>  <p>URL scheme.</p>"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.username","title":"username  <code>class-attribute</code>","text":"<pre><code>username: Optional[str]\n</code></pre>  <p>Username if specified.</p>"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.query_params","title":"query_params  <code>property</code>","text":"<pre><code>query_params: MultiDict\n</code></pre>  <p>Query parameters of a URL as a MultiDict</p> <p>Returns:</p>    Type Description      <code>MultiDict</code>  <p>A MultiDict with query parameters</p>     Notes <ul> <li>While the returned <code>MultiDict</code> is mutable, URL     itself is immutable, therefore mutating the query parameters will not     directly mutate the <code>URL</code>. If you want to modify query parameters, make     modifications in the multidict and pass them back to     with_replacements</li> </ul>"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.from_components","title":"from_components  <code>cached</code> <code>classmethod</code>","text":"<pre><code>from_components(scheme='', netloc='', path='', fragment='', query='')\n</code></pre>  <p>Create a new URL from components.</p> <p>Parameters:</p>    Name Type Description Default     <code>scheme</code>  <code>str</code>  <p>URL scheme</p>  <code>''</code>    <code>netloc</code>  <code>str</code>  <p>Network location</p>  <code>''</code>    <code>path</code>  <code>str</code>  <p>Hierarchical path</p>  <code>''</code>    <code>query</code>  <code>str</code>  <p>Query component</p>  <code>''</code>    <code>fragment</code>  <code>str</code>  <p>Fragment identifier</p>  <code>''</code>     <p>Returns:</p>    Type Description      <code>URL</code>  <p>A new URL with the given components</p>"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.from_scope","title":"from_scope  <code>classmethod</code>","text":"<pre><code>from_scope(scope)\n</code></pre>  <p>Construct a URL from a Scope</p> <p>Parameters:</p>    Name Type Description Default     <code>scope</code>  <code>Scope</code>  <p>A scope</p>  required     <p>Returns:</p>    Type Description      <code>URL</code>  <p>A URL</p>"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.with_replacements","title":"with_replacements","text":"<pre><code>with_replacements(scheme='', netloc='', path='', query=None, fragment='')\n</code></pre>  <p>Create a new URL, replacing the given components.</p> <p>Parameters:</p>    Name Type Description Default     <code>scheme</code>  <code>str</code>  <p>URL scheme</p>  <code>''</code>    <code>netloc</code>  <code>str</code>  <p>Network location</p>  <code>''</code>    <code>path</code>  <code>str</code>  <p>Hierarchical path</p>  <code>''</code>    <code>query</code>  <code>Optional[Union[str, MultiDict]]</code>  <p>Raw query string</p>  <code>None</code>    <code>fragment</code>  <code>str</code>  <p>Fragment identifier</p>  <code>''</code>     <p>Returns:</p>    Type Description      <code>URL</code>  <p>A new URL with the given components replaced</p>"},{"location":"reference/datastructures/8-url/#starlite.datastructures.Address","title":"starlite.datastructures.Address","text":"<p>         Bases: <code>NamedTuple</code></p> <p>Just a network address.</p>"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.Address.host","title":"host  <code>class-attribute</code>","text":"<pre><code>host: str\n</code></pre>  <p>Address host.</p>"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.Address.port","title":"port  <code>class-attribute</code>","text":"<pre><code>port: int\n</code></pre>  <p>Address port.</p>"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.make_absolute_url","title":"starlite.datastructures.url.make_absolute_url","text":"<pre><code>starlite.datastructures.url.make_absolute_url(path, base)\n</code></pre>  <p>Create an absolute URL.</p> <p>Parameters:</p>    Name Type Description Default     <code>path</code>  <code>Union[str, URL]</code>  <p>URL path to make absolute</p>  required    <code>base</code>  <code>Union[str, URL]</code>  <p>URL to use as a base</p>  required     <p>Returns:</p>    Type Description      <code>str</code>  <p>A string representing the new, absolute URL</p>"},{"location":"reference/datastructures/9-pagination/","title":"Pagination Containers","text":""},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.ClassicPagination","title":"starlite.datastructures.ClassicPagination  <code>dataclass</code>","text":"<p>         Bases: <code>Generic[T]</code></p> <p>Container for data returned using limit/offset pagination.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.ClassicPagination.items","title":"items  <code>class-attribute</code>","text":"<pre><code>items: List[T]\n</code></pre>  <p>List of data being sent as part of the response.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.ClassicPagination.page_size","title":"page_size  <code>class-attribute</code>","text":"<pre><code>page_size: int\n</code></pre>  <p>Number of items per page.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.ClassicPagination.current_page","title":"current_page  <code>class-attribute</code>","text":"<pre><code>current_page: int\n</code></pre>  <p>Current page number.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.ClassicPagination.total_pages","title":"total_pages  <code>class-attribute</code>","text":"<pre><code>total_pages: int\n</code></pre>  <p>Total number of pages.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.OffsetPagination","title":"starlite.datastructures.OffsetPagination  <code>dataclass</code>","text":"<p>         Bases: <code>Generic[T]</code></p> <p>Container for data returned using limit/offset pagination.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.OffsetPagination.items","title":"items  <code>class-attribute</code>","text":"<pre><code>items: List[T]\n</code></pre>  <p>List of data being sent as part of the response.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.OffsetPagination.limit","title":"limit  <code>class-attribute</code>","text":"<pre><code>limit: int\n</code></pre>  <p>Maximal number of items to send.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.OffsetPagination.offset","title":"offset  <code>class-attribute</code>","text":"<pre><code>offset: int\n</code></pre>  <p>Offset from the beginning of the query.</p> <p>Identical to an index.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.OffsetPagination.total","title":"total  <code>class-attribute</code>","text":"<pre><code>total: int\n</code></pre>  <p>Total number of items.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.CursorPagination","title":"starlite.datastructures.CursorPagination  <code>dataclass</code>","text":"<p>         Bases: <code>Generic[C, T]</code></p> <p>Container for data returned using cursor pagination.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.CursorPagination.items","title":"items  <code>class-attribute</code>","text":"<pre><code>items: List[T]\n</code></pre>  <p>List of data being sent as part of the response.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.CursorPagination.results_per_page","title":"results_per_page  <code>class-attribute</code>","text":"<pre><code>results_per_page: int\n</code></pre>  <p>Maximal number of items to send.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.CursorPagination.cursor","title":"cursor  <code>class-attribute</code>","text":"<pre><code>cursor: Optional[C]\n</code></pre>  <p>Unique ID, designating the last identifier in the given data set.</p> <p>This value can be used to request the \"next\" batch of records.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.AbstractSyncClassicPaginator","title":"starlite.datastructures.AbstractSyncClassicPaginator","text":"<p>         Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Base paginator class for sync classic pagination.</p> <p>Implement this class to return paginated result sets using the classic pagination scheme.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractSyncClassicPaginator.__call__","title":"__call__","text":"<pre><code>__call__(page_size, current_page)\n</code></pre>  <p>Return a paginated result set.</p> <p>Parameters:</p>    Name Type Description Default     <code>page_size</code>  <code>int</code>  <p>Maximal number of records to return.</p>  required    <code>current_page</code>  <code>int</code>  <p>The current page of results to return.</p>  required     <p>Returns:</p>    Type Description      <code>ClassicPagination[T]</code>  <p>A paginated result set.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractSyncClassicPaginator.get_items","title":"get_items  <code>abstractmethod</code>","text":"<pre><code>get_items(page_size, current_page)\n</code></pre>  <p>Return a list of items of the given size 'page_size' correlating with 'current_page'.</p> <p>Parameters:</p>    Name Type Description Default     <code>page_size</code>  <code>int</code>  <p>Maximal number of records to return.</p>  required    <code>current_page</code>  <code>int</code>  <p>The current page of results to return.</p>  required     <p>Returns:</p>    Type Description      <code>List[T]</code>  <p>A list of items.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractSyncClassicPaginator.get_total","title":"get_total  <code>abstractmethod</code>","text":"<pre><code>get_total(page_size)\n</code></pre>  <p>Return the total number of records.</p> <p>Parameters:</p>    Name Type Description Default     <code>page_size</code>  <code>int</code>  <p>Maximal number of records to return.</p>  required     <p>Returns:</p>    Type Description      <code>int</code>  <p>An integer.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.AbstractAsyncClassicPaginator","title":"starlite.datastructures.AbstractAsyncClassicPaginator","text":"<p>         Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Base paginator class for async classic pagination.</p> <p>Implement this class to return paginated result sets using the classic pagination scheme.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractAsyncClassicPaginator.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(page_size, current_page)\n</code></pre>  <p>Return a paginated result set.</p> <p>Parameters:</p>    Name Type Description Default     <code>page_size</code>  <code>int</code>  <p>Maximal number of records to return.</p>  required    <code>current_page</code>  <code>int</code>  <p>The current page of results to return.</p>  required     <p>Returns:</p>    Type Description      <code>ClassicPagination[T]</code>  <p>A paginated result set.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractAsyncClassicPaginator.get_items","title":"get_items  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_items(page_size, current_page)\n</code></pre>  <p>Return a list of items of the given size 'page_size' correlating with 'current_page'.</p> <p>Parameters:</p>    Name Type Description Default     <code>page_size</code>  <code>int</code>  <p>Maximal number of records to return.</p>  required    <code>current_page</code>  <code>int</code>  <p>The current page of results to return.</p>  required     <p>Returns:</p>    Type Description      <code>List[T]</code>  <p>A list of items.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractAsyncClassicPaginator.get_total","title":"get_total  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_total(page_size)\n</code></pre>  <p>Return the total number of records.</p> <p>Parameters:</p>    Name Type Description Default     <code>page_size</code>  <code>int</code>  <p>Maximal number of records to return.</p>  required     <p>Returns:</p>    Type Description      <code>int</code>  <p>An integer.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.AbstractSyncOffsetPaginator","title":"starlite.datastructures.AbstractSyncOffsetPaginator","text":"<p>         Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Base paginator class for limit / offset pagination.</p> <p>Implement this class to return paginated result sets using the limit / offset pagination scheme.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractSyncOffsetPaginator.__call__","title":"__call__","text":"<pre><code>__call__(limit, offset)\n</code></pre>  <p>Return a paginated result set.</p> <p>Parameters:</p>    Name Type Description Default     <code>limit</code>  <code>int</code>  <p>Maximal number of records to return.</p>  required    <code>offset</code>  <code>int</code>  <p>Starting position within the result set (assume index 0 as starting position).</p>  required     <p>Returns:</p>    Type Description      <code>OffsetPagination[T]</code>  <p>A paginated result set.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractSyncOffsetPaginator.get_items","title":"get_items  <code>abstractmethod</code>","text":"<pre><code>get_items(limit, offset)\n</code></pre>  <p>Return a list of items of the given size 'limit' starting from position 'offset'.</p> <p>Parameters:</p>    Name Type Description Default     <code>limit</code>  <code>int</code>  <p>Maximal number of records to return.</p>  required    <code>offset</code>  <code>int</code>  <p>Starting position within the result set (assume index 0 as starting position).</p>  required     <p>Returns:</p>    Type Description      <code>List[T]</code>  <p>A list of items.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractSyncOffsetPaginator.get_total","title":"get_total  <code>abstractmethod</code>","text":"<pre><code>get_total()\n</code></pre>  <p>Return the total number of records.</p> <p>Returns:</p>    Type Description      <code>int</code>  <p>An integer.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.AbstractAsyncOffsetPaginator","title":"starlite.datastructures.AbstractAsyncOffsetPaginator","text":"<p>         Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>Base paginator class for limit / offset pagination.</p> <p>Implement this class to return paginated result sets using the limit / offset pagination scheme.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractAsyncOffsetPaginator.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(limit, offset)\n</code></pre>  <p>Return a paginated result set.</p> <p>Parameters:</p>    Name Type Description Default     <code>limit</code>  <code>int</code>  <p>Maximal number of records to return.</p>  required    <code>offset</code>  <code>int</code>  <p>Starting position within the result set (assume index 0 as starting position).</p>  required     <p>Returns:</p>    Type Description      <code>OffsetPagination[T]</code>  <p>A paginated result set.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractAsyncOffsetPaginator.get_items","title":"get_items  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_items(limit, offset)\n</code></pre>  <p>Return a list of items of the given size 'limit' starting from position 'offset'.</p> <p>Parameters:</p>    Name Type Description Default     <code>limit</code>  <code>int</code>  <p>Maximal number of records to return.</p>  required    <code>offset</code>  <code>int</code>  <p>Starting position within the result set (assume index 0 as starting position).</p>  required     <p>Returns:</p>    Type Description      <code>List[T]</code>  <p>A list of items.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractAsyncOffsetPaginator.get_total","title":"get_total  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_total()\n</code></pre>  <p>Return the total number of records.</p> <p>Returns:</p>    Type Description      <code>int</code>  <p>An integer.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.AbstractSyncCursorPaginator","title":"starlite.datastructures.AbstractSyncCursorPaginator","text":"<p>         Bases: <code>ABC</code>, <code>Generic[C, T]</code></p> <p>Base paginator class for sync cursor pagination.</p> <p>Implement this class to return paginated result sets using the cursor pagination scheme.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractSyncCursorPaginator.__call__","title":"__call__","text":"<pre><code>__call__(cursor, results_per_page)\n</code></pre>  <p>Return a paginated result set given an optional cursor (unique ID) and a maximal number of results to return.</p> <p>Parameters:</p>    Name Type Description Default     <code>cursor</code>  <code>Optional[C]</code>  <p>A unique identifier that acts as the 'cursor' after which results should be given.</p>  required    <code>results_per_page</code>  <code>int</code>  <p>A maximal number of results to return.</p>  required     <p>Returns:</p>    Type Description      <code>CursorPagination[C, T]</code>  <p>A paginated result set.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractSyncCursorPaginator.get_items","title":"get_items  <code>abstractmethod</code>","text":"<pre><code>get_items(cursor, results_per_page)\n</code></pre>  <p>Return a list of items of the size 'results_per_page' following the given cursor, if any,</p> <p>Parameters:</p>    Name Type Description Default     <code>cursor</code>  <code>Optional[C]</code>  <p>A unique identifier that acts as the 'cursor' after which results should be given.</p>  required    <code>results_per_page</code>  <code>int</code>  <p>A maximal number of results to return.</p>  required     <p>Returns:</p>    Type Description      <code>List[T]</code>  <p>A tuple containing the result set and a new cursor that marks the last record retrieved.</p>    <code>Optional[C]</code>  <p>The new cursor can be used to ask for the 'next_cursor' batch of results.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.AbstractAsyncCursorPaginator","title":"starlite.datastructures.AbstractAsyncCursorPaginator","text":"<p>         Bases: <code>ABC</code>, <code>Generic[C, T]</code></p> <p>Base paginator class for async cursor pagination.</p> <p>Implement this class to return paginated result sets using the cursor pagination scheme.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractAsyncCursorPaginator.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(cursor, results_per_page)\n</code></pre>  <p>Return a paginated result set given an optional cursor (unique ID) and a maximal number of results to return.</p> <p>Parameters:</p>    Name Type Description Default     <code>cursor</code>  <code>Optional[C]</code>  <p>A unique identifier that acts as the 'cursor' after which results should be given.</p>  required    <code>results_per_page</code>  <code>int</code>  <p>A maximal number of results to return.</p>  required     <p>Returns:</p>    Type Description      <code>CursorPagination[C, T]</code>  <p>A paginated result set.</p>"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractAsyncCursorPaginator.get_items","title":"get_items  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get_items(cursor, results_per_page)\n</code></pre>  <p>Return a list of items of the size 'results_per_page' following the given cursor, if any,</p> <p>Parameters:</p>    Name Type Description Default     <code>cursor</code>  <code>Optional[C]</code>  <p>A unique identifier that acts as the 'cursor' after which results should be given.</p>  required    <code>results_per_page</code>  <code>int</code>  <p>A maximal number of results to return.</p>  required     <p>Returns:</p>    Type Description      <code>List[T]</code>  <p>A tuple containing the result set and a new cursor that marks the last record retrieved.</p>    <code>Optional[C]</code>  <p>The new cursor can be used to ask for the 'next_cursor' batch of results.</p>"},{"location":"reference/exceptions/0-base-exceptions/","title":"Base Exceptions","text":""},{"location":"reference/exceptions/0-base-exceptions/#starlite.exceptions.StarLiteException","title":"starlite.exceptions.StarLiteException","text":"<p>         Bases: <code>Exception</code></p> <p>Base exception class from which all Starlite exceptions inherit.</p>"},{"location":"reference/exceptions/0-base-exceptions/#starlite.exceptions.base_exceptions.StarLiteException.__init__","title":"__init__","text":"<pre><code>__init__(*args, detail='')\n</code></pre>  <p>Initialize <code>StarLiteException</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>*args</code>  <code>Any</code>  <p>args are cast to <code>str</code> before passing to <code>Exception.__init__()</code></p>  <code>()</code>    <code>detail</code>  <code>str</code>  <p>detail of the exception.</p>  <code>''</code>"},{"location":"reference/exceptions/0-base-exceptions/#starlite.exceptions.MissingDependencyException","title":"starlite.exceptions.MissingDependencyException","text":"<p>         Bases: <code>StarLiteException</code></p> <p>Missing optional dependency.</p> <p>This exception is raised only when a module depends on a dependency that has not been installed.</p>"},{"location":"reference/exceptions/1-http-exceptions/","title":"HTTP Exceptions","text":""},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.HTTPException","title":"starlite.exceptions.HTTPException","text":"<p>         Bases: <code>StarLiteException</code></p> <p>Base exception for HTTP error responses.</p> <p>These exceptions carry information to construct an HTTP response.</p>"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.HTTPException.detail","title":"detail  <code>instance-attribute</code>","text":"<pre><code>detail = detail\n</code></pre>"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.HTTPException.extra","title":"extra  <code>instance-attribute</code>","text":"<pre><code>extra = extra\n</code></pre>"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.HTTPException.headers","title":"headers  <code>instance-attribute</code>","text":"<pre><code>headers = headers\n</code></pre>"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.HTTPException.status_code","title":"status_code  <code>instance-attribute</code>","text":"<pre><code>status_code = status_code or self.status_code\n</code></pre>"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.HTTPException.__init__","title":"__init__","text":"<pre><code>__init__(*args, detail='', status_code=None, headers=None, extra=None)\n</code></pre>  <p>Initialize <code>HTTPException</code>.</p> <p>Set <code>detail</code> and <code>args</code> if not provided.</p> <p>Parameters:</p>    Name Type Description Default     <code>*args</code>  <code>Any</code>  <p>if <code>detail</code> kwarg not provided, first arg should be error detail.</p>  <code>()</code>    <code>detail</code>  <code>str</code>  <p>Exception details or message. Will default to args[0] if not provided.</p>  <code>''</code>    <code>status_code</code>  <code>Optional[int]</code>  <p>Exception HTTP status code.</p>  <code>None</code>    <code>headers</code>  <code>Optional[Dict[str, str]]</code>  <p>Headers to set on the response.</p>  <code>None</code>    <code>extra</code>  <code>Optional[Union[Dict[str, Any], List[Any]]]</code>  <p>An extra mapping to attach to the exception.</p>  <code>None</code>"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.ImproperlyConfiguredException","title":"starlite.exceptions.ImproperlyConfiguredException","text":"<p>         Bases: <code>HTTPException</code>, <code>ValueError</code></p> <p>Application has improper configuration.</p>"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.InternalServerException","title":"starlite.exceptions.InternalServerException","text":"<p>         Bases: <code>HTTPException</code></p> <p>Server encountered an unexpected condition that prevented it from fulfilling the request.</p>"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.InternalServerException.status_code","title":"status_code  <code>class-attribute</code>","text":"<pre><code>status_code = HTTP_500_INTERNAL_SERVER_ERROR\n</code></pre>"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.MethodNotAllowedException","title":"starlite.exceptions.MethodNotAllowedException","text":"<p>         Bases: <code>HTTPException</code></p> <p>Server knows the request method, but the target resource doesn't support this method.</p>"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.MethodNotAllowedException.status_code","title":"status_code  <code>class-attribute</code>","text":"<pre><code>status_code = HTTP_405_METHOD_NOT_ALLOWED\n</code></pre>"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.NotAuthorizedException","title":"starlite.exceptions.NotAuthorizedException","text":"<p>         Bases: <code>HTTPException</code></p> <p>Request lacks valid authentication credentials for the requested resource.</p>"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.NotAuthorizedException.status_code","title":"status_code  <code>class-attribute</code>","text":"<pre><code>status_code = HTTP_401_UNAUTHORIZED\n</code></pre>"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.NoRouteMatchFoundException","title":"starlite.exceptions.NoRouteMatchFoundException","text":"<p>         Bases: <code>InternalServerException</code></p> <p>A route with the given name could not be found.</p>"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.NotFoundException","title":"starlite.exceptions.NotFoundException","text":"<p>         Bases: <code>HTTPException</code>, <code>ValueError</code></p> <p>Cannot find the requested resource.</p>"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.NotFoundException.status_code","title":"status_code  <code>class-attribute</code>","text":"<pre><code>status_code = HTTP_404_NOT_FOUND\n</code></pre>"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.PermissionDeniedException","title":"starlite.exceptions.PermissionDeniedException","text":"<p>         Bases: <code>HTTPException</code></p> <p>Request understood, but not authorized.</p>"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.PermissionDeniedException.status_code","title":"status_code  <code>class-attribute</code>","text":"<pre><code>status_code = HTTP_403_FORBIDDEN\n</code></pre>"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.ServiceUnavailableException","title":"starlite.exceptions.ServiceUnavailableException","text":"<p>         Bases: <code>HTTPException</code></p> <p>Server is not ready to handle the request.</p>"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.TemplateNotFoundException","title":"starlite.exceptions.TemplateNotFoundException","text":"<p>         Bases: <code>InternalServerException</code></p> <p>Referenced template could not be found.</p>"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.TemplateNotFoundException.__init__","title":"__init__","text":"<pre><code>__init__(*args, template_name)\n</code></pre>  <p>Initialize <code>TemplateNotFoundException</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>*args</code>  <code>Any</code>  <p>Passed through to <code>super().__init__()</code> - should not include <code>detail</code>.</p>  <code>()</code>    <code>template_name</code>  <code>str</code>  <p>Name of template that could not be found.</p>  required"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.TooManyRequestsException","title":"starlite.exceptions.TooManyRequestsException","text":"<p>         Bases: <code>HTTPException</code></p> <p>Request limits have been exceeded.</p>"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.TooManyRequestsException.status_code","title":"status_code  <code>class-attribute</code>","text":"<pre><code>status_code = HTTP_429_TOO_MANY_REQUESTS\n</code></pre>"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.ValidationException","title":"starlite.exceptions.ValidationException","text":"<p>         Bases: <code>HTTPException</code>, <code>ValueError</code></p> <p>Client error.</p>"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.ValidationException.status_code","title":"status_code  <code>class-attribute</code>","text":"<pre><code>status_code = HTTP_400_BAD_REQUEST\n</code></pre>"},{"location":"reference/exceptions/2-websocket-exceptions/","title":"WebSocket Exceptions","text":""},{"location":"reference/exceptions/2-websocket-exceptions/#starlite.exceptions.WebSocketException","title":"starlite.exceptions.WebSocketException","text":"<p>         Bases: <code>StarLiteException</code></p> <p>Exception class for websocket related events.</p>"},{"location":"reference/handlers/0-base-handler/","title":"Base Route Handler","text":""},{"location":"reference/handlers/0-base-handler/#starlite.handlers.base.BaseRouteHandler","title":"starlite.handlers.base.BaseRouteHandler","text":"<p>         Bases: <code>Generic[T]</code></p> <p>Base route handler.</p> <p>Serves as a subclass for all route handlers</p>"},{"location":"reference/handlers/0-base-handler/#starlite.handlers.base.BaseRouteHandler.opt","title":"opt  <code>instance-attribute</code>","text":"<pre><code>opt: Dict[str, Any] = opt or {}\n</code></pre>"},{"location":"reference/handlers/1-http-handlers/","title":"HTTP Route Handler Decorators","text":""},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.HTTPRouteHandler","title":"starlite.handlers.HTTPRouteHandler","text":"<p>         Bases: <code>BaseRouteHandler[HTTPRouteHandler]</code></p> <p>HTTP Route Decorator.</p> <p>Use this decorator to decorate an HTTP handler with multiple methods.</p>"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.http.HTTPRouteHandler.__init__","title":"__init__","text":"<pre><code>__init__(\n    path=None,\n    *,\n    after_request=None,\n    after_response=None,\n    background=None,\n    before_request=None,\n    cache=False,\n    cache_control=None,\n    cache_key_builder=None,\n    dependencies=None,\n    etag=None,\n    exception_handlers=None,\n    guards=None,\n    http_method,\n    media_type=None,\n    middleware=None,\n    name=None,\n    opt=None,\n    response_class=None,\n    response_cookies=None,\n    response_headers=None,\n    status_code=None,\n    sync_to_thread=False,\n    content_encoding=None,\n    content_media_type=None,\n    deprecated=False,\n    description=None,\n    include_in_schema=True,\n    operation_id=None,\n    raises=None,\n    response_description=None,\n    responses=None,\n    security=None,\n    summary=None,\n    tags=None,\n    type_encoders=None,\n    **kwargs\n)\n</code></pre>  <p>Initialize <code>HTTPRouteHandler</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>path</code>  <code>Union[Optional[str], Optional[List[str]]]</code>  <p>A path fragment for the route handler function or a list of path fragments. If not given defaults to '/'</p>  <code>None</code>    <code>after_request</code>  <code>Optional[AfterRequestHookHandler]</code>  <p>A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used.</p>  <code>None</code>    <code>after_response</code>  <code>Optional[AfterResponseHookHandler]</code>  <p>A sync or async function called after the response has been awaited. It receives the Request object and should not return any values.</p>  <code>None</code>    <code>background</code>  <code>Optional[Union[BackgroundTask, BackgroundTasks]]</code>  <p>A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None.</p>  <code>None</code>    <code>before_request</code>  <code>Optional[BeforeRequestHookHandler]</code>  <p>A sync or async function called immediately before calling the route handler. Receives the <code>starlite.connection.Request</code> instance and any non-<code>None</code> return value is used for the response, bypassing the route handler.</p>  <code>None</code>    <code>cache</code>  <code>Union[bool, int]</code>  <p>Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response.</p>  <code>False</code>    <code>cache_control</code>  <code>Optional[CacheControlHeader]</code>  <p>A <code>cache-control</code> header of type CacheControlHeader that will be added to the response.</p>  <code>None</code>    <code>cache_key_builder</code>  <code>Optional[CacheKeyBuilder]</code>  <p>A cache-key builder function. Allows for customization of the cache key if caching is configured on the application level.</p>  <code>None</code>    <code>dependencies</code>  <code>Optional[Dict[str, Provide]]</code>  <p>A string keyed dictionary of dependency Provider instances.</p>  <code>None</code>    <code>etag</code>  <code>Optional[ETag]</code>  <p>An <code>etag</code> header of type ETag that will be added to the response.</p>  <code>None</code>    <code>exception_handlers</code>  <code>Optional[ExceptionHandlersMap]</code>  <p>A dictionary that maps handler functions to status codes and/or exception types.</p>  <code>None</code>    <code>guards</code>  <code>Optional[List[Guard]]</code>  <p>A list of Guard callables.</p>  <code>None</code>    <code>http_method</code>  <code>Union[HttpMethod, Method, List[Union[HttpMethod, Method]]]</code>  <p>An http method string, a member of the enum HttpMethod or a list of these that correlates to the methods the route handler function should handle.</p>  required    <code>media_type</code>  <code>Optional[Union[MediaType, str]]</code>  <p>A member of the MediaType enum or a string with a valid IANA Media-Type.</p>  <code>None</code>    <code>middleware</code>  <code>Optional[List[Middleware]]</code>  <p>A list of Middleware.</p>  <code>None</code>    <code>name</code>  <code>Optional[str]</code>  <p>A string identifying the route handler.</p>  <code>None</code>    <code>opt</code>  <code>Optional[Dict[str, Any]]</code>  <p>A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope.</p>  <code>None</code>    <code>response_class</code>  <code>Optional[ResponseType]</code>  <p>A custom subclass of [starlite.response.Response] to be used as route handler's default response.</p>  <code>None</code>    <code>response_cookies</code>  <code>Optional[ResponseCookies]</code>  <p>A list of [Cookie](starlite.datastructures.Cookie] instances.</p>  <code>None</code>    <code>response_headers</code>  <code>Optional[ResponseHeadersMap]</code>  <p>A string keyed dictionary mapping ResponseHeader instances.</p>  <code>None</code>    <code>responses</code>  <code>Optional[Dict[int, ResponseSpec]]</code>  <p>A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema</p>  <code>None</code>    <code>status_code</code>  <code>Optional[int]</code>  <p>An http status code for the response. Defaults to '200' for mixed method or 'GET', 'PUT' and 'PATCH', '201' for 'POST' and '204' for 'DELETE'.</p>  <code>None</code>    <code>sync_to_thread</code>  <code>bool</code>  <p>A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions.</p>  <code>False</code>    <code>content_encoding</code>  <code>Optional[str]</code>  <p>A string describing the encoding of the content, e.g. \"base64\".</p>  <code>None</code>    <code>content_media_type</code>  <code>Optional[str]</code>  <p>A string designating the media-type of the content, e.g. \"image/png\".</p>  <code>None</code>    <code>deprecated</code>  <code>bool</code>  <p>A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema.</p>  <code>False</code>    <code>description</code>  <code>Optional[str]</code>  <p>Text used for the route's schema description section.</p>  <code>None</code>    <code>include_in_schema</code>  <code>bool</code>  <p>A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema.</p>  <code>True</code>    <code>operation_id</code>  <code>Optional[str]</code>  <p>An identifier used for the route's schema operationId. Defaults to the name of the wrapped function.</p>  <code>None</code>    <code>raises</code>  <code>Optional[List[Type[HTTPException]]]</code>  <p>A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved.</p>  <code>None</code>    <code>response_description</code>  <code>Optional[str]</code>  <p>Text used for the route's response schema description section.</p>  <code>None</code>    <code>security</code>  <code>Optional[List[SecurityRequirement]]</code>  <p>A list of dictionaries that contain information about which security scheme can be used on the endpoint.</p>  <code>None</code>    <code>summary</code>  <code>Optional[str]</code>  <p>Text used for the route's schema summary section.</p>  <code>None</code>    <code>tags</code>  <code>Optional[List[str]]</code>  <p>A list of string tags that will be appended to the OpenAPI schema.</p>  <code>None</code>    <code>type_encoders</code>  <code>Optional[TypeEncodersMap]</code>  <p>A mapping of types to callables that transform them into types supported for serialization.</p>  <code>None</code>    <code>**kwargs</code>  <code>Any</code>  <p>Any additional kwarg - will be set in the opt dictionary.</p>  <code>{}</code>"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.route","title":"starlite.handlers.route  <code>module-attribute</code>","text":"<pre><code>starlite.handlers.route = HTTPRouteHandler\n</code></pre>"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.get","title":"starlite.handlers.get","text":"<p>         Bases: <code>HTTPRouteHandler</code></p> <p>GET Route Decorator.</p> <p>Use this decorator to decorate an HTTP handler for GET requests.</p>"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.http.get.__init__","title":"__init__","text":"<pre><code>__init__(\n    path=None,\n    *,\n    after_request=None,\n    after_response=None,\n    background=None,\n    before_request=None,\n    cache=False,\n    cache_control=None,\n    cache_key_builder=None,\n    dependencies=None,\n    etag=None,\n    exception_handlers=None,\n    guards=None,\n    media_type=None,\n    middleware=None,\n    name=None,\n    opt=None,\n    response_class=None,\n    response_cookies=None,\n    response_headers=None,\n    status_code=None,\n    sync_to_thread=False,\n    content_encoding=None,\n    content_media_type=None,\n    deprecated=False,\n    description=None,\n    include_in_schema=True,\n    operation_id=None,\n    raises=None,\n    response_description=None,\n    responses=None,\n    security=None,\n    summary=None,\n    tags=None,\n    type_encoders=None,\n    **kwargs\n)\n</code></pre>  <p>Initialize <code>get</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>path</code>  <code>Union[Optional[str], Optional[List[str]]]</code>  <p>A path fragment for the route handler function or a list of path fragments. If not given defaults to '/'</p>  <code>None</code>    <code>after_request</code>  <code>Optional[AfterRequestHookHandler]</code>  <p>A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used.</p>  <code>None</code>    <code>after_response</code>  <code>Optional[AfterResponseHookHandler]</code>  <p>A sync or async function called after the response has been awaited. It receives the Request object and should not return any values.</p>  <code>None</code>    <code>background</code>  <code>Optional[Union[BackgroundTask, BackgroundTasks]]</code>  <p>A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None.</p>  <code>None</code>    <code>before_request</code>  <code>Optional[BeforeRequestHookHandler]</code>  <p>A sync or async function called immediately before calling the route handler. Receives the <code>starlite.connection.Request</code> instance and any non-<code>None</code> return value is used for the response, bypassing the route handler.</p>  <code>None</code>    <code>cache</code>  <code>Union[bool, int]</code>  <p>Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response.</p>  <code>False</code>    <code>cache_control</code>  <code>Optional[CacheControlHeader]</code>  <p>A <code>cache-control</code> header of type CacheControlHeader that will be added to the response.</p>  <code>None</code>    <code>cache_key_builder</code>  <code>Optional[CacheKeyBuilder]</code>  <p>A cache-key builder function. Allows for customization of the cache key if caching is configured on the application level.</p>  <code>None</code>    <code>dependencies</code>  <code>Optional[Dict[str, Provide]]</code>  <p>A string keyed dictionary of dependency Provider instances.</p>  <code>None</code>    <code>etag</code>  <code>Optional[ETag]</code>  <p>An <code>etag</code> header of type ETag that will be added to the response.</p>  <code>None</code>    <code>exception_handlers</code>  <code>Optional[ExceptionHandlersMap]</code>  <p>A dictionary that maps handler functions to status codes and/or exception types.</p>  <code>None</code>    <code>guards</code>  <code>Optional[List[Guard]]</code>  <p>A list of Guard callables.</p>  <code>None</code>    <code>media_type</code>  <code>Optional[Union[MediaType, str]]</code>  <p>A member of the MediaType enum or a string with a valid IANA Media-Type.</p>  <code>None</code>    <code>middleware</code>  <code>Optional[List[Middleware]]</code>  <p>A list of Middleware.</p>  <code>None</code>    <code>name</code>  <code>Optional[str]</code>  <p>A string identifying the route handler.</p>  <code>None</code>    <code>opt</code>  <code>Optional[Dict[str, Any]]</code>  <p>A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope.</p>  <code>None</code>    <code>response_class</code>  <code>Optional[ResponseType]</code>  <p>A custom subclass of [starlite.response.Response] to be used as route handler's default response.</p>  <code>None</code>    <code>response_cookies</code>  <code>Optional[ResponseCookies]</code>  <p>A list of [Cookie](starlite.datastructures.Cookie] instances.</p>  <code>None</code>    <code>response_headers</code>  <code>Optional[ResponseHeadersMap]</code>  <p>A string keyed dictionary mapping ResponseHeader instances.</p>  <code>None</code>    <code>responses</code>  <code>Optional[Dict[int, ResponseSpec]]</code>  <p>A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema</p>  <code>None</code>    <code>status_code</code>  <code>Optional[int]</code>  <p>An http status code for the response. Defaults to '200'.</p>  <code>None</code>    <code>sync_to_thread</code>  <code>bool</code>  <p>A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions.</p>  <code>False</code>    <code>content_encoding</code>  <code>Optional[str]</code>  <p>A string describing the encoding of the content, e.g. \"base64\".</p>  <code>None</code>    <code>content_media_type</code>  <code>Optional[str]</code>  <p>A string designating the media-type of the content, e.g. \"image/png\".</p>  <code>None</code>    <code>deprecated</code>  <code>bool</code>  <p>A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema.</p>  <code>False</code>    <code>description</code>  <code>Optional[str]</code>  <p>Text used for the route's schema description section.</p>  <code>None</code>    <code>include_in_schema</code>  <code>bool</code>  <p>A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema.</p>  <code>True</code>    <code>operation_id</code>  <code>Optional[str]</code>  <p>An identifier used for the route's schema operationId. Defaults to the name of the wrapped function.</p>  <code>None</code>    <code>raises</code>  <code>Optional[List[Type[HTTPException]]]</code>  <p>A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved.</p>  <code>None</code>    <code>response_description</code>  <code>Optional[str]</code>  <p>Text used for the route's response schema description section.</p>  <code>None</code>    <code>security</code>  <code>Optional[List[SecurityRequirement]]</code>  <p>A list of dictionaries that contain information about which security scheme can be used on the endpoint.</p>  <code>None</code>    <code>summary</code>  <code>Optional[str]</code>  <p>Text used for the route's schema summary section.</p>  <code>None</code>    <code>tags</code>  <code>Optional[List[str]]</code>  <p>A list of string tags that will be appended to the OpenAPI schema.        type_encoders: A mapping of types to callables that transform them into types supported for serialization.</p>  <code>None</code>    <code>type_encoders</code>  <code>Optional[TypeEncodersMap]</code>  <p>A mapping of types to callables that transform them into types supported for serialization.</p>  <code>None</code>    <code>**kwargs</code>  <code>Any</code>  <p>Any additional kwarg - will be set in the opt dictionary.</p>  <code>{}</code>"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.head","title":"starlite.handlers.head","text":"<p>         Bases: <code>HTTPRouteHandler</code></p> <p>HEAD Route Decorator.</p> <p>Use this decorator to decorate an HTTP handler for HEAD requests.</p>"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.http.head.__init__","title":"__init__","text":"<pre><code>__init__(\n    path=None,\n    *,\n    after_request=None,\n    after_response=None,\n    background=None,\n    before_request=None,\n    cache=False,\n    cache_control=None,\n    cache_key_builder=None,\n    dependencies=None,\n    etag=None,\n    exception_handlers=None,\n    guards=None,\n    media_type=None,\n    middleware=None,\n    name=None,\n    opt=None,\n    response_class=None,\n    response_cookies=None,\n    response_headers=None,\n    status_code=None,\n    sync_to_thread=False,\n    content_encoding=None,\n    content_media_type=None,\n    deprecated=False,\n    description=None,\n    include_in_schema=True,\n    operation_id=None,\n    raises=None,\n    response_description=None,\n    responses=None,\n    security=None,\n    summary=None,\n    tags=None,\n    type_encoders=None,\n    **kwargs\n)\n</code></pre>  <p>Initialize <code>head</code>.</p>  Notes <ul> <li>A response to a head request cannot include a body.     See: MDN.</li> </ul>  <p>Parameters:</p>    Name Type Description Default     <code>path</code>  <code>Union[Optional[str], Optional[List[str]]]</code>  <p>A path fragment for the route handler function or a list of path fragments. If not given defaults to '/'</p>  <code>None</code>    <code>after_request</code>  <code>Optional[AfterRequestHookHandler]</code>  <p>A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used.</p>  <code>None</code>    <code>after_response</code>  <code>Optional[AfterResponseHookHandler]</code>  <p>A sync or async function called after the response has been awaited. It receives the Request object and should not return any values.</p>  <code>None</code>    <code>background</code>  <code>Optional[Union[BackgroundTask, BackgroundTasks]]</code>  <p>A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None.</p>  <code>None</code>    <code>before_request</code>  <code>Optional[BeforeRequestHookHandler]</code>  <p>A sync or async function called immediately before calling the route handler. Receives the <code>starlite.connection.Request</code> instance and any non-<code>None</code> return value is used for the response, bypassing the route handler.</p>  <code>None</code>    <code>cache</code>  <code>Union[bool, int]</code>  <p>Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response.</p>  <code>False</code>    <code>cache_control</code>  <code>Optional[CacheControlHeader]</code>  <p>A <code>cache-control</code> header of type CacheControlHeader that will be added to the response.</p>  <code>None</code>    <code>cache_key_builder</code>  <code>Optional[CacheKeyBuilder]</code>  <p>A cache-key builder function. Allows for customization of the cache key if caching is configured on the application level.</p>  <code>None</code>    <code>dependencies</code>  <code>Optional[Dict[str, Provide]]</code>  <p>A string keyed dictionary of dependency Provider instances.</p>  <code>None</code>    <code>exception_handlers</code>  <code>Optional[ExceptionHandlersMap]</code>  <p>A dictionary that maps handler functions to status codes and/or exception types.</p>  <code>None</code>    <code>guards</code>  <code>Optional[List[Guard]]</code>  <p>A list of Guard callables.</p>  <code>None</code>    <code>media_type</code>  <code>Optional[Union[MediaType, str]]</code>  <p>A member of the MediaType enum or a string with a valid IANA Media-Type.</p>  <code>None</code>    <code>middleware</code>  <code>Optional[List[Middleware]]</code>  <p>A list of Middleware.</p>  <code>None</code>    <code>name</code>  <code>Optional[str]</code>  <p>A string identifying the route handler.</p>  <code>None</code>    <code>opt</code>  <code>Optional[Dict[str, Any]]</code>  <p>A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope.</p>  <code>None</code>    <code>response_class</code>  <code>Optional[ResponseType]</code>  <p>A custom subclass of [starlite.response.Response] to be used as route handler's default response.</p>  <code>None</code>    <code>response_cookies</code>  <code>Optional[ResponseCookies]</code>  <p>A list of [Cookie](starlite.datastructures.Cookie] instances.</p>  <code>None</code>    <code>response_headers</code>  <code>Optional[ResponseHeadersMap]</code>  <p>A string keyed dictionary mapping ResponseHeader instances.</p>  <code>None</code>    <code>responses</code>  <code>Optional[Dict[int, ResponseSpec]]</code>  <p>A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema</p>  <code>None</code>    <code>status_code</code>  <code>Optional[int]</code>  <p>An http status code for the response. Defaults to '200'.</p>  <code>None</code>    <code>sync_to_thread</code>  <code>bool</code>  <p>A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions.</p>  <code>False</code>    <code>content_encoding</code>  <code>Optional[str]</code>  <p>A string describing the encoding of the content, e.g. \"base64\".</p>  <code>None</code>    <code>content_media_type</code>  <code>Optional[str]</code>  <p>A string designating the media-type of the content, e.g. \"image/png\".</p>  <code>None</code>    <code>deprecated</code>  <code>bool</code>  <p>A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema.</p>  <code>False</code>    <code>description</code>  <code>Optional[str]</code>  <p>Text used for the route's schema description section.</p>  <code>None</code>    <code>include_in_schema</code>  <code>bool</code>  <p>A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema.</p>  <code>True</code>    <code>operation_id</code>  <code>Optional[str]</code>  <p>An identifier used for the route's schema operationId. Defaults to the name of the wrapped function.</p>  <code>None</code>    <code>raises</code>  <code>Optional[List[Type[HTTPException]]]</code>  <p>A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved.</p>  <code>None</code>    <code>response_description</code>  <code>Optional[str]</code>  <p>Text used for the route's response schema description section.</p>  <code>None</code>    <code>security</code>  <code>Optional[List[SecurityRequirement]]</code>  <p>A list of dictionaries that contain information about which security scheme can be used on the endpoint.</p>  <code>None</code>    <code>summary</code>  <code>Optional[str]</code>  <p>Text used for the route's schema summary section.</p>  <code>None</code>    <code>tags</code>  <code>Optional[List[str]]</code>  <p>A list of string tags that will be appended to the OpenAPI schema.</p>  <code>None</code>    <code>type_encoders</code>  <code>Optional[TypeEncodersMap]</code>  <p>A mapping of types to callables that transform them into types supported for serialization.</p>  <code>None</code>    <code>**kwargs</code>  <code>Any</code>  <p>Any additional kwarg - will be set in the opt dictionary.</p>  <code>{}</code>"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.post","title":"starlite.handlers.post","text":"<p>         Bases: <code>HTTPRouteHandler</code></p> <p>POST Route Decorator.</p> <p>Use this decorator to decorate an HTTP handler for POST requests.</p>"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.http.post.__init__","title":"__init__","text":"<pre><code>__init__(\n    path=None,\n    *,\n    after_request=None,\n    after_response=None,\n    background=None,\n    before_request=None,\n    cache=False,\n    cache_control=None,\n    cache_key_builder=None,\n    dependencies=None,\n    etag=None,\n    exception_handlers=None,\n    guards=None,\n    media_type=None,\n    middleware=None,\n    name=None,\n    opt=None,\n    response_class=None,\n    response_cookies=None,\n    response_headers=None,\n    status_code=None,\n    sync_to_thread=False,\n    content_encoding=None,\n    content_media_type=None,\n    deprecated=False,\n    description=None,\n    include_in_schema=True,\n    operation_id=None,\n    raises=None,\n    response_description=None,\n    responses=None,\n    security=None,\n    summary=None,\n    tags=None,\n    type_encoders=None,\n    **kwargs\n)\n</code></pre>  <p>Initialize <code>post</code></p> <p>Parameters:</p>    Name Type Description Default     <code>path</code>  <code>Union[Optional[str], Optional[List[str]]]</code>  <p>A path fragment for the route handler function or a list of path fragments. If not given defaults to '/'</p>  <code>None</code>    <code>after_request</code>  <code>Optional[AfterRequestHookHandler]</code>  <p>A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used.</p>  <code>None</code>    <code>after_response</code>  <code>Optional[AfterResponseHookHandler]</code>  <p>A sync or async function called after the response has been awaited. It receives the Request object and should not return any values.</p>  <code>None</code>    <code>background</code>  <code>Optional[Union[BackgroundTask, BackgroundTasks]]</code>  <p>A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None.</p>  <code>None</code>    <code>before_request</code>  <code>Optional[BeforeRequestHookHandler]</code>  <p>A sync or async function called immediately before calling the route handler. Receives the <code>starlite.connection.Request</code> instance and any non-<code>None</code> return value is used for the response, bypassing the route handler.</p>  <code>None</code>    <code>cache</code>  <code>Union[bool, int]</code>  <p>Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response.</p>  <code>False</code>    <code>cache_control</code>  <code>Optional[CacheControlHeader]</code>  <p>A <code>cache-control</code> header of type CacheControlHeader that will be added to the response.</p>  <code>None</code>    <code>cache_key_builder</code>  <code>Optional[CacheKeyBuilder]</code>  <p>A cache-key builder function. Allows for customization of the cache key if caching is configured on the application level.</p>  <code>None</code>    <code>dependencies</code>  <code>Optional[Dict[str, Provide]]</code>  <p>A string keyed dictionary of dependency Provider instances.</p>  <code>None</code>    <code>etag</code>  <code>Optional[ETag]</code>  <p>An <code>etag</code> header of type ETag that will be added to the response.</p>  <code>None</code>    <code>exception_handlers</code>  <code>Optional[ExceptionHandlersMap]</code>  <p>A dictionary that maps handler functions to status codes and/or exception types.</p>  <code>None</code>    <code>guards</code>  <code>Optional[List[Guard]]</code>  <p>A list of Guard callables.</p>  <code>None</code>    <code>media_type</code>  <code>Optional[Union[MediaType, str]]</code>  <p>A member of the MediaType enum or a string with a valid IANA Media-Type.</p>  <code>None</code>    <code>middleware</code>  <code>Optional[List[Middleware]]</code>  <p>A list of Middleware.</p>  <code>None</code>    <code>name</code>  <code>Optional[str]</code>  <p>A string identifying the route handler.</p>  <code>None</code>    <code>opt</code>  <code>Optional[Dict[str, Any]]</code>  <p>A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope.</p>  <code>None</code>    <code>response_class</code>  <code>Optional[ResponseType]</code>  <p>A custom subclass of [starlite.response.Response] to be used as route handler's default response.</p>  <code>None</code>    <code>response_cookies</code>  <code>Optional[ResponseCookies]</code>  <p>A list of [Cookie](starlite.datastructures.Cookie] instances.</p>  <code>None</code>    <code>response_headers</code>  <code>Optional[ResponseHeadersMap]</code>  <p>A string keyed dictionary mapping ResponseHeader instances.</p>  <code>None</code>    <code>responses</code>  <code>Optional[Dict[int, ResponseSpec]]</code>  <p>A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema</p>  <code>None</code>    <code>status_code</code>  <code>Optional[int]</code>  <p>An http status code for the response. Defaults to '201' for 'POST'.</p>  <code>None</code>    <code>sync_to_thread</code>  <code>bool</code>  <p>A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions.</p>  <code>False</code>    <code>content_encoding</code>  <code>Optional[str]</code>  <p>A string describing the encoding of the content, e.g. \"base64\".</p>  <code>None</code>    <code>content_media_type</code>  <code>Optional[str]</code>  <p>A string designating the media-type of the content, e.g. \"image/png\".</p>  <code>None</code>    <code>deprecated</code>  <code>bool</code>  <p>A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema.</p>  <code>False</code>    <code>description</code>  <code>Optional[str]</code>  <p>Text used for the route's schema description section.</p>  <code>None</code>    <code>include_in_schema</code>  <code>bool</code>  <p>A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema.</p>  <code>True</code>    <code>operation_id</code>  <code>Optional[str]</code>  <p>An identifier used for the route's schema operationId. Defaults to the name of the wrapped function.</p>  <code>None</code>    <code>raises</code>  <code>Optional[List[Type[HTTPException]]]</code>  <p>A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved.</p>  <code>None</code>    <code>response_description</code>  <code>Optional[str]</code>  <p>Text used for the route's response schema description section.</p>  <code>None</code>    <code>security</code>  <code>Optional[List[SecurityRequirement]]</code>  <p>A list of dictionaries that contain information about which security scheme can be used on the endpoint.</p>  <code>None</code>    <code>summary</code>  <code>Optional[str]</code>  <p>Text used for the route's schema summary section.</p>  <code>None</code>    <code>tags</code>  <code>Optional[List[str]]</code>  <p>A list of string tags that will be appended to the OpenAPI schema.</p>  <code>None</code>    <code>type_encoders</code>  <code>Optional[TypeEncodersMap]</code>  <p>A mapping of types to callables that transform them into types supported for serialization.</p>  <code>None</code>    <code>**kwargs</code>  <code>Any</code>  <p>Any additional kwarg - will be set in the opt dictionary.</p>  <code>{}</code>"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.put","title":"starlite.handlers.put","text":"<p>         Bases: <code>HTTPRouteHandler</code></p> <p>PUT Route Decorator.</p> <p>Use this decorator to decorate an HTTP handler for PUT requests.</p>"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.http.put.__init__","title":"__init__","text":"<pre><code>__init__(\n    path=None,\n    *,\n    after_request=None,\n    after_response=None,\n    background=None,\n    before_request=None,\n    cache=False,\n    cache_control=None,\n    cache_key_builder=None,\n    dependencies=None,\n    etag=None,\n    exception_handlers=None,\n    guards=None,\n    media_type=None,\n    middleware=None,\n    name=None,\n    opt=None,\n    response_class=None,\n    response_cookies=None,\n    response_headers=None,\n    status_code=None,\n    sync_to_thread=False,\n    content_encoding=None,\n    content_media_type=None,\n    deprecated=False,\n    description=None,\n    include_in_schema=True,\n    operation_id=None,\n    raises=None,\n    response_description=None,\n    responses=None,\n    security=None,\n    summary=None,\n    tags=None,\n    type_encoders=None,\n    **kwargs\n)\n</code></pre>  <p>Initialize <code>put</code></p> <p>Parameters:</p>    Name Type Description Default     <code>path</code>  <code>Union[Optional[str], Optional[List[str]]]</code>  <p>A path fragment for the route handler function or a list of path fragments. If not given defaults to '/'</p>  <code>None</code>    <code>after_request</code>  <code>Optional[AfterRequestHookHandler]</code>  <p>A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used.</p>  <code>None</code>    <code>after_response</code>  <code>Optional[AfterResponseHookHandler]</code>  <p>A sync or async function called after the response has been awaited. It receives the Request object and should not return any values.</p>  <code>None</code>    <code>background</code>  <code>Optional[Union[BackgroundTask, BackgroundTasks]]</code>  <p>A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None.</p>  <code>None</code>    <code>before_request</code>  <code>Optional[BeforeRequestHookHandler]</code>  <p>A sync or async function called immediately before calling the route handler. Receives the <code>starlite.connection.Request</code> instance and any non-<code>None</code> return value is used for the response, bypassing the route handler.</p>  <code>None</code>    <code>cache</code>  <code>Union[bool, int]</code>  <p>Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response.</p>  <code>False</code>    <code>cache_control</code>  <code>Optional[CacheControlHeader]</code>  <p>A <code>cache-control</code> header of type CacheControlHeader that will be added to the response.</p>  <code>None</code>    <code>cache_key_builder</code>  <code>Optional[CacheKeyBuilder]</code>  <p>A cache-key builder function. Allows for customization of the cache key if caching is configured on the application level.</p>  <code>None</code>    <code>dependencies</code>  <code>Optional[Dict[str, Provide]]</code>  <p>A string keyed dictionary of dependency Provider instances.</p>  <code>None</code>    <code>etag</code>  <code>Optional[ETag]</code>  <p>An <code>etag</code> header of type ETag that will be added to the response.</p>  <code>None</code>    <code>exception_handlers</code>  <code>Optional[ExceptionHandlersMap]</code>  <p>A dictionary that maps handler functions to status codes and/or exception types.</p>  <code>None</code>    <code>guards</code>  <code>Optional[List[Guard]]</code>  <p>A list of Guard callables.</p>  <code>None</code>    <code>media_type</code>  <code>Optional[Union[MediaType, str]]</code>  <p>A member of the MediaType enum or a string with a valid IANA Media-Type.</p>  <code>None</code>    <code>middleware</code>  <code>Optional[List[Middleware]]</code>  <p>A list of Middleware.</p>  <code>None</code>    <code>name</code>  <code>Optional[str]</code>  <p>A string identifying the route handler.</p>  <code>None</code>    <code>opt</code>  <code>Optional[Dict[str, Any]]</code>  <p>A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope.</p>  <code>None</code>    <code>response_class</code>  <code>Optional[ResponseType]</code>  <p>A custom subclass of [starlite.response.Response] to be used as route handler's default response.</p>  <code>None</code>    <code>response_cookies</code>  <code>Optional[ResponseCookies]</code>  <p>A list of [Cookie](starlite.datastructures.Cookie] instances.</p>  <code>None</code>    <code>response_headers</code>  <code>Optional[ResponseHeadersMap]</code>  <p>A string keyed dictionary mapping ResponseHeader instances.</p>  <code>None</code>    <code>responses</code>  <code>Optional[Dict[int, ResponseSpec]]</code>  <p>A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema</p>  <code>None</code>    <code>status_code</code>  <code>Optional[int]</code>  <p>An http status code for the response. Defaults to '200'.</p>  <code>None</code>    <code>sync_to_thread</code>  <code>bool</code>  <p>A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions.</p>  <code>False</code>    <code>content_encoding</code>  <code>Optional[str]</code>  <p>A string describing the encoding of the content, e.g. \"base64\".</p>  <code>None</code>    <code>content_media_type</code>  <code>Optional[str]</code>  <p>A string designating the media-type of the content, e.g. \"image/png\".</p>  <code>None</code>    <code>deprecated</code>  <code>bool</code>  <p>A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema.</p>  <code>False</code>    <code>description</code>  <code>Optional[str]</code>  <p>Text used for the route's schema description section.</p>  <code>None</code>    <code>include_in_schema</code>  <code>bool</code>  <p>A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema.</p>  <code>True</code>    <code>operation_id</code>  <code>Optional[str]</code>  <p>An identifier used for the route's schema operationId. Defaults to the name of the wrapped function.</p>  <code>None</code>    <code>raises</code>  <code>Optional[List[Type[HTTPException]]]</code>  <p>A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved.</p>  <code>None</code>    <code>response_description</code>  <code>Optional[str]</code>  <p>Text used for the route's response schema description section.</p>  <code>None</code>    <code>security</code>  <code>Optional[List[SecurityRequirement]]</code>  <p>A list of dictionaries that contain information about which security scheme can be used on the endpoint.</p>  <code>None</code>    <code>summary</code>  <code>Optional[str]</code>  <p>Text used for the route's schema summary section.</p>  <code>None</code>    <code>tags</code>  <code>Optional[List[str]]</code>  <p>A list of string tags that will be appended to the OpenAPI schema.</p>  <code>None</code>    <code>type_encoders</code>  <code>Optional[TypeEncodersMap]</code>  <p>A mapping of types to callables that transform them into types supported for serialization.</p>  <code>None</code>    <code>**kwargs</code>  <code>Any</code>  <p>Any additional kwarg - will be set in the opt dictionary.</p>  <code>{}</code>"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.patch","title":"starlite.handlers.patch","text":"<p>         Bases: <code>HTTPRouteHandler</code></p> <p>PATCH Route Decorator.</p> <p>Use this decorator to decorate an HTTP handler for PATCH requests.</p>"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.http.patch.__init__","title":"__init__","text":"<pre><code>__init__(\n    path=None,\n    *,\n    after_request=None,\n    after_response=None,\n    background=None,\n    before_request=None,\n    cache=False,\n    cache_control=None,\n    cache_key_builder=None,\n    dependencies=None,\n    etag=None,\n    exception_handlers=None,\n    guards=None,\n    media_type=None,\n    middleware=None,\n    name=None,\n    opt=None,\n    response_class=None,\n    response_cookies=None,\n    response_headers=None,\n    status_code=None,\n    sync_to_thread=False,\n    content_encoding=None,\n    content_media_type=None,\n    deprecated=False,\n    description=None,\n    include_in_schema=True,\n    operation_id=None,\n    raises=None,\n    response_description=None,\n    responses=None,\n    security=None,\n    summary=None,\n    tags=None,\n    type_encoders=None,\n    **kwargs\n)\n</code></pre>  <p>Initialize <code>patch</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>path</code>  <code>Union[Optional[str], Optional[List[str]]]</code>  <p>A path fragment for the route handler function or a list of path fragments. If not given defaults to '/'</p>  <code>None</code>    <code>after_request</code>  <code>Optional[AfterRequestHookHandler]</code>  <p>A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used.</p>  <code>None</code>    <code>after_response</code>  <code>Optional[AfterResponseHookHandler]</code>  <p>A sync or async function called after the response has been awaited. It receives the Request object and should not return any values.</p>  <code>None</code>    <code>background</code>  <code>Optional[Union[BackgroundTask, BackgroundTasks]]</code>  <p>A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None.</p>  <code>None</code>    <code>before_request</code>  <code>Optional[BeforeRequestHookHandler]</code>  <p>A sync or async function called immediately before calling the route handler. Receives the <code>starlite.connection.Request</code> instance and any non-<code>None</code> return value is used for the response, bypassing the route handler.</p>  <code>None</code>    <code>cache</code>  <code>Union[bool, int]</code>  <p>Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response.</p>  <code>False</code>    <code>cache_control</code>  <code>Optional[CacheControlHeader]</code>  <p>A <code>cache-control</code> header of type CacheControlHeader that will be added to the response.</p>  <code>None</code>    <code>cache_key_builder</code>  <code>Optional[CacheKeyBuilder]</code>  <p>A cache-key builder function. Allows for customization of the cache key if caching is configured on the application level.</p>  <code>None</code>    <code>dependencies</code>  <code>Optional[Dict[str, Provide]]</code>  <p>A string keyed dictionary of dependency Provider instances.</p>  <code>None</code>    <code>etag</code>  <code>Optional[ETag]</code>  <p>An <code>etag</code> header of type ETag that will be added to the response.</p>  <code>None</code>    <code>exception_handlers</code>  <code>Optional[ExceptionHandlersMap]</code>  <p>A dictionary that maps handler functions to status codes and/or exception types.</p>  <code>None</code>    <code>guards</code>  <code>Optional[List[Guard]]</code>  <p>A list of Guard callables.</p>  <code>None</code>    <code>media_type</code>  <code>Optional[Union[MediaType, str]]</code>  <p>A member of the MediaType enum or a string with a valid IANA Media-Type.</p>  <code>None</code>    <code>middleware</code>  <code>Optional[List[Middleware]]</code>  <p>A list of Middleware.</p>  <code>None</code>    <code>name</code>  <code>Optional[str]</code>  <p>A string identifying the route handler.</p>  <code>None</code>    <code>opt</code>  <code>Optional[Dict[str, Any]]</code>  <p>A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope.</p>  <code>None</code>    <code>response_class</code>  <code>Optional[ResponseType]</code>  <p>A custom subclass of [starlite.response.Response] to be used as route handler's default response.</p>  <code>None</code>    <code>response_cookies</code>  <code>Optional[ResponseCookies]</code>  <p>A list of [Cookie](starlite.datastructures.Cookie] instances.</p>  <code>None</code>    <code>response_headers</code>  <code>Optional[ResponseHeadersMap]</code>  <p>A string keyed dictionary mapping ResponseHeader instances.</p>  <code>None</code>    <code>responses</code>  <code>Optional[Dict[int, ResponseSpec]]</code>  <p>A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema</p>  <code>None</code>    <code>status_code</code>  <code>Optional[int]</code>  <p>An http status code for the response. Defaults to '200'.</p>  <code>None</code>    <code>sync_to_thread</code>  <code>bool</code>  <p>A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions.</p>  <code>False</code>    <code>content_encoding</code>  <code>Optional[str]</code>  <p>A string describing the encoding of the content, e.g. \"base64\".</p>  <code>None</code>    <code>content_media_type</code>  <code>Optional[str]</code>  <p>A string designating the media-type of the content, e.g. \"image/png\".</p>  <code>None</code>    <code>deprecated</code>  <code>bool</code>  <p>A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema.</p>  <code>False</code>    <code>description</code>  <code>Optional[str]</code>  <p>Text used for the route's schema description section.</p>  <code>None</code>    <code>include_in_schema</code>  <code>bool</code>  <p>A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema.</p>  <code>True</code>    <code>operation_id</code>  <code>Optional[str]</code>  <p>An identifier used for the route's schema operationId. Defaults to the name of the wrapped function.</p>  <code>None</code>    <code>raises</code>  <code>Optional[List[Type[HTTPException]]]</code>  <p>A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved.</p>  <code>None</code>    <code>response_description</code>  <code>Optional[str]</code>  <p>Text used for the route's response schema description section.</p>  <code>None</code>    <code>security</code>  <code>Optional[List[SecurityRequirement]]</code>  <p>A list of dictionaries that contain information about which security scheme can be used on the endpoint.</p>  <code>None</code>    <code>summary</code>  <code>Optional[str]</code>  <p>Text used for the route's schema summary section.</p>  <code>None</code>    <code>tags</code>  <code>Optional[List[str]]</code>  <p>A list of string tags that will be appended to the OpenAPI schema.</p>  <code>None</code>    <code>type_encoders</code>  <code>Optional[TypeEncodersMap]</code>  <p>A mapping of types to callables that transform them into types supported for serialization.</p>  <code>None</code>    <code>**kwargs</code>  <code>Any</code>  <p>Any additional kwarg - will be set in the opt dictionary.</p>  <code>{}</code>"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.delete","title":"starlite.handlers.delete","text":"<p>         Bases: <code>HTTPRouteHandler</code></p> <p>DELETE Route Decorator.</p> <p>Use this decorator to decorate an HTTP handler for DELETE requests.</p>"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.http.delete.__init__","title":"__init__","text":"<pre><code>__init__(\n    path=None,\n    *,\n    after_request=None,\n    after_response=None,\n    background=None,\n    before_request=None,\n    cache=False,\n    cache_control=None,\n    cache_key_builder=None,\n    dependencies=None,\n    etag=None,\n    exception_handlers=None,\n    guards=None,\n    media_type=None,\n    middleware=None,\n    name=None,\n    opt=None,\n    response_class=None,\n    response_cookies=None,\n    response_headers=None,\n    status_code=None,\n    sync_to_thread=False,\n    content_encoding=None,\n    content_media_type=None,\n    deprecated=False,\n    description=None,\n    include_in_schema=True,\n    operation_id=None,\n    raises=None,\n    response_description=None,\n    responses=None,\n    security=None,\n    summary=None,\n    tags=None,\n    type_encoders=None,\n    **kwargs\n)\n</code></pre>  <p>Initialize <code>delete</code></p> <p>Parameters:</p>    Name Type Description Default     <code>path</code>  <code>Union[Optional[str], Optional[List[str]]]</code>  <p>A path fragment for the route handler function or a list of path fragments. If not given defaults to '/'</p>  <code>None</code>    <code>after_request</code>  <code>Optional[AfterRequestHookHandler]</code>  <p>A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used.</p>  <code>None</code>    <code>after_response</code>  <code>Optional[AfterResponseHookHandler]</code>  <p>A sync or async function called after the response has been awaited. It receives the Request object and should not return any values.</p>  <code>None</code>    <code>background</code>  <code>Optional[Union[BackgroundTask, BackgroundTasks]]</code>  <p>A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None.</p>  <code>None</code>    <code>before_request</code>  <code>Optional[BeforeRequestHookHandler]</code>  <p>A sync or async function called immediately before calling the route handler. Receives the <code>starlite.connection.Request</code> instance and any non-<code>None</code> return value is used for the response, bypassing the route handler.</p>  <code>None</code>    <code>cache</code>  <code>Union[bool, int]</code>  <p>Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response.</p>  <code>False</code>    <code>cache_control</code>  <code>Optional[CacheControlHeader]</code>  <p>A <code>cache-control</code> header of type CacheControlHeader that will be added to the response.</p>  <code>None</code>    <code>cache_key_builder</code>  <code>Optional[CacheKeyBuilder]</code>  <p>A cache-key builder function. Allows for customization of the cache key if caching is configured on the application level.</p>  <code>None</code>    <code>dependencies</code>  <code>Optional[Dict[str, Provide]]</code>  <p>A string keyed dictionary of dependency Provider instances.</p>  <code>None</code>    <code>etag</code>  <code>Optional[ETag]</code>  <p>An <code>etag</code> header of type ETag that will be added to the response.</p>  <code>None</code>    <code>exception_handlers</code>  <code>Optional[ExceptionHandlersMap]</code>  <p>A dictionary that maps handler functions to status codes and/or exception types.</p>  <code>None</code>    <code>guards</code>  <code>Optional[List[Guard]]</code>  <p>A list of Guard callables.</p>  <code>None</code>    <code>media_type</code>  <code>Optional[Union[MediaType, str]]</code>  <p>A member of the MediaType enum or a string with a valid IANA Media-Type.</p>  <code>None</code>    <code>middleware</code>  <code>Optional[List[Middleware]]</code>  <p>A list of Middleware.</p>  <code>None</code>    <code>name</code>  <code>Optional[str]</code>  <p>A string identifying the route handler.</p>  <code>None</code>    <code>opt</code>  <code>Optional[Dict[str, Any]]</code>  <p>A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope.</p>  <code>None</code>    <code>response_class</code>  <code>Optional[ResponseType]</code>  <p>A custom subclass of [starlite.response.Response] to be used as route handler's default response.</p>  <code>None</code>    <code>response_cookies</code>  <code>Optional[ResponseCookies]</code>  <p>A list of [Cookie](starlite.datastructures.Cookie] instances.</p>  <code>None</code>    <code>response_headers</code>  <code>Optional[ResponseHeadersMap]</code>  <p>A string keyed dictionary mapping ResponseHeader instances.</p>  <code>None</code>    <code>responses</code>  <code>Optional[Dict[int, ResponseSpec]]</code>  <p>A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema</p>  <code>None</code>    <code>status_code</code>  <code>Optional[int]</code>  <p>An http status code for the response. Defaults to '204'.</p>  <code>None</code>    <code>sync_to_thread</code>  <code>bool</code>  <p>A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions.</p>  <code>False</code>    <code>content_encoding</code>  <code>Optional[str]</code>  <p>A string describing the encoding of the content, e.g. \"base64\".</p>  <code>None</code>    <code>content_media_type</code>  <code>Optional[str]</code>  <p>A string designating the media-type of the content, e.g. \"image/png\".</p>  <code>None</code>    <code>deprecated</code>  <code>bool</code>  <p>A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema.</p>  <code>False</code>    <code>description</code>  <code>Optional[str]</code>  <p>Text used for the route's schema description section.</p>  <code>None</code>    <code>include_in_schema</code>  <code>bool</code>  <p>A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema.</p>  <code>True</code>    <code>operation_id</code>  <code>Optional[str]</code>  <p>An identifier used for the route's schema operationId. Defaults to the name of the wrapped function.</p>  <code>None</code>    <code>raises</code>  <code>Optional[List[Type[HTTPException]]]</code>  <p>A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved.</p>  <code>None</code>    <code>response_description</code>  <code>Optional[str]</code>  <p>Text used for the route's response schema description section.</p>  <code>None</code>    <code>security</code>  <code>Optional[List[SecurityRequirement]]</code>  <p>A list of dictionaries that contain information about which security scheme can be used on the endpoint.</p>  <code>None</code>    <code>summary</code>  <code>Optional[str]</code>  <p>Text used for the route's schema summary section.</p>  <code>None</code>    <code>tags</code>  <code>Optional[List[str]]</code>  <p>A list of string tags that will be appended to the OpenAPI schema.</p>  <code>None</code>    <code>type_encoders</code>  <code>Optional[TypeEncodersMap]</code>  <p>A mapping of types to callables that transform them into types supported for serialization.</p>  <code>None</code>    <code>**kwargs</code>  <code>Any</code>  <p>Any additional kwarg - will be set in the opt dictionary.</p>  <code>{}</code>"},{"location":"reference/handlers/2-websocket-handlers/","title":"WebSocket Route Handler Decorators","text":""},{"location":"reference/handlers/2-websocket-handlers/#starlite.handlers.WebsocketRouteHandler","title":"starlite.handlers.WebsocketRouteHandler","text":"<p>         Bases: <code>BaseRouteHandler[WebsocketRouteHandler]</code></p> <p>Websocket route handler decorator.</p> <p>Use this decorator to decorate websocket handler functions.</p>"},{"location":"reference/handlers/2-websocket-handlers/#starlite.handlers.websocket.WebsocketRouteHandler.__init__","title":"__init__","text":"<pre><code>__init__(\n    path=None,\n    *,\n    dependencies=None,\n    exception_handlers=None,\n    guards=None,\n    middleware=None,\n    name=None,\n    opt=None,\n    **kwargs\n)\n</code></pre>  <p>Initialize <code>WebsocketRouteHandler</code></p> <p>Parameters:</p>    Name Type Description Default     <code>path</code>  <code>Union[Optional[str], Optional[List[str]]]</code>  <p>A path fragment for the route handler function or a list of path fragments. If not given defaults to '/'</p>  <code>None</code>    <code>dependencies</code>  <code>Optional[Dependencies]</code>  <p>A string keyed dictionary of dependency Provider instances.</p>  <code>None</code>    <code>exception_handlers</code>  <code>Optional[Dict[Union[int, Type[Exception]], ExceptionHandler]]</code>  <p>A dictionary that maps handler functions to status codes and/or exception types.</p>  <code>None</code>    <code>guards</code>  <code>Optional[List[Guard]]</code>  <p>A list of Guard callables.</p>  <code>None</code>    <code>middleware</code>  <code>Optional[List[Middleware]]</code>  <p>A list of Middleware.</p>  <code>None</code>    <code>name</code>  <code>Optional[str]</code>  <p>A string identifying the route handler.</p>  <code>None</code>    <code>opt</code>  <code>Optional[Dict[str, Any]]</code>  <p>A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope.</p>  <code>None</code>    <code>**kwargs</code>  <code>Any</code>  <p>Any additional kwarg - will be set in the opt dictionary.</p>  <code>{}</code>"},{"location":"reference/handlers/2-websocket-handlers/#starlite.handlers.websocket","title":"starlite.handlers.websocket","text":""},{"location":"reference/handlers/3-asgi-handlers/","title":"ASGI Route Handler Decorators","text":""},{"location":"reference/handlers/3-asgi-handlers/#starlite.handlers.ASGIRouteHandler","title":"starlite.handlers.ASGIRouteHandler","text":"<p>         Bases: <code>BaseRouteHandler[ASGIRouteHandler]</code></p> <p>ASGI Route Handler decorator.</p> <p>Use this decorator to decorate ASGI applications.</p>"},{"location":"reference/handlers/3-asgi-handlers/#starlite.handlers.asgi.ASGIRouteHandler.__init__","title":"__init__","text":"<pre><code>__init__(\n    path=None,\n    *,\n    exception_handlers=None,\n    guards=None,\n    name=None,\n    opt=None,\n    is_mount=False,\n    is_static=False,\n    **kwargs\n)\n</code></pre>  <p>Initialize <code>ASGIRouteHandler</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>exception_handlers</code>  <code>Optional[ExceptionHandlersMap]</code>  <p>A dictionary that maps handler functions to status codes and/or exception types.</p>  <code>None</code>    <code>guards</code>  <code>Optional[List[Guard]]</code>  <p>A list of Guard callables.</p>  <code>None</code>    <code>name</code>  <code>Optional[str]</code>  <p>A string identifying the route handler.</p>  <code>None</code>    <code>opt</code>  <code>Optional[Dict[str, Any]]</code>  <p>A string key dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope.</p>  <code>None</code>    <code>path</code>  <code>Union[Optional[str], Optional[List[str]]]</code>  <p>A path fragment for the route handler function or a list of path fragments. If not given defaults to '/'</p>  <code>None</code>    <code>is_mount</code>  <code>bool</code>  <p>A boolean dictating whether the handler's paths should be regarded as mount paths. Mount path accept any arbitrary paths that begin with the defined prefixed path. For example, a mount with the path <code>/some-path/</code> will accept requests for <code>/some-path/</code> and any sub path under this, e.g. <code>/some-path/sub-path/</code> etc.</p>  <code>False</code>    <code>is_static</code>  <code>bool</code>  <p>A boolean dictating whether the handler's paths should be regarded as static paths. Static paths are used to deliver static files.</p>  <code>False</code>    <code>**kwargs</code>  <code>Any</code>  <p>Any additional kwarg - will be set in the opt dictionary.</p>  <code>{}</code>"},{"location":"reference/handlers/3-asgi-handlers/#starlite.handlers.asgi","title":"starlite.handlers.asgi","text":""},{"location":"reference/middleware/0-base/","title":"Middleware Base","text":""},{"location":"reference/middleware/0-base/#starlite.middleware.MiddlewareProtocol","title":"starlite.middleware.MiddlewareProtocol","text":"<p>         Bases: <code>Protocol</code></p> <p>Abstract middleware protocol.</p>"},{"location":"reference/middleware/0-base/#starlite.middleware.base.MiddlewareProtocol.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(scope, receive, send)\n</code></pre>  <p>Execute the ASGI middleware.</p> <p>Called by the previous middleware in the stack if a response is not awaited prior.</p> <p>Upon completion, middleware should call the next ASGI handler and await it - or await a response created in its closure.</p> <p>Parameters:</p>    Name Type Description Default     <code>scope</code>  <code>Scope</code>  <p>The ASGI connection scope.</p>  required    <code>receive</code>  <code>Receive</code>  <p>The ASGI receive function.</p>  required    <code>send</code>  <code>Send</code>  <p>The ASGI send function.</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/0-base/#starlite.middleware.DefineMiddleware","title":"starlite.middleware.DefineMiddleware","text":"<p>Container enabling passing args and *kwargs to Middleware class constructors and factory functions.</p>"},{"location":"reference/middleware/0-base/#starlite.middleware.base.DefineMiddleware.__init__","title":"__init__","text":"<pre><code>__init__(middleware, *args, **kwargs)\n</code></pre>  <p>Initialize <code>DefineMiddleware</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>middleware</code>  <code>Callable[..., ASGIApp]</code>  <p>A callable that returns an ASGIApp.</p>  required    <code>*args</code>  <code>Any</code>  <p>Positional arguments to pass to the callable.</p>  <code>()</code>    <code>**kwargs</code>  <code>Any</code>  <p>Key word arguments to pass to the callable.</p>  <code>{}</code>      Notes <p>The callable will be passed a kwarg <code>app</code>, which is the next ASGI app to call in the middleware stack. It therefore must define such a kwarg.</p>"},{"location":"reference/middleware/0-base/#starlite.middleware.AbstractMiddleware","title":"starlite.middleware.AbstractMiddleware","text":"<p>Abstract middleware providing base functionality common to all middlewares, for dynamically engaging/bypassing the middleware based on paths, <code>opt</code>-keys and scope types.</p> <p>When implementing new middleware, this class should be used as a base.</p>"},{"location":"reference/middleware/0-base/#starlite.middleware.base.AbstractMiddleware.__init__","title":"__init__","text":"<pre><code>__init__(app, exclude=None, exclude_opt_key=None, scopes=None)\n</code></pre>  <p>Initialize the middleware.</p> <p>Parameters:</p>    Name Type Description Default     <code>app</code>  <code>ASGIApp</code>  <p>The 'next' ASGI app to call.</p>  required    <code>exclude</code>  <code>Optional[Union[str, List[str]]]</code>  <p>A pattern or list of patterns to match against a request's path. If a match is found, the middleware will be skipped. .</p>  <code>None</code>    <code>exclude_opt_key</code>  <code>Optional[str]</code>  <p>An identifier that is set in the route handler 'opt' key which allows skipping the middleware.</p>  <code>None</code>    <code>scopes</code>  <code>Optional[Scopes]</code>  <p>ASGI scope types, should be a set including either or both 'ScopeType.HTTP' and 'ScopeType.WEBSOCKET'.</p>  <code>None</code>"},{"location":"reference/middleware/1-authentication-middleware/","title":"Authentication Middleware","text":""},{"location":"reference/middleware/1-authentication-middleware/#starlite.middleware.AuthenticationResult","title":"starlite.middleware.AuthenticationResult","text":"<p>         Bases: <code>BaseModel</code></p> <p>Pydantic model for authentication data.</p>"},{"location":"reference/middleware/1-authentication-middleware/#starlite.middleware.authentication.AuthenticationResult.user","title":"user  <code>class-attribute</code>","text":"<pre><code>user: Any\n</code></pre>  <p>The user model, this can be any value corresponding to a user of the API.</p>"},{"location":"reference/middleware/1-authentication-middleware/#starlite.middleware.authentication.AuthenticationResult.auth","title":"auth  <code>class-attribute</code>","text":"<pre><code>auth: Any = None\n</code></pre>  <p>The auth value, this can for example be a JWT token.</p>"},{"location":"reference/middleware/1-authentication-middleware/#starlite.middleware.AbstractAuthenticationMiddleware","title":"starlite.middleware.AbstractAuthenticationMiddleware","text":"<p>         Bases: <code>ABC</code></p> <p>Abstract AuthenticationMiddleware that allows users to create their own AuthenticationMiddleware by extending it and overriding the 'authenticate_request' method.</p>"},{"location":"reference/middleware/1-authentication-middleware/#starlite.middleware.authentication.AbstractAuthenticationMiddleware.scopes","title":"scopes  <code>instance-attribute</code>","text":"<pre><code>scopes = scopes or {ScopeType.HTTP, ScopeType.WEBSOCKET}\n</code></pre>"},{"location":"reference/middleware/1-authentication-middleware/#starlite.middleware.authentication.AbstractAuthenticationMiddleware.__init__","title":"__init__","text":"<pre><code>__init__(app, exclude=None, exclude_from_auth_key='exclude_from_auth', scopes=None)\n</code></pre>  <p>Initialize <code>AbstractAuthenticationMiddleware</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>app</code>  <code>ASGIApp</code>  <p>An ASGIApp, this value is the next ASGI handler to call in the middleware stack.</p>  required    <code>exclude</code>  <code>Optional[Union[str, List[str]]]</code>  <p>A pattern or list of patterns to skip in the authentication middleware.</p>  <code>None</code>    <code>exclude_from_auth_key</code>  <code>str</code>  <p>An identifier to use on routes to disable authentication for a particular route.</p>  <code>'exclude_from_auth'</code>    <code>scopes</code>  <code>Optional[Scopes]</code>  <p>ASGI scopes processed by the authentication middleware.</p>  <code>None</code>"},{"location":"reference/middleware/1-authentication-middleware/#starlite.middleware.authentication.AbstractAuthenticationMiddleware.authenticate_request","title":"authenticate_request  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>authenticate_request(connection)\n</code></pre>  <p>Receive the http connection and return an <code>AuthenticationResult</code>.</p>  Notes <ul> <li>This method must be overridden by subclasses.</li> </ul>  <p>Parameters:</p>    Name Type Description Default     <code>connection</code>  <code>ASGIConnection</code>  <p>An ASGIConnection instance.</p>  required     <p>Raises:</p>    Type Description      <code>NotAuthorizedException | PermissionDeniedException</code>  <p>if authentication fails.</p>    <p>Returns:</p>    Type Description      <code>AuthenticationResult</code>  <p>An instance of AuthenticationResult.</p>"},{"location":"reference/middleware/2-logging-middleware/","title":"Logging Middleware","text":""},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig","title":"starlite.middleware.logging.LoggingMiddlewareConfig","text":"<p>         Bases: <code>BaseModel</code></p> <p>Configuration for <code>LoggingMiddleware</code></p>"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.exclude","title":"exclude  <code>class-attribute</code>","text":"<pre><code>exclude: Optional[Union[str, List[str]]] = None\n</code></pre>  <p>List of paths to exclude from logging.</p>"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.exclude_opt_key","title":"exclude_opt_key  <code>class-attribute</code>","text":"<pre><code>exclude_opt_key: Optional[str] = None\n</code></pre>  <p>An identifier to use on routes to disable logging for a particular route.</p>"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.include_compressed_body","title":"include_compressed_body  <code>class-attribute</code>","text":"<pre><code>include_compressed_body: bool = False\n</code></pre>  <p>Include body of compressed response in middleware. If <code>\"body\"</code> not set in.</p> <p><code>response_log_fields</code> this config value is ignored.</p>"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.logger_name","title":"logger_name  <code>class-attribute</code>","text":"<pre><code>logger_name: str = 'starlite'\n</code></pre>  <p>Name of the logger to retrieve using <code>app.get_logger(\"&lt;name&gt;\")</code>.</p>"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.middleware","title":"middleware  <code>property</code>","text":"<pre><code>middleware: DefineMiddleware\n</code></pre>  <p>Use this property to insert the config into a middleware list on one of the application layers.</p> <p>Examples:</p> <pre><code>from starlite import Starlite, Request, LoggingConfig, get\nfrom starlite.middleware.logging import LoggingMiddlewareConfig\n\nlogging_config = LoggingConfig()\n\nlogging_middleware_config = LoggingMiddlewareConfig()\n\n\n@get(\"/\")\ndef my_handler(request: Request) -&gt; None:\n    ...\n\n\napp = Starlite(\n    route_handlers=[my_handler],\n    logging_config=logging_config,\n    middleware=[logging_middleware_config.middleware],\n)\n</code></pre> <p>Returns:</p>    Type Description      <code>DefineMiddleware</code>  <p>An instance of DefineMiddleware including 'self' as the config kwarg value.</p>"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.middleware_class","title":"middleware_class  <code>class-attribute</code>","text":"<pre><code>middleware_class: Type[LoggingMiddleware] = LoggingMiddleware\n</code></pre>  <p>Middleware class to use.</p> <p>Should be a subclass of [starlite.middleware.LoggingMiddleware].</p>"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.request_cookies_to_obfuscate","title":"request_cookies_to_obfuscate  <code>class-attribute</code>","text":"<pre><code>request_cookies_to_obfuscate: Set[str] = {'session'}\n</code></pre>  <p>Request cookie keys to obfuscate.</p> <p>Obfuscated values are replaced with '*'.</p>"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.request_headers_to_obfuscate","title":"request_headers_to_obfuscate  <code>class-attribute</code>","text":"<pre><code>request_headers_to_obfuscate: Set[str] = {'Authorization', 'X-API-KEY'}\n</code></pre>  <p>Request header keys to obfuscate.</p> <p>Obfuscated values are replaced with '*'.</p>"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.request_log_fields","title":"request_log_fields  <code>class-attribute</code>","text":"<pre><code>request_log_fields: Iterable[RequestExtractorField] = (\n    \"path\",\n    \"method\",\n    \"content_type\",\n    \"headers\",\n    \"cookies\",\n    \"query\",\n    \"path_params\",\n    \"body\",\n)\n</code></pre>  <p>Fields to extract and log from the request.</p>  Notes <ul> <li>The order of fields in the iterable determines the order of the log message logged out.     Thus, re-arranging the log-message is as simple as changing the iterable.</li> <li>To turn off logging of requests, use and empty iterable.</li> </ul>"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.request_log_message","title":"request_log_message  <code>class-attribute</code>","text":"<pre><code>request_log_message: str = 'HTTP Request'\n</code></pre>  <p>Log message to prepend when logging a request.</p>"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.response_cookies_to_obfuscate","title":"response_cookies_to_obfuscate  <code>class-attribute</code>","text":"<pre><code>response_cookies_to_obfuscate: Set[str] = {'session'}\n</code></pre>  <p>Response cookie keys to obfuscate.</p> <p>Obfuscated values are replaced with '*'.</p>"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.response_headers_to_obfuscate","title":"response_headers_to_obfuscate  <code>class-attribute</code>","text":"<pre><code>response_headers_to_obfuscate: Set[str] = {'Authorization', 'X-API-KEY'}\n</code></pre>  <p>Response header keys to obfuscate.</p> <p>Obfuscated values are replaced with '*'.</p>"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.response_log_fields","title":"response_log_fields  <code>class-attribute</code>","text":"<pre><code>response_log_fields: Iterable[ResponseExtractorField] = (\n    \"status_code\",\n    \"cookies\",\n    \"headers\",\n    \"body\",\n)\n</code></pre>  <p>Fields to extract and log from the response. The order of fields in the iterable determines the order of the log message logged out.</p>  Notes <ul> <li>The order of fields in the iterable determines the order of the log message logged out.     Thus, re-arranging the log-message is as simple as changing the iterable.</li> <li>To turn off logging of responses, use and empty iterable.</li> </ul>"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.response_log_message","title":"response_log_message  <code>class-attribute</code>","text":"<pre><code>response_log_message: str = 'HTTP Response'\n</code></pre>  <p>Log message to prepend when logging a response.</p>"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddleware","title":"starlite.middleware.logging.LoggingMiddleware","text":"<p>         Bases: <code>AbstractMiddleware</code></p> <p>Logging middleware.</p>"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddleware.__init__","title":"__init__","text":"<pre><code>__init__(app, config)\n</code></pre>  <p>Initialize <code>LoggingMiddleware</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>app</code>  <code>ASGIApp</code>  <p>The 'next' ASGI app to call.</p>  required    <code>config</code>  <code>LoggingMiddlewareConfig</code>  <p>An instance of LoggingMiddlewareConfig.</p>  required"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddleware.create_send_wrapper","title":"create_send_wrapper","text":"<pre><code>create_send_wrapper(scope, send)\n</code></pre>  <p>Create a <code>send</code> wrapper, which handles logging response data.</p> <p>Parameters:</p>    Name Type Description Default     <code>scope</code>  <code>Scope</code>  <p>The ASGI connection scope.</p>  required    <code>send</code>  <code>Send</code>  <p>The ASGI send function.</p>  required     <p>Returns:</p>    Type Description      <code>Send</code>  <p>An ASGI send function.</p>"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddleware.extract_request_data","title":"extract_request_data  <code>async</code>","text":"<pre><code>extract_request_data(request)\n</code></pre>  <p>Create a dictionary of values for the message.</p> <p>Parameters:</p>    Name Type Description Default     <code>request</code>  <code>Request</code>  <p>A Request instance.</p>  required     <p>Returns:</p>    Type Description      <code>Dict[str, Any]</code>  <p>An dict.</p>"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddleware.extract_response_data","title":"extract_response_data","text":"<pre><code>extract_response_data(scope)\n</code></pre>  <p>Extract data from the response.</p> <p>Parameters:</p>    Name Type Description Default     <code>scope</code>  <code>Scope</code>  <p>The ASGI connection scope.</p>  required     <p>Returns:</p>    Type Description      <code>Dict[str, Any]</code>  <p>An dict.</p>"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddleware.log_message","title":"log_message","text":"<pre><code>log_message(values)\n</code></pre>  <p>Log a message.</p> <p>Parameters:</p>    Name Type Description Default     <code>values</code>  <code>Dict[str, Any]</code>  <p>Extract values to log.</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddleware.log_request","title":"log_request  <code>async</code>","text":"<pre><code>log_request(scope, receive)\n</code></pre>  <p>Extract request data and log the message.</p> <p>Parameters:</p>    Name Type Description Default     <code>scope</code>  <code>Scope</code>  <p>The ASGI connection scope.</p>  required    <code>receive</code>  <code>Receive</code>  <p>ASGI receive callable</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddleware.log_response","title":"log_response","text":"<pre><code>log_response(scope)\n</code></pre>  <p>Extract the response data and log the message.</p> <p>Parameters:</p>    Name Type Description Default     <code>scope</code>  <code>Scope</code>  <p>The ASGI connection scope.</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/3-rate-limit-middleware/","title":"Rate-Limit Middleware","text":""},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig","title":"starlite.middleware.rate_limit.RateLimitConfig","text":"<p>         Bases: <code>BaseModel</code></p> <p>Configuration for <code>RateLimitMiddleware</code></p>"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.cache_key_builder","title":"cache_key_builder  <code>class-attribute</code>","text":"<pre><code>cache_key_builder: Optional[Callable[[Request], str]] = None\n</code></pre>"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.check_throttle_handler","title":"check_throttle_handler  <code>class-attribute</code>","text":"<pre><code>check_throttle_handler: Optional[Callable[[Request[Any, Any]], SyncOrAsyncUnion[bool]]] = None\n</code></pre>  <p>Handler callable that receives the request instance, returning a boolean dictating whether or not the request should be checked for rate limiting.</p>"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.exclude","title":"exclude  <code>class-attribute</code>","text":"<pre><code>exclude: Optional[Union[str, List[str]]] = None\n</code></pre>  <p>A pattern or list of patterns to skip in the rate limiting middleware.</p>"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.exclude_opt_key","title":"exclude_opt_key  <code>class-attribute</code>","text":"<pre><code>exclude_opt_key: Optional[str] = None\n</code></pre>  <p>An identifier to use on routes to disable rate limiting for a particular route.</p>"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.middleware","title":"middleware  <code>property</code>","text":"<pre><code>middleware: DefineMiddleware\n</code></pre>  <p>Use this property to insert the config into a middleware list on one of the application layers.</p> <p>Examples:</p> <pre><code>from starlite import Starlite, Request, get\nfrom starlite.middleware import RateLimitConfig\n\n# limit to 10 requests per minute, excluding the schema path\nthrottle_config = RateLimitConfig(rate_limit=(\"minute\", 10), exclude=[\"/schema\"])\n\n\n@get(\"/\")\ndef my_handler(request: Request) -&gt; None:\n    ...\n\n\napp = Starlite(route_handlers=[my_handler], middleware=[throttle_config.middleware])\n</code></pre> <p>Returns:</p>    Type Description      <code>DefineMiddleware</code>  <p>An instance of DefineMiddleware including 'self' as the config kwarg value.</p>"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.middleware_class","title":"middleware_class  <code>class-attribute</code>","text":"<pre><code>middleware_class: Type[RateLimitMiddleware] = RateLimitMiddleware\n</code></pre>  <p>The middleware class to use.</p>"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.rate_limit","title":"rate_limit  <code>class-attribute</code>","text":"<pre><code>rate_limit: Tuple[DurationUnit, int]\n</code></pre>  <p>A tuple containing a time unit (second, minute, hour, day) and quantity, e.g. (\"day\", 1) or (\"minute\", 5).</p>"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.rate_limit_limit_header_key","title":"rate_limit_limit_header_key  <code>class-attribute</code>","text":"<pre><code>rate_limit_limit_header_key: str = 'RateLimit-Limit'\n</code></pre>  <p>Key to use for the rate limit limit header.</p>"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.rate_limit_policy_header_key","title":"rate_limit_policy_header_key  <code>class-attribute</code>","text":"<pre><code>rate_limit_policy_header_key: str = 'RateLimit-Policy'\n</code></pre>  <p>Key to use for the rate limit policy header.</p>"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.rate_limit_remaining_header_key","title":"rate_limit_remaining_header_key  <code>class-attribute</code>","text":"<pre><code>rate_limit_remaining_header_key: str = 'RateLimit-Remaining'\n</code></pre>  <p>Key to use for the rate limit remaining header.</p>"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.rate_limit_reset_header_key","title":"rate_limit_reset_header_key  <code>class-attribute</code>","text":"<pre><code>rate_limit_reset_header_key: str = 'RateLimit-Reset'\n</code></pre>  <p>Key to use for the rate limit reset header.</p>"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.set_rate_limit_headers","title":"set_rate_limit_headers  <code>class-attribute</code>","text":"<pre><code>set_rate_limit_headers: bool = True\n</code></pre>  <p>Boolean dictating whether to set the rate limit headers on the response.</p>"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitMiddleware","title":"starlite.middleware.rate_limit.RateLimitMiddleware","text":"<p>         Bases: <code>AbstractMiddleware</code></p> <p>Rate-limiting middleware.</p>"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitMiddleware.__init__","title":"__init__","text":"<pre><code>__init__(app, config)\n</code></pre>  <p>Initialize <code>RateLimitMiddleware</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>app</code>  <code>ASGIApp</code>  <p>The 'next' ASGI app to call.</p>  required    <code>config</code>  <code>RateLimitConfig</code>  <p>An instance of RateLimitConfig.</p>  required"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitMiddleware.cache_key_from_request","title":"cache_key_from_request","text":"<pre><code>cache_key_from_request(request)\n</code></pre>  <p>Get a cache-key from a <code>Request</code></p> <p>Parameters:</p>    Name Type Description Default     <code>request</code>  <code>Request[Any, Any]</code>  <p>A Request instance.</p>  required     <p>Returns:</p>    Type Description      <code>str</code>  <p>A cache key.</p>"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitMiddleware.create_response_headers","title":"create_response_headers","text":"<pre><code>create_response_headers(cache_object)\n</code></pre>  <p>Create ratelimit response headers.</p>  Notes <ul> <li>see the [IETF RateLimit draft][https://datatracker.ietf.org/doc/draft-ietf-httpapi-ratelimit-headers/]</li> </ul>  <p>Parameters:</p>    Name Type Description Default     <code>cache_object</code>  <code>CacheObject</code>  <p>An instance of Cache Object.</p>  required     <p>Returns:</p>    Type Description      <code>Dict[str, str]</code>  <p>A dict of http headers.</p>"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitMiddleware.retrieve_cached_history","title":"retrieve_cached_history  <code>async</code>","text":"<pre><code>retrieve_cached_history(key)\n</code></pre>  <p>Retrieve a list of time stamps for the given duration unit.</p> <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>str</code>  <p>Cache key.</p>  required     <p>Returns:</p>    Type Description      <code>CacheObject</code>  <p>An instance of CacheObject.</p>"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitMiddleware.set_cached_history","title":"set_cached_history  <code>async</code>","text":"<pre><code>set_cached_history(key, cache_object)\n</code></pre>  <p>Store history extended with the current timestamp in cache.</p> <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>str</code>  <p>Cache key.</p>  required    <code>cache_object</code>  <code>CacheObject</code>  <p>An instance of CacheObject.</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitMiddleware.should_check_request","title":"should_check_request  <code>async</code>","text":"<pre><code>should_check_request(request)\n</code></pre>  <p>Return a boolean indicating if a request should be checked for rate limiting.</p> <p>Parameters:</p>    Name Type Description Default     <code>request</code>  <code>Request[Any, Any]</code>  <p>A Request instance.</p>  required     <p>Returns:</p>    Type Description      <code>bool</code>  <p>Boolean dictating whether the request should be checked for rate-limiting.</p>"},{"location":"reference/middleware/4-compression-middleware/","title":"Compression Middleware","text":""},{"location":"reference/middleware/4-compression-middleware/#starlite.middleware.CompressionMiddleware","title":"starlite.middleware.CompressionMiddleware","text":"<p>         Bases: <code>AbstractMiddleware</code></p> <p>Compression Middleware Wrapper.</p> <p>This is a wrapper allowing for generic compression configuration / handler middleware</p>"},{"location":"reference/middleware/4-compression-middleware/#starlite.middleware.compression.CompressionMiddleware.__init__","title":"__init__","text":"<pre><code>__init__(app, config)\n</code></pre>  <p>Initialize <code>CompressionMiddleware</code></p> <p>Parameters:</p>    Name Type Description Default     <code>app</code>  <code>ASGIApp</code>  <p>The 'next' ASGI app to call.</p>  required    <code>config</code>  <code>CompressionConfig</code>  <p>An instance of CompressionConfig.</p>  required"},{"location":"reference/middleware/5-csrf-middleware/","title":"CSRF Middleware","text":""},{"location":"reference/middleware/5-csrf-middleware/#starlite.middleware.CSRFMiddleware","title":"starlite.middleware.CSRFMiddleware","text":"<p>         Bases: <code>MiddlewareProtocol</code></p> <p>CSRF Middleware class.</p> <p>This Middleware protects against attacks by setting a CSRF cookie with a token and verifying it in request headers.</p>"},{"location":"reference/middleware/5-csrf-middleware/#starlite.middleware.csrf.CSRFMiddleware.__init__","title":"__init__","text":"<pre><code>__init__(app, config)\n</code></pre>  <p>Initialize <code>CSRFMiddleware</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>app</code>  <code>ASGIApp</code>  <p>The 'next' ASGI app to call.</p>  required    <code>config</code>  <code>CSRFConfig</code>  <p>The CSRFConfig instance.</p>  required"},{"location":"reference/middleware/6-exceptions-middleware/","title":"Exceptions Middleware","text":""},{"location":"reference/middleware/6-exceptions-middleware/#starlite.middleware.ExceptionHandlerMiddleware","title":"starlite.middleware.ExceptionHandlerMiddleware","text":"<p>Middleware used to wrap an ASGIApp inside a try catch block and handle any exceptions raised.</p> <p>This used in multiple layers of Starlite.</p>"},{"location":"reference/middleware/6-exceptions-middleware/#starlite.middleware.exceptions.middleware.ExceptionHandlerMiddleware.__init__","title":"__init__","text":"<pre><code>__init__(app, debug, exception_handlers)\n</code></pre>  <p>Initialize <code>ExceptionHandlerMiddleware</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>app</code>  <code>ASGIApp</code>  <p>The 'next' ASGI app to call.</p>  required    <code>debug</code>  <code>bool</code>  <p>Whether 'debug' mode is enabled</p>  required    <code>exception_handlers</code>  <code>ExceptionHandlersMap</code>  <p>A dictionary mapping status codes and/or exception types to handler functions.</p>  required"},{"location":"reference/middleware/6-exceptions-middleware/#starlite.middleware.exceptions.middleware.ExceptionHandlerMiddleware.default_http_exception_handler","title":"default_http_exception_handler","text":"<pre><code>default_http_exception_handler(request, exc)\n</code></pre>  <p>Handle <code>HTTPException</code>s and its subclasses.</p>"},{"location":"reference/middleware/7-cors-middleware/","title":"CORS Middleware","text":""},{"location":"reference/middleware/7-cors-middleware/#starlite.middleware.cors.CORSMiddleware","title":"starlite.middleware.cors.CORSMiddleware","text":"<p>         Bases: <code>AbstractMiddleware</code></p> <p>CORS Middleware.</p>"},{"location":"reference/middleware/7-cors-middleware/#starlite.middleware.cors.CORSMiddleware.__init__","title":"__init__","text":"<pre><code>__init__(app, config)\n</code></pre>  <p>Middleware that adds CORS validation to the application.</p> <p>Parameters:</p>    Name Type Description Default     <code>app</code>  <code>ASGIApp</code>  <p>The 'next' ASGI app to call.</p>  required    <code>config</code>  <code>CORSConfig</code>  <p>An instance of CORSConfig</p>  required"},{"location":"reference/middleware/session-middleware/0-middleware/","title":"Middleware","text":""},{"location":"reference/middleware/session-middleware/0-middleware/#starlite.middleware.session.SessionMiddleware","title":"starlite.middleware.session.SessionMiddleware","text":"<p>         Bases: <code>AbstractMiddleware</code>, <code>Generic[BaseSessionBackendT]</code></p> <p>Starlite session middleware for storing session data.</p>"},{"location":"reference/middleware/session-middleware/0-middleware/#starlite.middleware.session.base.SessionMiddleware.__init__","title":"__init__","text":"<pre><code>__init__(app, backend)\n</code></pre>  <p>Initialize <code>SessionMiddleware</code></p> <p>Parameters:</p>    Name Type Description Default     <code>app</code>  <code>ASGIApp</code>  <p>An ASGI application</p>  required    <code>backend</code>  <code>BaseSessionBackendT</code>  <p>A BaseSessionBackend instance used to store and retrieve session data</p>  required"},{"location":"reference/middleware/session-middleware/1-base-backend/","title":"Base backend","text":""},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseBackendConfig","title":"starlite.middleware.session.base.BaseBackendConfig","text":"<p>         Bases: <code>BaseModel</code></p> <p>Configuration for Session middleware backends.</p>"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseBackendConfig.key","title":"key  <code>class-attribute</code>","text":"<pre><code>key: constr(min_length=1, max_length=256) = 'session'\n</code></pre>  <p>Key to use for the cookie inside the header, e.g. <code>session=&lt;data&gt;</code> where 'session' is the cookie key and  is the session data.  Notes <ul> <li>If a session cookie exceeds 4KB in size it is split. In this case the key will be of the format     'session-{segment number}'.</li> </ul>"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseBackendConfig.max_age","title":"max_age  <code>class-attribute</code>","text":"<pre><code>max_age: conint(ge=1) = ONE_DAY_IN_SECONDS * 14\n</code></pre>  <p>Maximal age of the cookie before its invalidated.</p>"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseBackendConfig.scopes","title":"scopes  <code>class-attribute</code>","text":"<pre><code>scopes: Scopes = {ScopeType.HTTP, ScopeType.WEBSOCKET}\n</code></pre>  <p>Scopes for the middleware - options are 'http' and 'websocket' with the default being both</p>"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseBackendConfig.path","title":"path  <code>class-attribute</code>","text":"<pre><code>path: str = '/'\n</code></pre>  <p>Path fragment that must exist in the request url for the cookie to be valid.</p> <p>Defaults to '/'.</p>"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseBackendConfig.domain","title":"domain  <code>class-attribute</code>","text":"<pre><code>domain: Optional[str] = None\n</code></pre>  <p>Domain for which the cookie is valid.</p>"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseBackendConfig.secure","title":"secure  <code>class-attribute</code>","text":"<pre><code>secure: bool = False\n</code></pre>  <p>Https is required for the cookie.</p>"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseBackendConfig.httponly","title":"httponly  <code>class-attribute</code>","text":"<pre><code>httponly: bool = True\n</code></pre>  <p>Forbids javascript to access the cookie via 'Document.cookie'.</p>"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseBackendConfig.samesite","title":"samesite  <code>class-attribute</code>","text":"<pre><code>samesite: Literal['lax', 'strict', 'none'] = 'lax'\n</code></pre>  <p>Controls whether or not a cookie is sent with cross-site requests.</p> <p>Defaults to 'lax'.</p>"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseBackendConfig.middleware","title":"middleware  <code>property</code>","text":"<pre><code>middleware: DefineMiddleware\n</code></pre>  <p>Use this property to insert the config into a middleware list on one of the application layers.</p> <p>Examples:</p> <pre><code>from os import urandom\n\nfrom starlite import Starlite, Request, get\nfrom starlite.middleware.session import SessionCookieConfig\n\nsession_config = SessionCookieConfig(secret=urandom(16))\n\n\n@get(\"/\")\ndef my_handler(request: Request) -&gt; None:\n    ...\n\n\napp = Starlite(route_handlers=[my_handler], middleware=[session_config.middleware])\n</code></pre> <p>Returns:</p>    Type Description      <code>DefineMiddleware</code>  <p>An instance of DefineMiddleware including 'self' as the config kwarg value.</p>"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.ServerSideSessionConfig","title":"starlite.middleware.session.base.ServerSideSessionConfig","text":"<p>         Bases: <code>BaseBackendConfig</code></p> <p>Base configuration for server side backends.</p>"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.ServerSideSessionConfig.session_id_bytes","title":"session_id_bytes  <code>class-attribute</code>","text":"<pre><code>session_id_bytes: int = 32\n</code></pre>  <p>Number of bytes used to generate a random session-ID.</p>"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseSessionBackend","title":"starlite.middleware.session.base.BaseSessionBackend","text":"<p>         Bases: <code>ABC</code>, <code>Generic[ConfigT]</code></p> <p>Abstract session backend defining the interface between a storage mechanism and the application.</p> <p>SessionMiddleware.</p> <p>This serves as the base class for all client- and server-side backends</p>"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseSessionBackend.__init__","title":"__init__","text":"<pre><code>__init__(config)\n</code></pre>  <p>Initialize <code>BaseSessionBackend</code></p> <p>Parameters:</p>    Name Type Description Default     <code>config</code>  <code>ConfigT</code>  <p>A instance of a subclass of <code>BaseBackendConfig</code></p>  required"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseSessionBackend.deserialize_data","title":"deserialize_data  <code>staticmethod</code>","text":"<pre><code>deserialize_data(data)\n</code></pre>  <p>Deserialize data into a dictionary for use in the application scope.</p> <p>Parameters:</p>    Name Type Description Default     <code>data</code>  <code>Any</code>  <p>Data to be deserialized</p>  required     <p>Returns:</p>    Type Description      <code>Dict[str, Any]</code>  <p>Deserialized data as a dictionary</p>"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseSessionBackend.store_in_message","title":"store_in_message  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>store_in_message(scope_session, message, connection)\n</code></pre>  <p>Store the necessary information in the outgoing <code>Message</code></p> <p>Parameters:</p>    Name Type Description Default     <code>scope_session</code>  <code>ScopeSession</code>  <p>Current session to store</p>  required    <code>message</code>  <code>Message</code>  <p>Outgoing send-message</p>  required    <code>connection</code>  <code>ASGIConnection</code>  <p>Originating ASGIConnection containing the scope</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseSessionBackend.load_from_connection","title":"load_from_connection  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>load_from_connection(connection)\n</code></pre>  <p>Load session data from a connection and return it as a dictionary to be used in the current application scope.</p> <p>Parameters:</p>    Name Type Description Default     <code>connection</code>  <code>ASGIConnection</code>  <p>An ASGIConnection instance</p>  required     <p>Returns:</p>    Type Description      <code>Dict[str, Any]</code>  <p>The session data</p>     Notes <ul> <li>This should not modify the connection's scope. The data returned by this method will be stored in the application scope by the middleware</li> </ul>"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.ServerSideBackend","title":"starlite.middleware.session.base.ServerSideBackend","text":"<p>         Bases: <code>Generic[ServerConfigT]</code>, <code>BaseSessionBackend[ServerConfigT]</code></p> <p>Base class for server-side backends.</p> <p>Implements BaseSessionBackend and defines and interface which subclasses can implement to facilitate the storage of session data</p>"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.ServerSideBackend.__init__","title":"__init__","text":"<pre><code>__init__(config)\n</code></pre>  <p>Initialize <code>ServerSideBackend</code></p> <p>Parameters:</p>    Name Type Description Default     <code>config</code>  <code>ServerConfigT</code>  <p>A subclass of <code>ServerSideSessionConfig</code></p>  required"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.ServerSideBackend.store_in_message","title":"store_in_message  <code>async</code>","text":"<pre><code>store_in_message(scope_session, message, connection)\n</code></pre>  <p>Store the necessary information in the outgoing <code>Message</code> by setting a cookie containing the session-ID.</p> <p>If the session is empty, a null-cookie will be set. Otherwise, the serialised data will be stored using set, under the current session-id. If no session-ID exists, a new ID will be generated using generate_session_id.</p> <p>Parameters:</p>    Name Type Description Default     <code>scope_session</code>  <code>ScopeSession</code>  <p>Current session to store</p>  required    <code>message</code>  <code>Message</code>  <p>Outgoing send-message</p>  required    <code>connection</code>  <code>ASGIConnection</code>  <p>Originating ASGIConnection containing the scope</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.ServerSideBackend.load_from_connection","title":"load_from_connection  <code>async</code>","text":"<pre><code>load_from_connection(connection)\n</code></pre>  <p>Load session data from a connection and return it as a dictionary to be used in the current application scope.</p> <p>The session-ID will be gathered from a cookie with the key set in the configuration. If a cookie is found, its value will be used as the session-ID and data associated with this ID will be loaded using get. If no cookie was found or no data was loaded from the store, this will return an empty dictionary.</p> <p>Parameters:</p>    Name Type Description Default     <code>connection</code>  <code>ASGIConnection</code>  <p>An ASGIConnection instance</p>  required     <p>Returns:</p>    Type Description      <code>Dict[str, Any]</code>  <p>The current session data</p>"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.ServerSideBackend.get","title":"get  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get(session_id)\n</code></pre>  <p>Retrieve data associated with <code>session_id</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>session_id</code>  <code>str</code>  <p>The session-ID</p>  required     <p>Returns:</p>    Type Description      <code>Union[bytes, str, Dict[str, Any], None]</code>  <p>The session data, if existing, otherwise <code>None</code>.</p>"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.ServerSideBackend.set","title":"set  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>set(session_id, data)\n</code></pre>  <p>Store <code>data</code> under the <code>session_id</code> for later retrieval.</p> <p>If there is already data associated with <code>session_id</code>, replace it with <code>data</code> and reset its expiry time</p> <p>Parameters:</p>    Name Type Description Default     <code>session_id</code>  <code>str</code>  <p>The session-ID</p>  required    <code>data</code>  <code>bytes</code>  <p>Serialized session data</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.ServerSideBackend.delete","title":"delete  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>delete(session_id)\n</code></pre>  <p>Delete the data associated with <code>session_id</code>. Fails silently if no such session-ID exists.</p> <p>Parameters:</p>    Name Type Description Default     <code>session_id</code>  <code>str</code>  <p>The session-ID</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.ServerSideBackend.delete_all","title":"delete_all  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>delete_all()\n</code></pre>  <p>Delete all session data stored within this backend.</p> <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.ServerSideBackend.generate_session_id","title":"generate_session_id","text":"<pre><code>generate_session_id()\n</code></pre>  <p>Generate a new session-ID, with n=[session_id_bytes][starlite.middle ware.session.base.ServerSideSessionConfig.session_id_bytes] random bytes.</p> <p>Returns:</p>    Type Description      <code>str</code>  <p>A session-ID</p>"},{"location":"reference/middleware/session-middleware/2-cookie-backend/","title":"Cookie Backend","text":""},{"location":"reference/middleware/session-middleware/2-cookie-backend/#starlite.middleware.session.cookie_backend.CookieBackendConfig","title":"starlite.middleware.session.cookie_backend.CookieBackendConfig","text":"<p>         Bases: <code>BaseBackendConfig</code></p> <p>Configuration for [SessionMiddleware] middleware.</p>"},{"location":"reference/middleware/session-middleware/2-cookie-backend/#starlite.middleware.session.cookie_backend.CookieBackendConfig.secret","title":"secret  <code>class-attribute</code>","text":"<pre><code>secret: SecretBytes\n</code></pre>  <p>A secret key to use for generating an encryption key.</p> <p>Must have a length of 16 (128 bits), 24 (192 bits) or 32 (256 bits) characters.</p>"},{"location":"reference/middleware/session-middleware/2-cookie-backend/#starlite.middleware.session.cookie_backend.CookieBackend","title":"starlite.middleware.session.cookie_backend.CookieBackend","text":"<p>         Bases: <code>BaseSessionBackend[CookieBackendConfig]</code></p> <p>Cookie backend for SessionMiddleware.</p>"},{"location":"reference/middleware/session-middleware/2-cookie-backend/#starlite.middleware.session.cookie_backend.CookieBackend.__init__","title":"__init__","text":"<pre><code>__init__(config)\n</code></pre>  <p>Initialize <code>CookieBackend</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>config</code>  <code>CookieBackendConfig</code>  <p>SessionCookieConfig instance.</p>  required"},{"location":"reference/middleware/session-middleware/2-cookie-backend/#starlite.middleware.session.cookie_backend.CookieBackend.dump_data","title":"dump_data","text":"<pre><code>dump_data(data, scope=None)\n</code></pre>  <p>Given serializable data, including pydantic models and numpy types, dump it into a bytes string, encrypt, encode and split it into chunks of the desirable size.</p> <p>Parameters:</p>    Name Type Description Default     <code>data</code>  <code>Any</code>  <p>Data to serialize, encrypt, encode and chunk.</p>  required    <code>scope</code>  <code>Optional[Scope]</code>  <p>The ASGI connection scope.</p>  <code>None</code>      Notes <ul> <li>The returned list is composed of a chunks of a single base64 encoded string that is encrypted using AES-CGM.</li> </ul>  <p>Returns:</p>    Type Description      <code>List[bytes]</code>  <p>List of encoded bytes string of a maximum length equal to the 'CHUNK_SIZE' constant.</p>"},{"location":"reference/middleware/session-middleware/2-cookie-backend/#starlite.middleware.session.cookie_backend.CookieBackend.load_data","title":"load_data","text":"<pre><code>load_data(data)\n</code></pre>  <p>Given a list of strings, decodes them into the session object.</p> <p>Parameters:</p>    Name Type Description Default     <code>data</code>  <code>List[bytes]</code>  <p>A list of strings derived from the request's session cookie(s).</p>  required     <p>Returns:</p>    Type Description      <code>Dict[str, Any]</code>  <p>A deserialized session value.</p>"},{"location":"reference/middleware/session-middleware/2-cookie-backend/#starlite.middleware.session.cookie_backend.CookieBackend.get_cookie_keys","title":"get_cookie_keys","text":"<pre><code>get_cookie_keys(connection)\n</code></pre>  <p>Return a list of cookie-keys from the connection if they match the session-cookie pattern.</p> <p>Parameters:</p>    Name Type Description Default     <code>connection</code>  <code>ASGIConnection</code>  <p>An ASGIConnection instance</p>  required     <p>Returns:</p>    Type Description      <code>List[str]</code>  <p>A list of session-cookie keys</p>"},{"location":"reference/middleware/session-middleware/2-cookie-backend/#starlite.middleware.session.cookie_backend.CookieBackend.store_in_message","title":"store_in_message  <code>async</code>","text":"<pre><code>store_in_message(scope_session, message, connection)\n</code></pre>  <p>Store data from <code>scope_session</code> in <code>Message</code> in the form of cookies. If the contents of <code>scope_session</code> are too large to fit a single cookie, it will be split across several cookies, following the naming scheme of <code>&lt;cookie key&gt;-&lt;n&gt;</code>. If the session is empty or shrinks, cookies will be cleared by setting their value to <code>null</code></p> <p>Parameters:</p>    Name Type Description Default     <code>scope_session</code>  <code>ScopeSession</code>  <p>Current session to store</p>  required    <code>message</code>  <code>Message</code>  <p>Outgoing send-message</p>  required    <code>connection</code>  <code>ASGIConnection</code>  <p>Originating ASGIConnection containing the scope</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/session-middleware/2-cookie-backend/#starlite.middleware.session.cookie_backend.CookieBackend.load_from_connection","title":"load_from_connection  <code>async</code>","text":"<pre><code>load_from_connection(connection)\n</code></pre>  <p>Load session data from a connection's session-cookies and return it as a dictionary.</p> <p>Parameters:</p>    Name Type Description Default     <code>connection</code>  <code>ASGIConnection</code>  <p>Originating ASGIConnection</p>  required     <p>Returns:</p>    Type Description      <code>Dict[str, Any]</code>  <p>The session data</p>"},{"location":"reference/middleware/session-middleware/3-file-backend/","title":"File backend","text":""},{"location":"reference/middleware/session-middleware/3-file-backend/#starlite.middleware.session.file_backend.FileBackendConfig","title":"starlite.middleware.session.file_backend.FileBackendConfig","text":"<p>         Bases: <code>ServerSideSessionConfig</code></p> <p>Backend configuration for <code>FileBackend</code></p>"},{"location":"reference/middleware/session-middleware/3-file-backend/#starlite.middleware.session.file_backend.FileBackendConfig.storage_path","title":"storage_path  <code>class-attribute</code>","text":"<pre><code>storage_path: PathLike\n</code></pre>  <p>Disk path under which to store session files.</p>"},{"location":"reference/middleware/session-middleware/3-file-backend/#starlite.middleware.session.file_backend.FileBackendConfig.make_filename","title":"make_filename  <code>class-attribute</code>","text":"<pre><code>make_filename: Optional[Callable[[str], str]] = None\n</code></pre>  <p>Callable that turns a session-ID into a filename used for storage.</p> <p>By default, the session-ID will be used as a filename</p>"},{"location":"reference/middleware/session-middleware/3-file-backend/#starlite.middleware.session.file_backend.FileBackend","title":"starlite.middleware.session.file_backend.FileBackend","text":"<p>         Bases: <code>ServerSideBackend[FileBackendConfig]</code></p> <p>Session backend to store data in files.</p>"},{"location":"reference/middleware/session-middleware/3-file-backend/#starlite.middleware.session.file_backend.FileBackend.__init__","title":"__init__","text":"<pre><code>__init__(config)\n</code></pre>  <p>Initialize <code>FileBackend</code></p> <p>Parameters:</p>    Name Type Description Default     <code>config</code>  <code>FileBackendConfig</code>  <p>A <code>FileBackendConfig</code></p>  required"},{"location":"reference/middleware/session-middleware/3-file-backend/#starlite.middleware.session.file_backend.FileBackend.get","title":"get  <code>async</code>","text":"<pre><code>get(session_id)\n</code></pre>  <p>Load data associated with <code>session_id</code> from a file.</p> <p>Parameters:</p>    Name Type Description Default     <code>session_id</code>  <code>str</code>  <p>The session-ID</p>  required     <p>Returns:</p>    Type Description      <code>Optional[bytes]</code>  <p>The session data, if existing, otherwise <code>None</code>.</p>"},{"location":"reference/middleware/session-middleware/3-file-backend/#starlite.middleware.session.file_backend.FileBackend.set","title":"set  <code>async</code>","text":"<pre><code>set(session_id, data)\n</code></pre>  <p>Store <code>data</code> alongside metadata under the <code>session_id</code>, using the ID as a filename. If a file already exists for <code>session_id</code>, replace it with <code>data</code> and reset its expiry time.</p> <p>Parameters:</p>    Name Type Description Default     <code>session_id</code>  <code>str</code>  <p>The session-ID</p>  required    <code>data</code>  <code>bytes</code>  <p>Serialized session data</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/session-middleware/3-file-backend/#starlite.middleware.session.file_backend.FileBackend.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(session_id)\n</code></pre>  <p>Delete the file associated with <code>session_id</code>.</p> <p>Fails silently if no such file exists</p> <p>Parameters:</p>    Name Type Description Default     <code>session_id</code>  <code>str</code>  <p>The session-ID</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/session-middleware/3-file-backend/#starlite.middleware.session.file_backend.FileBackend.delete_all","title":"delete_all  <code>async</code>","text":"<pre><code>delete_all()\n</code></pre>  <p>Delete all files in the storage path.</p> <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/session-middleware/3-file-backend/#starlite.middleware.session.file_backend.FileBackend.delete_expired","title":"delete_expired  <code>async</code>","text":"<pre><code>delete_expired()\n</code></pre>  <p>Delete expired session files.</p>  Return <p>None</p>"},{"location":"reference/middleware/session-middleware/4-memcached-backend/","title":"Memcached backend","text":""},{"location":"reference/middleware/session-middleware/4-memcached-backend/#starlite.middleware.session.memcached_backend.MemcachedBackendConfig","title":"starlite.middleware.session.memcached_backend.MemcachedBackendConfig","text":"<p>         Bases: <code>ServerSideSessionConfig</code></p> <p>Configuration for <code>MemcachedBackend</code></p>"},{"location":"reference/middleware/session-middleware/4-memcached-backend/#starlite.middleware.session.memcached_backend.MemcachedBackendConfig.memcached","title":"memcached  <code>class-attribute</code>","text":"<pre><code>memcached: MemcacheClient\n</code></pre>  <p>An <code>aiomcache.Client</code> instance.</p>"},{"location":"reference/middleware/session-middleware/4-memcached-backend/#starlite.middleware.session.memcached_backend.MemcachedBackend","title":"starlite.middleware.session.memcached_backend.MemcachedBackend","text":"<p>         Bases: <code>ServerSideBackend[MemcachedBackendConfig]</code></p> <p>Session backend to store data in memcached.</p>"},{"location":"reference/middleware/session-middleware/4-memcached-backend/#starlite.middleware.session.memcached_backend.MemcachedBackend.__init__","title":"__init__","text":"<pre><code>__init__(config)\n</code></pre>  <p>Initialize <code>MemcachedBackend</code></p> <p>Parameters:</p>    Name Type Description Default     <code>config</code>  <code>MemcachedBackendConfig</code>  <p>A <code>MemcachedBackendConfig</code> instance</p>  required      Notes <ul> <li>Requires <code>aiomcache</code>. Install with <code>pip install starlite[memcached]</code></li> </ul>"},{"location":"reference/middleware/session-middleware/4-memcached-backend/#starlite.middleware.session.memcached_backend.MemcachedBackend.get","title":"get  <code>async</code>","text":"<pre><code>get(session_id)\n</code></pre>  <p>Retrieve data associated with <code>session_id</code> from memcached.</p> <p>Parameters:</p>    Name Type Description Default     <code>session_id</code>  <code>str</code>  <p>The session-ID</p>  required     <p>Returns:</p>    Type Description      <code>Optional[bytes]</code>  <p>The session data, if existing, otherwise <code>None</code>.</p>"},{"location":"reference/middleware/session-middleware/4-memcached-backend/#starlite.middleware.session.memcached_backend.MemcachedBackend.set","title":"set  <code>async</code>","text":"<pre><code>set(session_id, data)\n</code></pre>  <p>Store <code>data</code> in memcached under <code>&lt;prefix&gt;:&lt;session_id&gt;</code>. If there is already data associated with <code>session_id</code>, replace it with <code>data</code> and reset its expiry time.</p> <p>Parameters:</p>    Name Type Description Default     <code>session_id</code>  <code>str</code>  <p>The session-ID</p>  required    <code>data</code>  <code>bytes</code>  <p>Serialized session data</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/session-middleware/4-memcached-backend/#starlite.middleware.session.memcached_backend.MemcachedBackend.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(session_id)\n</code></pre>  <p>Delete the data associated with <code>session_id</code>. Fail silently if no such session-ID exists.</p> <p>Parameters:</p>    Name Type Description Default     <code>session_id</code>  <code>str</code>  <p>The session-ID</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/session-middleware/4-memcached-backend/#starlite.middleware.session.memcached_backend.MemcachedBackend.delete_all","title":"delete_all  <code>async</code>","text":"<pre><code>delete_all()\n</code></pre>  <p>Delete all data stored within this backend.</p> <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>     Notes <p>This has poor performance since memcached does not offer utilities to properly scan or match keys by prefix.</p>   <p>Deprecated since 1.43.0</p> <p>This method is deprecated since 1.43.0. If you need this functionality, consider using the redis backend instead.</p>"},{"location":"reference/middleware/session-middleware/5-memory-backend/","title":"Memory backend","text":""},{"location":"reference/middleware/session-middleware/5-memory-backend/#starlite.middleware.session.memory_backend.MemoryBackend","title":"starlite.middleware.session.memory_backend.MemoryBackend","text":"<p>         Bases: <code>ServerSideBackend[MemoryBackendConfig]</code></p> <p>Session backend to store data in memory.</p>"},{"location":"reference/middleware/session-middleware/5-memory-backend/#starlite.middleware.session.memory_backend.MemoryBackend.__init__","title":"__init__","text":"<pre><code>__init__(config)\n</code></pre>  <p>Initialize <code>MemoryBackend</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>config</code>  <code>MemoryBackendConfig</code>  <p>An instance of <code>MemoryBackendConfig</code></p>  required      Warning <p>This should not be used in production and serves mainly as a dummy backend for easy testing. It is not process-safe, and data won't be persisted</p>"},{"location":"reference/middleware/session-middleware/5-memory-backend/#starlite.middleware.session.memory_backend.MemoryBackend.get","title":"get  <code>async</code>","text":"<pre><code>get(session_id)\n</code></pre>  <p>Retrieve data associated with <code>session_id</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>session_id</code>  <code>str</code>  <p>The session-ID</p>  required     <p>Returns:</p>    Type Description      <code>Optional[bytes]</code>  <p>The session data, if existing, otherwise <code>None</code>.</p>"},{"location":"reference/middleware/session-middleware/5-memory-backend/#starlite.middleware.session.memory_backend.MemoryBackend.set","title":"set  <code>async</code>","text":"<pre><code>set(session_id, data)\n</code></pre>  <p>Store <code>data</code> under the <code>session_id</code> for later retrieval.</p> <p>If there is already data associated with <code>session_id</code>, replace it with <code>data</code> and reset its expiry time</p> <p>Parameters:</p>    Name Type Description Default     <code>session_id</code>  <code>str</code>  <p>The session-ID</p>  required    <code>data</code>  <code>bytes</code>  <p>Serialized session data</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/session-middleware/5-memory-backend/#starlite.middleware.session.memory_backend.MemoryBackend.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(session_id)\n</code></pre>  <p>Delete the data associated with <code>session_id</code>. Fails silently if no such session-ID exists.</p> <p>Parameters:</p>    Name Type Description Default     <code>session_id</code>  <code>str</code>  <p>The session-ID</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/session-middleware/5-memory-backend/#starlite.middleware.session.memory_backend.MemoryBackend.delete_all","title":"delete_all  <code>async</code>","text":"<pre><code>delete_all()\n</code></pre>  <p>Delete all session data.</p> <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/session-middleware/6-redis-backend/","title":"Redis backend","text":""},{"location":"reference/middleware/session-middleware/6-redis-backend/#starlite.middleware.session.redis_backend.RedisBackendConfig","title":"starlite.middleware.session.redis_backend.RedisBackendConfig","text":"<p>         Bases: <code>ServerSideSessionConfig</code></p> <p>Configuration for <code>RedisBackend</code></p>"},{"location":"reference/middleware/session-middleware/6-redis-backend/#starlite.middleware.session.redis_backend.RedisBackendConfig.redis","title":"redis  <code>class-attribute</code>","text":"<pre><code>redis: Redis\n</code></pre>  <p><code>redis.asyncio.Redis</code> instance.</p>"},{"location":"reference/middleware/session-middleware/6-redis-backend/#starlite.middleware.session.redis_backend.RedisBackend","title":"starlite.middleware.session.redis_backend.RedisBackend","text":"<p>         Bases: <code>ServerSideBackend[RedisBackendConfig]</code></p> <p>Session backend to store data in redis.</p>"},{"location":"reference/middleware/session-middleware/6-redis-backend/#starlite.middleware.session.redis_backend.RedisBackend.__init__","title":"__init__","text":"<pre><code>__init__(config)\n</code></pre>  <p>Initialize <code>RedisBackend</code>.</p>  Notes <ul> <li>Requires <code>redis</code>. Install with <code>pip install starlite[redis]</code></li> </ul>"},{"location":"reference/middleware/session-middleware/6-redis-backend/#starlite.middleware.session.redis_backend.RedisBackend.get","title":"get  <code>async</code>","text":"<pre><code>get(session_id)\n</code></pre>  <p>Load data associated with <code>session_id</code> from redis.</p> <p>Parameters:</p>    Name Type Description Default     <code>session_id</code>  <code>str</code>  <p>The session-ID</p>  required     <p>Returns:</p>    Type Description      <code>Union[bytes, str, None]</code>  <p>The session data, if existing, otherwise <code>None</code>.</p>"},{"location":"reference/middleware/session-middleware/6-redis-backend/#starlite.middleware.session.redis_backend.RedisBackend.set","title":"set  <code>async</code>","text":"<pre><code>set(session_id, data)\n</code></pre>  <p>Store <code>data</code> in redis under <code>&lt;prefix&gt;:&lt;session_id&gt;</code></p> <p>If there is already data associated with <code>session_id</code>, replace it with <code>data</code> and reset its expiry time</p> <p>Parameters:</p>    Name Type Description Default     <code>session_id</code>  <code>str</code>  <p>The session-ID</p>  required    <code>data</code>  <code>bytes</code>  <p>Serialized session data</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/session-middleware/6-redis-backend/#starlite.middleware.session.redis_backend.RedisBackend.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(session_id)\n</code></pre>  <p>Delete the data associated with <code>session_id</code> from redis. Fail silently if no such session-ID exists.</p> <p>Parameters:</p>    Name Type Description Default     <code>session_id</code>  <code>str</code>  <p>The session-ID</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/session-middleware/6-redis-backend/#starlite.middleware.session.redis_backend.RedisBackend.delete_all","title":"delete_all  <code>async</code>","text":"<pre><code>delete_all()\n</code></pre>  <p>Delete all session data stored in redis.</p> <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/","title":"SQLAlchemy backends","text":""},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SQLAlchemyBackendConfig","title":"starlite.middleware.session.sqlalchemy_backend.SQLAlchemyBackendConfig","text":"<p>         Bases: <code>ServerSideSessionConfig</code></p> <p>Configuration for <code>SQLAlchemyBackend</code> and <code>AsyncSQLAlchemyBackend</code></p>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SQLAlchemyBackendConfig.plugin","title":"plugin  <code>class-attribute</code>","text":"<pre><code>plugin: SQLAlchemyPlugin\n</code></pre>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.BaseSQLAlchemyBackend","title":"starlite.middleware.session.sqlalchemy_backend.BaseSQLAlchemyBackend","text":"<p>         Bases: <code>Generic[AnySASessionT]</code>, <code>ServerSideBackend[SQLAlchemyBackendConfig]</code>, <code>ABC</code></p> <p>Session backend to store data in a database with SQLAlchemy. Works with both sync and async engines.</p>  Notes <ul> <li>Requires <code>sqlalchemy</code> which needs to be installed separately, and a configured SQLAlchemyPlugin.</li> </ul>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.BaseSQLAlchemyBackend.__init__","title":"__init__","text":"<pre><code>__init__(config)\n</code></pre>  <p>Initialize <code>BaseSQLAlchemyBackend</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>config</code>  <code>SQLAlchemyBackendConfig</code>  <p>An instance of <code>SQLAlchemyBackendConfig</code></p>  required"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.BaseSQLAlchemyBackend.delete_expired","title":"delete_expired  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>delete_expired()\n</code></pre>  <p>Delete all expired sessions from the database.</p>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SQLAlchemyBackend","title":"starlite.middleware.session.sqlalchemy_backend.SQLAlchemyBackend","text":"<p>         Bases: <code>BaseSQLAlchemyBackend[SASession]</code></p> <p>Synchronous SQLAlchemy backend.</p>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SQLAlchemyBackend.get","title":"get  <code>async</code>","text":"<pre><code>get(session_id)\n</code></pre>  <p>Retrieve data associated with <code>session_id</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>session_id</code>  <code>str</code>  <p>The session-ID</p>  required     <p>Returns:</p>    Type Description      <code>Optional[bytes]</code>  <p>The session data, if existing, otherwise <code>None</code>.</p>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SQLAlchemyBackend.set","title":"set  <code>async</code>","text":"<pre><code>set(session_id, data)\n</code></pre>  <p>Store <code>data</code> under the <code>session_id</code> for later retrieval.</p> <p>If there is already data associated with <code>session_id</code>, replace it with <code>data</code> and reset its expiry time</p> <p>Parameters:</p>    Name Type Description Default     <code>session_id</code>  <code>str</code>  <p>The session-ID</p>  required    <code>data</code>  <code>bytes</code>  <p>Serialized session data</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SQLAlchemyBackend.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(session_id)\n</code></pre>  <p>Delete the data associated with <code>session_id</code>. Fails silently if no such session-ID exists.</p> <p>Parameters:</p>    Name Type Description Default     <code>session_id</code>  <code>str</code>  <p>The session-ID</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SQLAlchemyBackend.delete_all","title":"delete_all  <code>async</code>","text":"<pre><code>delete_all()\n</code></pre>  <p>Delete all session data.</p> <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SQLAlchemyBackend.delete_expired","title":"delete_expired  <code>async</code>","text":"<pre><code>delete_expired()\n</code></pre>  <p>Delete all expired session from the database.</p> <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.AsyncSQLAlchemyBackend","title":"starlite.middleware.session.sqlalchemy_backend.AsyncSQLAlchemyBackend","text":"<p>         Bases: <code>BaseSQLAlchemyBackend[AsyncSASession]</code></p> <p>Asynchronous SQLAlchemy backend.</p>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.AsyncSQLAlchemyBackend.get","title":"get  <code>async</code>","text":"<pre><code>get(session_id)\n</code></pre>  <p>Retrieve data associated with <code>session_id</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>session_id</code>  <code>str</code>  <p>The session-ID</p>  required     <p>Returns:</p>    Type Description      <code>Optional[bytes]</code>  <p>The session data, if existing, otherwise <code>None</code>.</p>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.AsyncSQLAlchemyBackend.set","title":"set  <code>async</code>","text":"<pre><code>set(session_id, data)\n</code></pre>  <p>Store <code>data</code> under the <code>session_id</code> for later retrieval.</p> <p>If there is already data associated with <code>session_id</code>, replace it with <code>data</code> and reset its expiry time</p> <p>Parameters:</p>    Name Type Description Default     <code>session_id</code>  <code>str</code>  <p>The session-ID.</p>  required    <code>data</code>  <code>bytes</code>  <p>Serialized session data</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.AsyncSQLAlchemyBackend.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(session_id)\n</code></pre>  <p>Delete the data associated with <code>session_id</code>. Fails silently if no such session-ID exists.</p> <p>Parameters:</p>    Name Type Description Default     <code>session_id</code>  <code>str</code>  <p>The session-ID</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.AsyncSQLAlchemyBackend.delete_all","title":"delete_all  <code>async</code>","text":"<pre><code>delete_all()\n</code></pre>  <p>Delete all session data.</p> <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.AsyncSQLAlchemyBackend.delete_expired","title":"delete_expired  <code>async</code>","text":"<pre><code>delete_expired()\n</code></pre>  <p>Delete all expired session from the database.</p> <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.create_session_model","title":"starlite.middleware.session.sqlalchemy_backend.create_session_model","text":"<pre><code>starlite.middleware.session.sqlalchemy_backend.create_session_model(base, table_name='session')\n</code></pre>  <p>Dynamically generate a session storage model and register it with the declarative base.</p> <p>Parameters:</p>    Name Type Description Default     <code>base</code>  <code>Type[Any]</code>  <p>SQLAlchemy declarative base</p>  required    <code>table_name</code>  <code>str</code>  <p>Alternative table name</p>  <code>'session'</code>     <p>Returns:</p>    Type Description      <code>Type[SessionModelMixin]</code>  <p>A mapped model subclassing <code>base</code> and <code>SessionModelMixin</code></p>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.register_session_model","title":"starlite.middleware.session.sqlalchemy_backend.register_session_model","text":"<pre><code>starlite.middleware.session.sqlalchemy_backend.register_session_model(base, model)\n</code></pre>  <p>Map and register a pre-existing model subclassing <code>SessionModelMixin</code> with a declarative base or registry.</p> <p>Parameters:</p>    Name Type Description Default     <code>base</code>  <code>Union[registry, Any]</code>  <p>Either a <code>orm.registry</code> or <code>DeclarativeBase</code></p>  required    <code>model</code>  <code>Type[SessionModelT]</code>  <p>SQLAlchemy model to register</p>  required     <p>Returns:</p>    Type Description      <code>Type[SessionModelT]</code>  <p>A mapped model subclassing <code>SessionModelMixin</code>, and registered in <code>registry</code></p>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SessionModelMixin","title":"starlite.middleware.session.sqlalchemy_backend.SessionModelMixin","text":"<p>Mixin for session storage.</p>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SessionModelMixin.session_id","title":"session_id  <code>class-attribute</code>","text":"<pre><code>session_id: Mapped[str] = sa.Column(sa.String, nullable=False, unique=True, index=True)\n</code></pre>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SessionModelMixin.data","title":"data  <code>class-attribute</code>","text":"<pre><code>data: Mapped[bytes] = sa.Column(sa.LargeBinary, nullable=False)\n</code></pre>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SessionModelMixin.expires","title":"expires  <code>class-attribute</code>","text":"<pre><code>expires: Mapped[datetime] = sa.Column(sa.DateTime, nullable=False)\n</code></pre>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SessionModelMixin.expired","title":"expired","text":"<pre><code>expired()\n</code></pre>  <p>SQL-Expression to check if the session has expired.</p>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SessionModel","title":"starlite.middleware.session.sqlalchemy_backend.SessionModel","text":"<p>         Bases: <code>SessionModelMixin</code></p> <p>Session storage model.</p>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SessionModel.__tablename__","title":"__tablename__  <code>class-attribute</code>","text":"<pre><code>__tablename__ = 'session'\n</code></pre>"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SessionModel.id","title":"id  <code>class-attribute</code>","text":"<pre><code>id: Mapped[int] = sa.Column(sa.Integer, primary_key=True)\n</code></pre>"},{"location":"reference/openapi/0-openapi-controller/","title":"OpenAPI Controller","text":""},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController","title":"starlite.openapi.controller.OpenAPIController","text":"<p>         Bases: <code>Controller</code></p> <p>Controller for OpenAPI endpoints.</p>"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.favicon","title":"favicon  <code>property</code>","text":"<pre><code>favicon: str\n</code></pre>  <p>Return favicon <code>&lt;link&gt;</code> tag, if applicable.</p> <p>Returns:</p>    Type Description      <code>str</code>  <p>A <code>&lt;link&gt;</code> tag if self.favicon_url is not empty, otherwise returns a placeholder meta tag.</p>"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.favicon_url","title":"favicon_url  <code>class-attribute</code>","text":"<pre><code>favicon_url: str = ''\n</code></pre>  <p>URL to download a favicon from.</p>"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.path","title":"path  <code>class-attribute</code>","text":"<pre><code>path: str = '/schema'\n</code></pre>  <p>Base path for the OpenAPI documentation endpoints.</p>"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.redoc_version","title":"redoc_version  <code>class-attribute</code>","text":"<pre><code>redoc_version: str = 'next'\n</code></pre>  <p>Redoc version to download from the CDN.</p>"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.redoc_google_fonts","title":"redoc_google_fonts  <code>class-attribute</code>","text":"<pre><code>redoc_google_fonts: bool = True\n</code></pre>  <p>Download google fonts via CDN.</p> <p>Should be set to <code>False</code> when not using a CDN.</p>"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.redoc_js_url","title":"redoc_js_url  <code>class-attribute</code>","text":"<pre><code>redoc_js_url: str = (\n    f\"https://cdn.jsdelivr.net/npm/redoc@{redoc_version}/bundles/redoc.standalone.js\"\n)\n</code></pre>  <p>Download url for the Redoc JS bundle.</p>"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.render_methods_map","title":"render_methods_map  <code>cached</code> <code>property</code>","text":"<pre><code>render_methods_map: Dict[Literal['redoc', 'swagger', 'elements'], Callable[[Request], str]]\n</code></pre>  <p>Map render method names to render methods.</p> <p>Returns:</p>    Type Description      <code>Dict[Literal['redoc', 'swagger', 'elements'], Callable[[Request], str]]</code>  <p>A mapping of string keys to render methods.</p>"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.stoplight_elements_version","title":"stoplight_elements_version  <code>class-attribute</code>","text":"<pre><code>stoplight_elements_version: str = '7.7.5'\n</code></pre>  <p>StopLight Elements version to download from the CDN.</p>"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.stoplight_elements_css_url","title":"stoplight_elements_css_url  <code>class-attribute</code>","text":"<pre><code>stoplight_elements_css_url: str = (\n    f\"https://unpkg.com/@stoplight/elements@{stoplight_elements_version}/styles.min.css\"\n)\n</code></pre>  <p>Download url for the Stoplight Elements CSS bundle.</p>"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.stoplight_elements_js_url","title":"stoplight_elements_js_url  <code>class-attribute</code>","text":"<pre><code>stoplight_elements_js_url: str = (\n    f\"https://unpkg.com/@stoplight/elements@{stoplight_elements_version}/web-components.min.js\"\n)\n</code></pre>  <p>Download url for the Stoplight Elements JS bundle.</p>"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.style","title":"style  <code>class-attribute</code>","text":"<pre><code>style: str = 'body { margin: 0; padding: 0 }'\n</code></pre>  <p>Base styling of the html body.</p>"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.swagger_ui_version","title":"swagger_ui_version  <code>class-attribute</code>","text":"<pre><code>swagger_ui_version: str = '4.15.5'\n</code></pre>  <p>SwaggerUI version to download from the CDN.</p>"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.swagger_css_url","title":"swagger_css_url  <code>class-attribute</code>","text":"<pre><code>swagger_css_url: str = (\n    f\"https://cdn.jsdelivr.net/npm/swagger-ui-dist@{swagger_ui_version}/swagger-ui.css\"\n)\n</code></pre>  <p>Download url for the Swagger UI CSS bundle.</p>"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.redoc","title":"redoc","text":"<pre><code>redoc(request)\n</code></pre>  <p>Route handler responsible for rendering Redoc.</p> <p>Parameters:</p>    Name Type Description Default     <code>request</code>  <code>Request</code>  <p>A Request instance.</p>  required     <p>Returns:</p>    Type Description      <code>Response</code>  <p>A response with a rendered redoc documentation site</p>"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.render_404_page","title":"render_404_page","text":"<pre><code>render_404_page()\n</code></pre>  <p>Render an HTML 404 page.</p> <p>Returns:</p>    Type Description      <code>str</code>  <p>A rendered html string.</p>"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.render_redoc","title":"render_redoc","text":"<pre><code>render_redoc(request)\n</code></pre>  <p>Render an HTML page for Redoc.</p>  Notes <ul> <li>override this method to customize the template.</li> </ul>  <p>Parameters:</p>    Name Type Description Default     <code>request</code>  <code>Request</code>  <p>A Request instance.</p>  required     <p>Returns:</p>    Type Description      <code>str</code>  <p>A rendered html string.</p>"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.render_stoplight_elements","title":"render_stoplight_elements","text":"<pre><code>render_stoplight_elements(request)\n</code></pre>  <p>Render an HTML page for StopLight Elements.</p>  Notes <ul> <li>override this method to customize the template.</li> </ul>  <p>Parameters:</p>    Name Type Description Default     <code>request</code>  <code>Request</code>  <p>A Request instance.</p>  required     <p>Returns:</p>    Type Description      <code>str</code>  <p>A rendered html string.</p>"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.render_swagger_ui","title":"render_swagger_ui","text":"<pre><code>render_swagger_ui(request)\n</code></pre>  <p>Render an HTML page for Swagger-UI.</p>  Notes <ul> <li>override this method to customize the template.</li> </ul>  <p>Parameters:</p>    Name Type Description Default     <code>request</code>  <code>Request</code>  <p>A Request instance.</p>  required     <p>Returns:</p>    Type Description      <code>str</code>  <p>A rendered html string.</p>"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.retrieve_schema_json","title":"retrieve_schema_json","text":"<pre><code>retrieve_schema_json(request)\n</code></pre>  <p>Return the OpenAPI schema as JSON with an 'application/vnd.oai.openapi+json' Content-Type header.</p> <p>Parameters:</p>    Name Type Description Default     <code>request</code>  <code>Request</code>  <p>A Request instance.</p>  required     <p>Returns:</p>    Type Description      <code>Response</code>  <p>A Response instance with the JSON object rendered into a string.</p>"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.retrieve_schema_yaml","title":"retrieve_schema_yaml","text":"<pre><code>retrieve_schema_yaml(request)\n</code></pre>  <p>Return the OpenAPI schema as YAML with an 'application/vnd.oai.openapi' Content-Type header.</p> <p>Parameters:</p>    Name Type Description Default     <code>request</code>  <code>Request</code>  <p>A Request instance.</p>  required     <p>Returns:</p>    Type Description      <code>Response</code>  <p>A Response instance with the YAML object rendered into a string.</p>"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.root","title":"root","text":"<pre><code>root(request)\n</code></pre>  <p>Render a static documentation site.</p> <p>The site to be rendered is based on the <code>root_schema_site</code> value set in the  application's OpenAPIConfig.  Defaults to <code>redoc</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>request</code>  <code>Request</code>  <p>A Request instance.</p>  required     <p>Returns:</p>    Type Description      <code>Response</code>  <p>A response with the rendered site defined in root_schema_site.</p>    <p>Raises:</p>    Type Description      <code>ImproperlyConfiguredException</code>  <p>If the application <code>openapi_config</code> attribute is <code>None</code>.</p>"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.should_serve_endpoint","title":"should_serve_endpoint","text":"<pre><code>should_serve_endpoint(request)\n</code></pre>  <p>Verify that the requested path is within the enabled endpoints in the openapi_config.</p> <p>Parameters:</p>    Name Type Description Default     <code>request</code>  <code>Request</code>  <p>To be tested if endpoint enabled.</p>  required     <p>Returns:</p>    Type Description      <code>bool</code>  <p>A boolean.</p>    <p>Raises:</p>    Type Description      <code>ImproperlyConfiguredException</code>  <p>If the application <code>openapi_config</code> attribute is <code>None</code>.</p>"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.stoplight_elements","title":"stoplight_elements","text":"<pre><code>stoplight_elements(request)\n</code></pre>  <p>Route handler responsible for rendering StopLight Elements.</p> <p>Parameters:</p>    Name Type Description Default     <code>request</code>  <code>Request</code>  <p>A Request instance.</p>  required     <p>Returns:</p>    Type Description      <code>Response</code>  <p>A response with a rendered stoplight elements documentation site</p>"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.swagger_ui","title":"swagger_ui","text":"<pre><code>swagger_ui(request)\n</code></pre>  <p>Route handler responsible for rendering Swagger-UI.</p> <p>Parameters:</p>    Name Type Description Default     <code>request</code>  <code>Request</code>  <p>A Request instance.</p>  required     <p>Returns:</p>    Name Type Description     <code>response</code>  <code>Response</code>  <p>With a rendered swagger documentation site</p>"},{"location":"reference/openapi/1-openapi-response-spec/","title":"OpenAPI Response Spec","text":""},{"location":"reference/openapi/1-openapi-response-spec/#starlite.openapi.datastructures.ResponseSpec","title":"starlite.openapi.datastructures.ResponseSpec","text":"<p>         Bases: <code>BaseModel</code></p> <p>Container type of additional responses.</p>"},{"location":"reference/openapi/1-openapi-response-spec/#starlite.openapi.datastructures.ResponseSpec.model","title":"model  <code>class-attribute</code>","text":"<pre><code>model: Type[BaseModel]\n</code></pre>  <p>A model that describes the content of the response.</p>"},{"location":"reference/openapi/1-openapi-response-spec/#starlite.openapi.datastructures.ResponseSpec.generate_examples","title":"generate_examples  <code>class-attribute</code>","text":"<pre><code>generate_examples: bool = True\n</code></pre>  <p>Generate examples for the response content.</p>"},{"location":"reference/openapi/1-openapi-response-spec/#starlite.openapi.datastructures.ResponseSpec.description","title":"description  <code>class-attribute</code>","text":"<pre><code>description: str = 'Additional response'\n</code></pre>  <p>A description of the response.</p>"},{"location":"reference/openapi/1-openapi-response-spec/#starlite.openapi.datastructures.ResponseSpec.media_type","title":"media_type  <code>class-attribute</code>","text":"<pre><code>media_type: MediaType = MediaType.JSON\n</code></pre>  <p>Response media type.</p>"},{"location":"reference/params/0-parameter/","title":"Parameter","text":""},{"location":"reference/params/0-parameter/#starlite.params.Parameter","title":"<code>starlite.params.Parameter(value_type=Undefined, *, header=None, cookie=None, query=None, examples=None, external_docs=None, content_encoding=None, required=True, default=Undefined, title=None, description=None, const=None, gt=None, ge=None, lt=None, le=None, multiple_of=None, min_items=None, max_items=None, min_length=None, max_length=None, regex=None)</code>","text":"<p>Create a pydantic <code>FieldInfo</code> instance with an extra kwargs, used for both parameter parsing and OpenAPI schema generation.</p> <p>Parameters:</p>    Name Type Description Default     <code>value_type</code>  <code>Any</code>  <p><code>Undefined</code> by default.</p>  <code>Undefined</code>    <code>header</code>  <code>Optional[str]</code>  <p>The header parameter key - required for header parameters.</p>  <code>None</code>    <code>cookie</code>  <code>Optional[str]</code>  <p>The cookie parameter key - required for cookie parameters.</p>  <code>None</code>    <code>query</code>  <code>Optional[str]</code>  <p>The query parameter key for this parameter.</p>  <code>None</code>    <code>examples</code>  <code>Optional[List[Example]]</code>  <p>A list of Example models.</p>  <code>None</code>    <code>external_docs</code>  <code>Optional[ExternalDocumentation]</code>  <p>A url pointing at external documentation for the given parameter.</p>  <code>None</code>    <code>content_encoding</code>  <code>Optional[str]</code>  <p>The content encoding of the value. Applicable on to string values. See OpenAPI 3.1 for details.</p>  <code>None</code>    <code>required</code>  <code>bool</code>  <p>A boolean flag dictating whether this parameter is required. If set to False, None values will be allowed. Defaults to True.</p>  <code>True</code>    <code>default</code>  <code>Any</code>  <p>A default value. If const is true, this value is required.</p>  <code>Undefined</code>    <code>title</code>  <code>Optional[str]</code>  <p>String value used in the title section of the OpenAPI schema for the given parameter.</p>  <code>None</code>    <code>description</code>  <code>Optional[str]</code>  <p>String value used in the description section of the OpenAPI schema for the given parameter.</p>  <code>None</code>    <code>const</code>  <code>Optional[bool]</code>  <p>A boolean flag dictating whether this parameter is a constant. If True, the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with the default value.</p>  <code>None</code>    <code>gt</code>  <code>Optional[float]</code>  <p>Constrict value to be greater than a given float or int. Equivalent to exclusiveMinimum in the OpenAPI specification.</p>  <code>None</code>    <code>ge</code>  <code>Optional[float]</code>  <p>Constrict value to be greater or equal to a given float or int. Equivalent to minimum in the OpenAPI specification.</p>  <code>None</code>    <code>lt</code>  <code>Optional[float]</code>  <p>Constrict value to be less than a given float or int. Equivalent to exclusiveMaximum in the OpenAPI specification.</p>  <code>None</code>    <code>le</code>  <code>Optional[float]</code>  <p>Constrict value to be less or equal to a given float or int. Equivalent to maximum in the OpenAPI specification.</p>  <code>None</code>    <code>multiple_of</code>  <code>Optional[float]</code>  <p>Constrict value to a multiple of a given float or int. Equivalent to multipleOf in the OpenAPI specification.</p>  <code>None</code>    <code>min_items</code>  <code>Optional[int]</code>  <p>Constrict a set or a list to have a minimum number of items. Equivalent to minItems in the OpenAPI specification.</p>  <code>None</code>    <code>max_items</code>  <code>Optional[int]</code>  <p>Constrict a set or a list to have a maximum number of items. Equivalent to maxItems in the OpenAPI specification.</p>  <code>None</code>    <code>min_length</code>  <code>Optional[int]</code>  <p>Constrict a string or bytes value to have a minimum length. Equivalent to minLength in the OpenAPI specification.</p>  <code>None</code>    <code>max_length</code>  <code>Optional[int]</code>  <p>Constrict a string or bytes value to have a maximum length. Equivalent to maxLength in the OpenAPI specification.</p>  <code>None</code>    <code>regex</code>  <code>Optional[str]</code>  <p>A string representing a regex against which the given string will be matched. Equivalent to pattern in the OpenAPI specification.</p>  <code>None</code>"},{"location":"reference/params/1-body/","title":"Body","text":""},{"location":"reference/params/1-body/#starlite.params.Body","title":"<code>starlite.params.Body(*, media_type=RequestEncodingType.JSON, examples=None, external_docs=None, content_encoding=None, default=Undefined, title=None, description=None, const=None, gt=None, ge=None, lt=None, le=None, multiple_of=None, min_items=None, max_items=None, min_length=None, max_length=None, regex=None)</code>","text":"<p>Create a pydantic <code>FieldInfo</code> instance with an extra kwargs, used for both parameter parsing and OpenAPI schema generation.</p> <p>Parameters:</p>    Name Type Description Default     <code>media_type</code>  <code>Union[str, RequestEncodingType]</code>  <p>Defaults to RequestEncodingType.JSON.</p>  <code>RequestEncodingType.JSON</code>    <code>examples</code>  <code>Optional[List[Example]]</code>  <p>A list of Example models.</p>  <code>None</code>    <code>external_docs</code>  <code>Optional[ExternalDocumentation]</code>  <p>A url pointing at external documentation for the given parameter.</p>  <code>None</code>    <code>content_encoding</code>  <code>Optional[str]</code>  <p>The content encoding of the value. Applicable on to string values. See OpenAPI 3.1 for details.</p>  <code>None</code>    <code>default</code>  <code>Any</code>  <p>A default value. If const is true, this value is required.</p>  <code>Undefined</code>    <code>title</code>  <code>Optional[str]</code>  <p>String value used in the title section of the OpenAPI schema for the given parameter.</p>  <code>None</code>    <code>description</code>  <code>Optional[str]</code>  <p>String value used in the description section of the OpenAPI schema for the given parameter.</p>  <code>None</code>    <code>const</code>  <code>Optional[bool]</code>  <p>A boolean flag dictating whether this parameter is a constant. If True, the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with the default value.</p>  <code>None</code>    <code>gt</code>  <code>Optional[float]</code>  <p>Constrict value to be greater than a given float or int. Equivalent to exclusiveMinimum in the OpenAPI specification.</p>  <code>None</code>    <code>ge</code>  <code>Optional[float]</code>  <p>Constrict value to be greater or equal to a given float or int. Equivalent to minimum in the OpenAPI specification.</p>  <code>None</code>    <code>lt</code>  <code>Optional[float]</code>  <p>Constrict value to be less than a given float or int. Equivalent to exclusiveMaximum in the OpenAPI specification.</p>  <code>None</code>    <code>le</code>  <code>Optional[float]</code>  <p>Constrict value to be less or equal to a given float or int. Equivalent to maximum in the OpenAPI specification.</p>  <code>None</code>    <code>multiple_of</code>  <code>Optional[float]</code>  <p>Constrict value to a multiple of a given float or int. Equivalent to multipleOf in the OpenAPI specification.</p>  <code>None</code>    <code>min_items</code>  <code>Optional[int]</code>  <p>Constrict a set or a list to have a minimum number of items. Equivalent to minItems in the OpenAPI specification.</p>  <code>None</code>    <code>max_items</code>  <code>Optional[int]</code>  <p>Constrict a set or a list to have a maximum number of items. Equivalent to maxItems in the OpenAPI specification.</p>  <code>None</code>    <code>min_length</code>  <code>Optional[int]</code>  <p>Constrict a string or bytes value to have a minimum length. Equivalent to minLength in the OpenAPI specification.</p>  <code>None</code>    <code>max_length</code>  <code>Optional[int]</code>  <p>Constrict a string or bytes value to have a maximum length. Equivalent to maxLength in the OpenAPI specification.</p>  <code>None</code>    <code>regex</code>  <code>Optional[str]</code>  <p>A string representing a regex against which the given string will be matched. Equivalent to pattern in the OpenAPI specification.</p>  <code>None</code>"},{"location":"reference/params/2-dependency/","title":"Dependency","text":""},{"location":"reference/params/2-dependency/#starlite.params.Dependency","title":"<code>starlite.params.Dependency(*, default=Undefined, skip_validation=False)</code>","text":"<p>Create a pydantic <code>FieldInfo</code> instance with an extra kwargs, used for both parameter parsing and OpenAPI schema generation.</p> <p>Parameters:</p>    Name Type Description Default     <code>default</code>  <code>Any</code>  <p>default value if dependency not provided.</p>  <code>Undefined</code>    <code>skip_validation</code>  <code>bool</code>  <p>If <code>True</code> provided dependency values are not validated by signature model.</p>  <code>False</code>"},{"location":"reference/plugins/0-plugin-protocol/","title":"Plugin Protocol","text":""},{"location":"reference/plugins/0-plugin-protocol/#starlite.plugins.base.PluginProtocol","title":"starlite.plugins.base.PluginProtocol","text":"<p>         Bases: <code>Protocol[ModelT]</code></p> <p>Base plugin protocol to be inherited when implementing plugins.</p>"},{"location":"reference/plugins/0-plugin-protocol/#starlite.plugins.base.PluginProtocol.on_app_init","title":"on_app_init","text":"<pre><code>on_app_init(app)\n</code></pre>  <p>Receive the Starlite application instance before <code>init</code> is finalized and allow the plugin to update various attributes.</p> <p>Examples:</p> <pre><code>from starlite import PluginProtocol, Starlite, get\n\n\n@get(\"/my-path\")\ndef my_route_handler() -&gt; dict[str, str]:\n    return {\"hello\": \"world\"}\n\n\nclass MyPlugin(PluginProtocol[Any]):\n    def on_app_init(self, app: Starlite) -&gt; None:\n        # update app attributes\n\n        app.after_request = ...\n        app.after_response = ...\n        app.before_request = ...\n        app.dependencies.update({...})\n        app.exception_handlers.update({...})\n        app.guards.extend(...)\n        app.middleware.extend(...)\n        app.on_shutdown.extend(...)\n        app.on_startup.extend(...)\n        app.parameters.update({...})\n        app.response_class = ...\n        app.response_cookies.extend(...)\n        app.response_headers.update(...)\n        app.tags.extend(...)\n\n        # register a route handler\n        app.register(my_route_handler)\n</code></pre> <p>Parameters:</p>    Name Type Description Default     <code>app</code>  <code>Starlite</code>  <p>The Starlite instance.</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/plugins/0-plugin-protocol/#starlite.plugins.base.PluginProtocol.is_plugin_supported_type","title":"is_plugin_supported_type  <code>staticmethod</code>","text":"<pre><code>is_plugin_supported_type(value)\n</code></pre>  <p>Given a value of indeterminate type, determine if this value is supported by the plugin.</p> <p>Parameters:</p>    Name Type Description Default     <code>value</code>  <code>Any</code>  <p>An arbitrary value.</p>  required     <p>Returns:</p>    Type Description      <code>TypeGuard[ModelT]</code>  <p>A typeguard dictating whether the value is supported by the plugin.</p>"},{"location":"reference/plugins/0-plugin-protocol/#starlite.plugins.base.PluginProtocol.to_pydantic_model_class","title":"to_pydantic_model_class","text":"<pre><code>to_pydantic_model_class(model_class, **kwargs)\n</code></pre>  <p>Given a model_class supported by the plugin, convert it to a subclass of the pydantic BaseModel.</p> <p>Parameters:</p>    Name Type Description Default     <code>model_class</code>  <code>Type[ModelT]</code>  <p>A model class supported by the plugin.</p>  required    <code>**kwargs</code>  <code>Any</code>  <p>Any additional kwargs.</p>  <code>{}</code>     <p>Returns:</p>    Type Description      <code>Type[BaseModel]</code>  <p>A pydantic model class.</p>"},{"location":"reference/plugins/0-plugin-protocol/#starlite.plugins.base.PluginProtocol.from_pydantic_model_instance","title":"from_pydantic_model_instance","text":"<pre><code>from_pydantic_model_instance(model_class, pydantic_model_instance)\n</code></pre>  <p>Given an instance of a pydantic model created using a plugin's 'to_pydantic_model_class', return an instance of the class from which that pydantic model has been created.</p> <p>This class is passed in as the 'model_class' kwarg.</p> <p>Parameters:</p>    Name Type Description Default     <code>model_class</code>  <code>Type[ModelT]</code>  <p>A model class supported by the plugin.</p>  required    <code>pydantic_model_instance</code>  <code>BaseModel</code>  <p>A pydantic model instance.</p>  required     <p>Returns:</p>    Type Description      <code>ModelT</code>  <p>A model instance.</p>"},{"location":"reference/plugins/0-plugin-protocol/#starlite.plugins.base.PluginProtocol.to_dict","title":"to_dict","text":"<pre><code>to_dict(model_instance)\n</code></pre>  <p>Given an instance of a model supported by the plugin, return a dictionary of serializable values.</p> <p>Parameters:</p>    Name Type Description Default     <code>model_instance</code>  <code>ModelT</code>  <p>A model instance of the type supported by the plugin.</p>  required      Notes <ul> <li>This method can be async as well.</li> </ul>  <p>Returns:</p>    Type Description      <code>Union[Dict[str, Any], Awaitable[Dict[str, Any]]]</code>  <p>A string keyed dictionary of values.</p>"},{"location":"reference/plugins/0-plugin-protocol/#starlite.plugins.base.PluginProtocol.from_dict","title":"from_dict","text":"<pre><code>from_dict(model_class, **kwargs)\n</code></pre>  <p>Given a class supported by this plugin and a dict of values, create an instance of the class.</p> <p>Parameters:</p>    Name Type Description Default     <code>model_class</code>  <code>Type[ModelT]</code>  <p>A model class supported by the plugin.</p>  required    <code>**kwargs</code>  <code>Any</code>  <p>A string keyed mapping of values.</p>  <code>{}</code>     <p>Returns:</p>    Type Description      <code>ModelT</code>  <p>A model instance.</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/","title":"SQLAlchemy Plugin","text":""},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.SQLAlchemyPlugin","title":"starlite.plugins.sql_alchemy.SQLAlchemyPlugin","text":"<p>         Bases: <code>PluginProtocol[DeclarativeMeta]</code></p> <p>A Plugin for SQLAlchemy.</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.providers_map","title":"providers_map  <code>property</code>","text":"<pre><code>providers_map: Dict[Type[TypeEngine], Callable[[Union[TypeEngine, Type[TypeEngine]]], Any]]\n</code></pre>  <p>Map of SQLAlchemy column types to provider functions.</p> <p>This method is separated to allow for easy overriding in subclasses.</p> <p>Returns     A dictionary mapping SQLAlchemy types to callables.</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.__init__","title":"__init__","text":"<pre><code>__init__(config=None)\n</code></pre>  <p>Initialize <code>SQLAlchemyPlugin</code>.</p> <p>Support (de)serialization and OpenAPI generation for SQLAlchemy ORM types.</p> <p>Parameters:</p>    Name Type Description Default     <code>config</code>  <code>Optional[SQLAlchemyConfig]</code>  <p>Optional SQLAlchemyConfig instance. If passed, the plugin will establish a DB connection and hook handlers and dependencies.</p>  <code>None</code>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.from_dict","title":"from_dict","text":"<pre><code>from_dict(model_class, **kwargs)\n</code></pre>  <p>Given a dictionary of kwargs, return an instance of the given model_class.</p> <p>Parameters:</p>    Name Type Description Default     <code>model_class</code>  <code>Type[DeclarativeMeta]</code>  <p>A declarative table class.</p>  required    <code>**kwargs</code>  <code>Any</code>  <p>Kwargs to instantiate the table with.</p>  <code>{}</code>     <p>Returns:</p>    Type Description      <code>DeclarativeMeta</code>  <p>An instantiated table instance.</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.from_pydantic_model_instance","title":"from_pydantic_model_instance","text":"<pre><code>from_pydantic_model_instance(model_class, pydantic_model_instance)\n</code></pre>  <p>Create an instance of a given model_class using the values stored in the given pydantic_model_instance.</p> <p>Parameters:</p>    Name Type Description Default     <code>model_class</code>  <code>Type[DeclarativeMeta]</code>  <p>A declarative table class.</p>  required    <code>pydantic_model_instance</code>  <code>BaseModel</code>  <p>A pydantic model instance.</p>  required     <p>Returns:</p>    Type Description      <code>Any</code>  <p>A declarative meta table instance.</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.get_pydantic_type","title":"get_pydantic_type","text":"<pre><code>get_pydantic_type(column_type)\n</code></pre>  <p>Given a 'Column.type' value, return a type supported by pydantic.</p> <p>Parameters:</p>    Name Type Description Default     <code>column_type</code>  <code>Any</code>  <p>The type of the SQLColumn.</p>  required     <p>Returns:</p>    Type Description      <code>Any</code>  <p>A pydantic supported type.</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.is_plugin_supported_type","title":"is_plugin_supported_type  <code>staticmethod</code>","text":"<pre><code>is_plugin_supported_type(value)\n</code></pre>  <p><code>TypeGuard</code> testing whether values are subclasses of SQLAlchemy's 'DeclarativeMeta' class.</p> <p>Parameters:</p>    Name Type Description Default     <code>value</code>  <code>Any</code>  <p>An arbitrary type to test.</p>  required     <p>Returns:</p>    Type Description      <code>TypeGuard[DeclarativeMeta]</code>  <p>A boolean typeguard.</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.on_app_init","title":"on_app_init","text":"<pre><code>on_app_init(app)\n</code></pre>  <p>If config has been passed to the plugin, it will initialize SQLAlchemy and add the dependencies as expected.</p> <p>Executed on the application's init process.</p> <p>Parameters:</p>    Name Type Description Default     <code>app</code>  <code>Starlite</code>  <p>The Starlite application instance.</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.to_dict","title":"to_dict","text":"<pre><code>to_dict(model_instance)\n</code></pre>  <p>Given a model instance, convert it to a dict of values that can be serialized.</p> <p>Parameters:</p>    Name Type Description Default     <code>model_instance</code>  <code>DeclarativeMeta</code>  <p>An SQLAlchemy declarative table instance.</p>  required     <p>Returns:</p>    Type Description      <code>Dict[str, Any]</code>  <p>A string keyed dict of values.</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.to_pydantic_model_class","title":"to_pydantic_model_class","text":"<pre><code>to_pydantic_model_class(model_class, **kwargs)\n</code></pre>  <p>Generate a pydantic model for a given SQLAlchemy declarative table and any nested relations.</p> <p>Parameters:</p>    Name Type Description Default     <code>model_class</code>  <code>Type[DeclarativeMeta]</code>  <p>An SQLAlchemy declarative class instance.</p>  required    <code>**kwargs</code>  <code>Any</code>  <p>Kwargs to pass to the model.</p>  <code>{}</code>     <p>Returns:</p>    Type Description      <code>Type[BaseModel]</code>  <p>A pydantic model instance.</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.SQLAlchemyConfig","title":"starlite.plugins.sql_alchemy.SQLAlchemyConfig","text":"<p>         Bases: <code>BaseModel</code></p> <p>Configuration for SQLAlchemy's <code>sessionmaker</code>.</p> <p>For details see: https://docs.sqlalchemy.org/en/14/orm/session_api.html</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.before_send_handler","title":"before_send_handler  <code>class-attribute</code>","text":"<pre><code>before_send_handler: BeforeMessageSendHookHandler = default_before_send_handler\n</code></pre>  <p>Handler to call before the ASGI message is sent.</p> <p>The handler should handle closing the session stored in the ASGI scope, if its still open, and committing and uncommitted data.</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.connection_string","title":"connection_string  <code>class-attribute</code>","text":"<pre><code>connection_string: Optional[str] = None\n</code></pre>  <p>Database connection string in one of the formats supported by SQLAlchemy.</p> <p>Notes: - For async connections, the connection string must include the correct async prefix.     e.g. 'postgresql+asyncpg://...' instead of 'postgresql://', and for sync connections its the opposite.</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.create_async_engine_callable","title":"create_async_engine_callable  <code>class-attribute</code>","text":"<pre><code>create_async_engine_callable: Callable[[str], AsyncEngine] = create_async_engine\n</code></pre>  <p>Callable that creates an 'AsyncEngine' instance or instance of its subclass.</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.create_engine_callable","title":"create_engine_callable  <code>class-attribute</code>","text":"<pre><code>create_engine_callable: Callable[[str], Union[Engine, FutureEngine]] = create_engine\n</code></pre>  <p>Callable that creates an 'Engine' or 'FutureEngine' instance or instance of its subclass.</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.dependency_key","title":"dependency_key  <code>class-attribute</code>","text":"<pre><code>dependency_key: str = 'db_session'\n</code></pre>  <p>Key to use for the dependency injection of database sessions.</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.engine","title":"engine  <code>property</code>","text":"<pre><code>engine: Union[Engine, FutureEngine, AsyncEngine]\n</code></pre>  <p>Return an engine. If none exists yet, create one.</p> <p>Returns:</p>    Type Description      <code>Union[Engine, FutureEngine, AsyncEngine]</code>  <p>Getter that returns the engine instance used by the plugin.</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.engine_app_state_key","title":"engine_app_state_key  <code>class-attribute</code>","text":"<pre><code>engine_app_state_key: str = 'db_engine'\n</code></pre>  <p>Key under which to store the SQLAlchemy engine in the application State instance.</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.engine_config","title":"engine_config  <code>class-attribute</code>","text":"<pre><code>engine_config: SQLAlchemyEngineConfig = SQLAlchemyEngineConfig()\n</code></pre>  <p>Configuration for the SQLAlchemy engine.</p> <p>The configuration options are documented in the SQLAlchemy documentation.</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.engine_instance","title":"engine_instance  <code>class-attribute</code>","text":"<pre><code>engine_instance: Optional[Union[Engine, FutureEngine, AsyncEngine]] = None\n</code></pre>  <p>Optional engine to use.</p> <p>If set, the plugin will use the provided instance rather than instantiate an engine.</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.session_class","title":"session_class  <code>class-attribute</code>","text":"<pre><code>session_class: Optional[Union[Type[Session], Type[AsyncSession]]] = None\n</code></pre>  <p>The session class to use.</p> <p>If not set, the session class will default to 'sqlalchemy.orm.Session' for sync connections and 'sqlalchemy.ext.asyncio.AsyncSession' for async ones.</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.session_config","title":"session_config  <code>class-attribute</code>","text":"<pre><code>session_config: SQLAlchemySessionConfig = SQLAlchemySessionConfig()\n</code></pre>  <p>Configuration options for the 'sessionmaker'.</p> <p>The configuration options are documented in the SQLAlchemy documentation.</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.session_maker","title":"session_maker  <code>property</code>","text":"<pre><code>session_maker: sessionmaker\n</code></pre>  <p>Get a sessionmaker. If none exists yet, create one.</p> <p>Returns:</p>    Type Description      <code>sessionmaker</code>  <p>Getter that returns the session_maker instance used by the plugin.</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.session_maker_app_state_key","title":"session_maker_app_state_key  <code>class-attribute</code>","text":"<pre><code>session_maker_app_state_key: str = 'session_maker_class'\n</code></pre>  <p>Key under which to store the SQLAlchemy 'sessionmaker' in the application State instance.</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.session_maker_class","title":"session_maker_class  <code>class-attribute</code>","text":"<pre><code>session_maker_class: Type[SessionMakerTypeProtocol] = sessionmaker\n</code></pre>  <p>Sessionmaker class to use.</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.session_maker_instance","title":"session_maker_instance  <code>class-attribute</code>","text":"<pre><code>session_maker_instance: Optional[SessionMakerInstanceProtocol] = None\n</code></pre>  <p>Optional sessionmaker to use.</p> <p>If set, the plugin will use the provided instance rather than instantiate a sessionmaker.</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.SQLAlchemyEngineConfig","title":"starlite.plugins.sql_alchemy.SQLAlchemyEngineConfig","text":"<p>         Bases: <code>BaseModel</code></p> <p>Configuration for SQLAlchemy's <code>Engine</code>.</p> <p>For details see: https://docs.sqlalchemy.org/en/14/core/engines.html</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.connect_args","title":"connect_args  <code>class-attribute</code>","text":"<pre><code>connect_args: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.echo","title":"echo  <code>class-attribute</code>","text":"<pre><code>echo: Optional[bool] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.echo_pool","title":"echo_pool  <code>class-attribute</code>","text":"<pre><code>echo_pool: Optional[bool] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.enable_from_linting","title":"enable_from_linting  <code>class-attribute</code>","text":"<pre><code>enable_from_linting: Optional[bool] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.future","title":"future  <code>class-attribute</code>","text":"<pre><code>future: bool = True\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.hide_parameters","title":"hide_parameters  <code>class-attribute</code>","text":"<pre><code>hide_parameters: Optional[bool] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.isolation_level","title":"isolation_level  <code>class-attribute</code>","text":"<pre><code>isolation_level: Optional[IsolationLevel] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.json_deserializer","title":"json_deserializer  <code>class-attribute</code>","text":"<pre><code>json_deserializer: Callable[[str], Any] = decode_json\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.json_serializer","title":"json_serializer  <code>class-attribute</code>","text":"<pre><code>json_serializer: Callable[[Any], str] = serializer\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.label_length","title":"label_length  <code>class-attribute</code>","text":"<pre><code>label_length: Optional[int] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.listeners","title":"listeners  <code>class-attribute</code>","text":"<pre><code>listeners: Any = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.logging_level","title":"logging_level  <code>class-attribute</code>","text":"<pre><code>logging_level: Optional[Union[int, str]] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.logging_name","title":"logging_name  <code>class-attribute</code>","text":"<pre><code>logging_name: Optional[str] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.max_identifier_length","title":"max_identifier_length  <code>class-attribute</code>","text":"<pre><code>max_identifier_length: Optional[int] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.max_overflow","title":"max_overflow  <code>class-attribute</code>","text":"<pre><code>max_overflow: Optional[int] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.module","title":"module  <code>class-attribute</code>","text":"<pre><code>module: Any = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.paramstyle","title":"paramstyle  <code>class-attribute</code>","text":"<pre><code>paramstyle: Optional[Literal['qmark', 'numeric', 'named', 'format', 'pyformat']] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.plugins","title":"plugins  <code>class-attribute</code>","text":"<pre><code>plugins: Optional[List[str]] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.pool","title":"pool  <code>class-attribute</code>","text":"<pre><code>pool: Optional[Pool] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.pool_logging_name","title":"pool_logging_name  <code>class-attribute</code>","text":"<pre><code>pool_logging_name: Optional[str] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.pool_pre_ping","title":"pool_pre_ping  <code>class-attribute</code>","text":"<pre><code>pool_pre_ping: Optional[bool] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.pool_recycle","title":"pool_recycle  <code>class-attribute</code>","text":"<pre><code>pool_recycle: Optional[int] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.pool_reset_on_return","title":"pool_reset_on_return  <code>class-attribute</code>","text":"<pre><code>pool_reset_on_return: Optional[Literal['rollback', 'commit']] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.pool_size","title":"pool_size  <code>class-attribute</code>","text":"<pre><code>pool_size: Optional[int] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.pool_timeout","title":"pool_timeout  <code>class-attribute</code>","text":"<pre><code>pool_timeout: Optional[int] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.pool_use_lifo","title":"pool_use_lifo  <code>class-attribute</code>","text":"<pre><code>pool_use_lifo: Optional[bool] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.poolclass","title":"poolclass  <code>class-attribute</code>","text":"<pre><code>poolclass: Optional[Type[Pool]] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.query_cache_size","title":"query_cache_size  <code>class-attribute</code>","text":"<pre><code>query_cache_size: Optional[int] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.strategy","title":"strategy  <code>class-attribute</code>","text":"<pre><code>strategy: Optional[str] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.SQLAlchemySessionConfig","title":"starlite.plugins.sql_alchemy.SQLAlchemySessionConfig","text":"<p>         Bases: <code>BaseModel</code></p> <p>Configuration for a SQLAlchemy-Session.</p>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.autocommit","title":"autocommit  <code>class-attribute</code>","text":"<pre><code>autocommit: Optional[bool] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.autoflush","title":"autoflush  <code>class-attribute</code>","text":"<pre><code>autoflush: Optional[bool] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.bind","title":"bind  <code>class-attribute</code>","text":"<pre><code>bind: Optional[Any] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.binds","title":"binds  <code>class-attribute</code>","text":"<pre><code>binds: Optional[Any] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.enable_baked_queries","title":"enable_baked_queries  <code>class-attribute</code>","text":"<pre><code>enable_baked_queries: Optional[bool] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.expire_on_commit","title":"expire_on_commit  <code>class-attribute</code>","text":"<pre><code>expire_on_commit: bool = False\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.future","title":"future  <code>class-attribute</code>","text":"<pre><code>future: Optional[bool] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.info","title":"info  <code>class-attribute</code>","text":"<pre><code>info: Optional[Dict[str, Any]] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.query_cls","title":"query_cls  <code>class-attribute</code>","text":"<pre><code>query_cls: Optional[Type[Query]] = None\n</code></pre>"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.twophase","title":"twophase  <code>class-attribute</code>","text":"<pre><code>twophase: Optional[bool] = None\n</code></pre>"},{"location":"reference/plugins/2-piccolo-orm-plugin/","title":"PiccoloORM Plugin","text":""},{"location":"reference/plugins/2-piccolo-orm-plugin/#starlite.plugins.piccolo_orm.PiccoloORMPlugin","title":"starlite.plugins.piccolo_orm.PiccoloORMPlugin","text":"<p>         Bases: <code>PluginProtocol[Table]</code></p> <p>Support (de)serialization and OpenAPI generation for Piccolo ORM types.</p>"},{"location":"reference/plugins/2-piccolo-orm-plugin/#starlite.plugins.piccolo_orm.PiccoloORMPlugin.from_dict","title":"from_dict","text":"<pre><code>from_dict(model_class, **kwargs)\n</code></pre>  <p>Given a class supported by this plugin and a dict of values, create an instance of the class.</p>"},{"location":"reference/plugins/2-piccolo-orm-plugin/#starlite.plugins.piccolo_orm.PiccoloORMPlugin.from_pydantic_model_instance","title":"from_pydantic_model_instance","text":"<pre><code>from_pydantic_model_instance(model_class, pydantic_model_instance)\n</code></pre>  <p>Given an instance of a pydantic model created using the plugin's 'to_pydantic_model_class', return an instance of the class from which that pydantic model has been created.</p> <p>This class is passed in as the 'model_class' kwarg.</p>"},{"location":"reference/plugins/2-piccolo-orm-plugin/#starlite.plugins.piccolo_orm.PiccoloORMPlugin.is_plugin_supported_type","title":"is_plugin_supported_type  <code>staticmethod</code>","text":"<pre><code>is_plugin_supported_type(value)\n</code></pre>  <p>Given a value of indeterminate type, determine if this value is supported by the plugin.</p>"},{"location":"reference/plugins/2-piccolo-orm-plugin/#starlite.plugins.piccolo_orm.PiccoloORMPlugin.to_dict","title":"to_dict","text":"<pre><code>to_dict(model_instance)\n</code></pre>  <p>Given an instance of a model supported by the plugin, return a dictionary of serializable values.</p>"},{"location":"reference/plugins/2-piccolo-orm-plugin/#starlite.plugins.piccolo_orm.PiccoloORMPlugin.to_pydantic_model_class","title":"to_pydantic_model_class","text":"<pre><code>to_pydantic_model_class(model_class, **kwargs)\n</code></pre>  <p>Given a piccolo model_class instance, convert it to a subclass of the piccolo \"BaseModel\".</p> <p>Since incoming request body's cannot and should not include values for related fields, pk fields and read only fields in piccolo-orm, we generate two different kinds of pydantic models here: - the first is a regular pydantic model, and the other is for the \"data\" kwarg only, which is further sanitized.</p> <p>This function uses memoization to ensure we don't recompute unnecessarily.</p>"},{"location":"reference/plugins/3-tortoise-orm-plugin/","title":"TortoiseORM Plugin","text":""},{"location":"reference/plugins/3-tortoise-orm-plugin/#starlite.plugins.tortoise_orm.TortoiseORMPlugin","title":"starlite.plugins.tortoise_orm.TortoiseORMPlugin","text":"<p>         Bases: <code>PluginProtocol[Model]</code></p> <p>Support (de)serialization and OpenAPI generation for Tortoise ORMtypes.</p>"},{"location":"reference/plugins/3-tortoise-orm-plugin/#starlite.plugins.tortoise_orm.TortoiseORMPlugin.from_dict","title":"from_dict","text":"<pre><code>from_dict(model_class, **kwargs)\n</code></pre>  <p>Given a class supported by this plugin and a dict of values, create an instance of the class.</p>"},{"location":"reference/plugins/3-tortoise-orm-plugin/#starlite.plugins.tortoise_orm.TortoiseORMPlugin.from_pydantic_model_instance","title":"from_pydantic_model_instance","text":"<pre><code>from_pydantic_model_instance(model_class, pydantic_model_instance)\n</code></pre>  <p>Given an instance of a pydantic model created using the plugin's 'to_pydantic_model_class', return an instance of the class from which that pydantic model has been created.</p> <p>This class is passed in as the 'model_class' kwarg.</p>"},{"location":"reference/plugins/3-tortoise-orm-plugin/#starlite.plugins.tortoise_orm.TortoiseORMPlugin.is_plugin_supported_type","title":"is_plugin_supported_type  <code>staticmethod</code>","text":"<pre><code>is_plugin_supported_type(value)\n</code></pre>  <p>Given a value of indeterminate type, determine if this value is supported by the plugin.</p>"},{"location":"reference/plugins/3-tortoise-orm-plugin/#starlite.plugins.tortoise_orm.TortoiseORMPlugin.to_dict","title":"to_dict  <code>async</code>","text":"<pre><code>to_dict(model_instance)\n</code></pre>  <p>Given an instance of a model supported by the plugin, return a dictionary of serializable values.</p>"},{"location":"reference/plugins/3-tortoise-orm-plugin/#starlite.plugins.tortoise_orm.TortoiseORMPlugin.to_pydantic_model_class","title":"to_pydantic_model_class","text":"<pre><code>to_pydantic_model_class(model_class, **kwargs)\n</code></pre>  <p>Given a tortoise model_class instance, convert it to a subclass of the tortoise PydanticModel.</p> <p>Since incoming request body's cannot and should not include values for related fields, pk fields and read only fields in tortoise-orm, we generate two different kinds of pydantic models here: - the first is a regular pydantic model, and the other is for the \"data\" kwarg only, which is further sanitized.</p> <p>This function uses memoization to ensure we don't recompute unnecessarily.</p>"},{"location":"reference/response/0-base/","title":"Base HTTP Response","text":""},{"location":"reference/response/0-base/#starlite.response.Response","title":"starlite.response.Response","text":"<p>         Bases: <code>Generic[T]</code></p> <p>Base Starlite HTTP response class, used as the basis for all other response classes.</p>"},{"location":"reference/response/0-base/#starlite.response.base.Response.content_length","title":"content_length  <code>property</code>","text":"<pre><code>content_length: int\n</code></pre>  <p>Content length of the response if applicable.</p> <p>Returns:</p>    Type Description      <code>int</code>  <p>The content length of the body (e.g. for use in a \"Content-Length\" header).</p>    <code>int</code>  <p>If the response does not have a body, this value is <code>None</code></p>"},{"location":"reference/response/0-base/#starlite.response.base.Response.__init__","title":"__init__","text":"<pre><code>__init__(\n    content,\n    *,\n    status_code=HTTP_200_OK,\n    media_type=MediaType.JSON,\n    background=None,\n    headers=None,\n    cookies=None,\n    encoding=\"utf-8\",\n    is_head_response=False,\n    type_encoders=None\n)\n</code></pre>  <p>Initialize the response.</p> <p>Parameters:</p>    Name Type Description Default     <code>content</code>  <code>T</code>  <p>A value for the response body that will be rendered into bytes string.</p>  required    <code>status_code</code>  <code>int</code>  <p>An HTTP status code.</p>  <code>HTTP_200_OK</code>    <code>media_type</code>  <code>Union[MediaType, OpenAPIMediaType, str]</code>  <p>A value for the response 'Content-Type' header.</p>  <code>MediaType.JSON</code>    <code>background</code>  <code>Optional[Union[BackgroundTask, BackgroundTasks]]</code>  <p>A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None.</p>  <code>None</code>    <code>headers</code>  <code>Optional[Dict[str, Any]]</code>  <p>A string keyed dictionary of response headers. Header keys are insensitive.</p>  <code>None</code>    <code>cookies</code>  <code>Optional[ResponseCookies]</code>  <p>A list of Cookie instances to be set under the response 'Set-Cookie' header.</p>  <code>None</code>    <code>encoding</code>  <code>str</code>  <p>The encoding to be used for the response headers.</p>  <code>'utf-8'</code>    <code>is_head_response</code>  <code>bool</code>  <p>Whether the response should send only the headers (\"head\" request) or also the content.</p>  <code>False</code>    <code>type_encoders</code>  <code>Optional[TypeEncodersMap]</code>  <p>A mapping of types to callables that transform them into types supported for serialization.</p>  <code>None</code>"},{"location":"reference/response/0-base/#starlite.response.base.Response.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(scope, receive, send)\n</code></pre>  <p>ASGI callable of the <code>Response</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>scope</code>  <code>Scope</code>  <p>The ASGI connection scope.</p>  required    <code>receive</code>  <code>Receive</code>  <p>The ASGI receive function.</p>  required    <code>send</code>  <code>Send</code>  <p>The ASGI send function.</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/response/0-base/#starlite.response.base.Response.after_response","title":"after_response  <code>async</code>","text":"<pre><code>after_response()\n</code></pre>  <p>Execute after the response is sent.</p> <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/response/0-base/#starlite.response.base.Response.delete_cookie","title":"delete_cookie","text":"<pre><code>delete_cookie(key, path='/', domain=None)\n</code></pre>  <p>Delete a cookie.</p> <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>str</code>  <p>Key of the cookie.</p>  required    <code>path</code>  <code>str</code>  <p>Path of the cookie.</p>  <code>'/'</code>    <code>domain</code>  <code>Optional[str]</code>  <p>Domain of the cookie.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>None</code>  <p>None.</p>"},{"location":"reference/response/0-base/#starlite.response.base.Response.encode_headers","title":"encode_headers","text":"<pre><code>encode_headers()\n</code></pre>  <p>Encode the response headers as a list of byte tuples.</p>  Notes <ul> <li>A 'Content-Length' header will be added if appropriate and not provided by the user.</li> </ul>  <p>Returns:</p>    Type Description      <code>List[Tuple[bytes, bytes]]</code>  <p>A list of tuples containing the headers and cookies of the request in a format ready for ASGI transmission.</p>"},{"location":"reference/response/0-base/#starlite.response.base.Response.render","title":"render","text":"<pre><code>render(content)\n</code></pre>  <p>Handle the rendering of content T into a bytes string.</p> <p>Parameters:</p>    Name Type Description Default     <code>content</code>  <code>Any</code>  <p>A value for the response body that will be rendered into bytes string.</p>  required     <p>Returns:</p>    Type Description      <code>bytes</code>  <p>An encoded bytes string</p>"},{"location":"reference/response/0-base/#starlite.response.base.Response.send_body","title":"send_body  <code>async</code>","text":"<pre><code>send_body(send, receive)\n</code></pre>  <p>Emit the response body.</p> <p>Parameters:</p>    Name Type Description Default     <code>send</code>  <code>Send</code>  <p>The ASGI send function.</p>  required    <code>receive</code>  <code>Receive</code>  <p>The ASGI receive function.</p>  required      Notes <ul> <li>Response subclasses should customize this method if there is a need to customize sending data.</li> </ul>  <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/response/0-base/#starlite.response.base.Response.serializer","title":"serializer  <code>classmethod</code>","text":"<pre><code>serializer(value)\n</code></pre>  <p>Transform non-natively supported types into supported types.</p> <p>Should raise <code>TypeError</code> if a type cannot be transformed into a supported type</p>"},{"location":"reference/response/0-base/#starlite.response.base.Response.set_cookie","title":"set_cookie","text":"<pre><code>set_cookie(\n    key,\n    value=None,\n    max_age=None,\n    expires=None,\n    path=\"/\",\n    domain=None,\n    secure=False,\n    httponly=False,\n    samesite=\"lax\",\n)\n</code></pre>  <p>Set a cookie on the response. If passed a Cookie instance, keyword arguments will be ignored.</p> <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>Union[str, Cookie]</code>  <p>Key for the cookie or a Cookie instance.</p>  required    <code>value</code>  <code>Optional[str]</code>  <p>Value for the cookie, if none given defaults to empty string.</p>  <code>None</code>    <code>max_age</code>  <code>Optional[int]</code>  <p>Maximal age of the cookie before its invalidated.</p>  <code>None</code>    <code>expires</code>  <code>Optional[int]</code>  <p>Expiration date as unix MS timestamp.</p>  <code>None</code>    <code>path</code>  <code>str</code>  <p>Path fragment that must exist in the request url for the cookie to be valid. Defaults to '/'.</p>  <code>'/'</code>    <code>domain</code>  <code>Optional[str]</code>  <p>Domain for which the cookie is valid.</p>  <code>None</code>    <code>secure</code>  <code>bool</code>  <p>Https is required for the cookie.</p>  <code>False</code>    <code>httponly</code>  <code>bool</code>  <p>Forbids javascript to access the cookie via 'Document.cookie'.</p>  <code>False</code>    <code>samesite</code>  <code>Literal['lax', 'strict', 'none']</code>  <p>Controls whether a cookie is sent with cross-site requests. Defaults to 'lax'.</p>  <code>'lax'</code>     <p>Returns:</p>    Type Description      <code>None</code>  <p>None.</p>"},{"location":"reference/response/0-base/#starlite.response.base.Response.set_etag","title":"set_etag","text":"<pre><code>set_etag(etag)\n</code></pre>  <p>Set an etag header.</p> <p>Parameters:</p>    Name Type Description Default     <code>etag</code>  <code>Union[str, ETag]</code>  <p>An etag value.</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/response/0-base/#starlite.response.base.Response.set_header","title":"set_header","text":"<pre><code>set_header(key, value)\n</code></pre>  <p>Set a header on the response.</p> <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>str</code>  <p>Header key.</p>  required    <code>value</code>  <code>str</code>  <p>Header value.</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None.</p>"},{"location":"reference/response/0-base/#starlite.response.base.Response.start_response","title":"start_response  <code>async</code>","text":"<pre><code>start_response(send)\n</code></pre>  <p>Emit the start event of the response. This event includes the headers and status codes.</p> <p>Parameters:</p>    Name Type Description Default     <code>send</code>  <code>Send</code>  <p>The ASGI send function.</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/response/1-streaming/","title":"Streaming Response","text":""},{"location":"reference/response/1-streaming/#starlite.response.StreamingResponse","title":"starlite.response.StreamingResponse","text":"<p>         Bases: <code>Response[StreamType[Union[str, bytes]]]</code></p> <p>An HTTP response that streams the response data as a series of ASGI 'http.response.body' events.</p>"},{"location":"reference/response/1-streaming/#starlite.response.streaming.StreamingResponse.__init__","title":"__init__","text":"<pre><code>__init__(\n    content,\n    *,\n    status_code=HTTP_200_OK,\n    media_type=MediaType.JSON,\n    background=None,\n    headers=None,\n    cookies=None,\n    encoding=\"utf-8\",\n    is_head_response=False\n)\n</code></pre>  <p>Initialize the response.</p> <p>Parameters:</p>    Name Type Description Default     <code>content</code>  <code>StreamType[Union[str, bytes]]</code>  <p>A sync or async iterator or iterable.</p>  required    <code>status_code</code>  <code>int</code>  <p>An HTTP status code.</p>  <code>HTTP_200_OK</code>    <code>media_type</code>  <code>Union[MediaType, OpenAPIMediaType, str]</code>  <p>A value for the response 'Content-Type' header.</p>  <code>MediaType.JSON</code>    <code>background</code>  <code>Optional[Union[BackgroundTask, BackgroundTasks]]</code>  <p>A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None.</p>  <code>None</code>    <code>headers</code>  <code>Optional[Dict[str, Any]]</code>  <p>A string keyed dictionary of response headers. Header keys are insensitive.</p>  <code>None</code>    <code>cookies</code>  <code>Optional[ResponseCookies]</code>  <p>A list of Cookie instances to be set under the response 'Set-Cookie' header.</p>  <code>None</code>    <code>encoding</code>  <code>str</code>  <p>The encoding to be used for the response headers.</p>  <code>'utf-8'</code>    <code>is_head_response</code>  <code>bool</code>  <p>Whether the response should send only the headers (\"head\" request) or also the content.</p>  <code>False</code>"},{"location":"reference/response/1-streaming/#starlite.response.streaming.StreamingResponse.send_body","title":"send_body  <code>async</code>","text":"<pre><code>send_body(send, receive)\n</code></pre>  <p>Emit a stream of events correlating with the response body.</p> <p>Parameters:</p>    Name Type Description Default     <code>send</code>  <code>Send</code>  <p>The ASGI send function.</p>  required    <code>receive</code>  <code>Receive</code>  <p>The ASGI receive function.</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/response/2-file/","title":"File Response","text":""},{"location":"reference/response/2-file/#starlite.response.FileResponse","title":"starlite.response.FileResponse","text":"<p>         Bases: <code>StreamingResponse</code></p> <p>A response, streaming a file as response body.</p>"},{"location":"reference/response/2-file/#starlite.response.file.FileResponse.content_length","title":"content_length  <code>property</code>","text":"<pre><code>content_length: int\n</code></pre>  <p>Content length of the response if applicable.</p> <p>Returns:</p>    Type Description      <code>int</code>  <p>Returns the value of 'self.stat_result.st_size' to populate the 'Content-Length' header.</p>"},{"location":"reference/response/2-file/#starlite.response.file.FileResponse.__init__","title":"__init__","text":"<pre><code>__init__(\n    path,\n    *,\n    background=None,\n    chunk_size=ONE_MEGABYTE,\n    content_disposition_type=\"attachment\",\n    cookies=None,\n    encoding=\"utf-8\",\n    etag=None,\n    file_system=None,\n    filename=None,\n    file_info=None,\n    headers=None,\n    is_head_response=False,\n    media_type=None,\n    stat_result=None,\n    status_code=HTTP_200_OK\n)\n</code></pre>  <p>Initialize <code>FileResponse</code></p>  Notes <ul> <li>This class extends the StreamingResponse class.</li> </ul>  <p>Parameters:</p>    Name Type Description Default     <code>path</code>  <code>Union[str, PathLike, Path]</code>  <p>A file path in one of the supported formats.</p>  required    <code>status_code</code>  <code>int</code>  <p>An HTTP status code.</p>  <code>HTTP_200_OK</code>    <code>media_type</code>  <code>Optional[Union[Literal[MediaType.TEXT], str]]</code>  <p>A value for the response 'Content-Type' header. If not provided, the value will be either derived from the filename if provided and supported by the stdlib, or will default to 'application/octet-stream'.</p>  <code>None</code>    <code>background</code>  <code>Optional[Union[BackgroundTask, BackgroundTasks]]</code>  <p>A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None.</p>  <code>None</code>    <code>headers</code>  <code>Optional[Dict[str, Any]]</code>  <p>A string keyed dictionary of response headers. Header keys are insensitive.</p>  <code>None</code>    <code>cookies</code>  <code>Optional[ResponseCookies]</code>  <p>A list of Cookie instances to be set under the response 'Set-Cookie' header.</p>  <code>None</code>    <code>encoding</code>  <code>str</code>  <p>The encoding to be used for the response headers.</p>  <code>'utf-8'</code>    <code>is_head_response</code>  <code>bool</code>  <p>Whether the response should send only the headers (\"head\" request) or also the content.</p>  <code>False</code>    <code>filename</code>  <code>Optional[str]</code>  <p>An optional filename to set in the header.</p>  <code>None</code>    <code>stat_result</code>  <code>Optional[stat_result_type]</code>  <p>An optional result of calling 'os.stat'. If not provided, this will be done by the response constructor.</p>  <code>None</code>    <code>chunk_size</code>  <code>int</code>  <p>The chunk sizes to use when streaming the file. Defaults to 1MB.</p>  <code>ONE_MEGABYTE</code>    <code>content_disposition_type</code>  <code>Literal['attachment', 'inline']</code>  <p>The type of the 'Content-Disposition'. Either 'inline' or 'attachment'.</p>  <code>'attachment'</code>    <code>etag</code>  <code>Optional[ETag]</code>  <p>An optional ETag instance. If not provided, an etag will be automatically generated.</p>  <code>None</code>    <code>file_system</code>  <code>Optional[FileSystemProtocol]</code>  <p>An implementation of the `FileSystemProtocol. If provided it will be used to load the file.</p>  <code>None</code>    <code>file_info</code>  <code>Optional[FileInfo]</code>  <p>The output of calling <code>file_system.info(..)</code>, equivalent to providing a <code>stat_result</code>.</p>  <code>None</code>"},{"location":"reference/response/2-file/#starlite.response.file.FileResponse.send_body","title":"send_body  <code>async</code>","text":"<pre><code>send_body(send, receive)\n</code></pre>  <p>Emit a stream of events correlating with the response body.</p> <p>Parameters:</p>    Name Type Description Default     <code>send</code>  <code>Send</code>  <p>The ASGI send function.</p>  required    <code>receive</code>  <code>Receive</code>  <p>The ASGI receive function.</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/response/2-file/#starlite.response.file.FileResponse.start_response","title":"start_response  <code>async</code>","text":"<pre><code>start_response(send)\n</code></pre>  <p>Emit the start event of the response. This event includes the headers and status codes.</p> <p>Parameters:</p>    Name Type Description Default     <code>send</code>  <code>Send</code>  <p>The ASGI send function.</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/response/3-template/","title":"Template Response","text":""},{"location":"reference/response/3-template/#starlite.response.TemplateResponse","title":"starlite.response.TemplateResponse","text":"<p>         Bases: <code>Response[bytes]</code></p> <p>Template-based response, rendering a given template into a bytes string.</p>"},{"location":"reference/response/3-template/#starlite.response.template.TemplateResponse.__init__","title":"__init__","text":"<pre><code>__init__(\n    template_name,\n    *,\n    template_engine,\n    context,\n    status_code=HTTP_200_OK,\n    background=None,\n    headers=None,\n    cookies=None,\n    encoding=\"utf-8\",\n    media_type=MediaType.HTML\n)\n</code></pre>  <p>Handle the rendering of a given template into a bytes string.</p> <p>Parameters:</p>    Name Type Description Default     <code>template_name</code>  <code>str</code>  <p>Path-like name for the template to be rendered, e.g. \"index.html\".</p>  required    <code>template_engine</code>  <code>TemplateEngineProtocol</code>  <p>The template engine class to use to render the response.</p>  required    <code>status_code</code>  <code>int</code>  <p>A value for the response HTTP status code.</p>  <code>HTTP_200_OK</code>    <code>context</code>  <code>Dict[str, Any]</code>  <p>A dictionary of key/value pairs to be passed to the temple engine's render method.</p>  required    <code>background</code>  <code>Optional[Union[BackgroundTask, BackgroundTasks]]</code>  <p>A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None.</p>  <code>None</code>    <code>headers</code>  <code>Optional[Dict[str, Any]]</code>  <p>A string keyed dictionary of response headers. Header keys are insensitive.</p>  <code>None</code>    <code>cookies</code>  <code>Optional[ResponseCookies]</code>  <p>A list of Cookie instances to be set under the response 'Set-Cookie' header.</p>  <code>None</code>    <code>encoding</code>  <code>str</code>  <p>Content encoding</p>  <code>'utf-8'</code>    <code>media_type</code>  <code>Union[MediaType, str]</code>  <p>A string or member of the MediaType enum. If not set, try to infer the media type based on the template name. If this fails, fall back to <code>text/plain</code>.</p>  <code>MediaType.HTML</code>"},{"location":"reference/response/4-redirect/","title":"Redirect Response","text":""},{"location":"reference/response/4-redirect/#starlite.response.RedirectResponse","title":"starlite.response.RedirectResponse","text":"<p>         Bases: <code>Response[Any]</code></p> <p>A redirect response.</p>"},{"location":"reference/response/4-redirect/#starlite.response.redirect.RedirectResponse.__init__","title":"__init__","text":"<pre><code>__init__(\n    url,\n    *,\n    status_code=HTTP_307_TEMPORARY_REDIRECT,\n    background=None,\n    headers=None,\n    cookies=None,\n    encoding=\"utf-8\"\n)\n</code></pre>  <p>Initialize the response.</p> <p>Parameters:</p>    Name Type Description Default     <code>url</code>  <code>str</code>  <p>A url to redirect to.</p>  required    <code>status_code</code>  <code>Literal[301, 302, 303, 307, 308]</code>  <p>An HTTP status code. The status code should be one of 301, 302, 303, 307 or 308, otherwise an exception will be raised. .</p>  <code>HTTP_307_TEMPORARY_REDIRECT</code>    <code>headers</code>  <code>Optional[Dict[str, Any]]</code>  <p>A string keyed dictionary of response headers. Header keys are insensitive.</p>  <code>None</code>    <code>cookies</code>  <code>Optional[ResponseCookies]</code>  <p>A list of Cookie instances to be set under the response 'Set-Cookie' header.</p>  <code>None</code>    <code>encoding</code>  <code>str</code>  <p>The encoding to be used for the response headers.</p>  <code>'utf-8'</code>     <p>Raises:</p>    Type Description      <code>[ImproperlyConfiguredException][starlite.exceptions.ImproperlyConfiguredException]</code>  <p>If status code is not a redirect status code.</p>"},{"location":"reference/security/0-base/","title":"Security Config","text":""},{"location":"reference/security/0-base/#starlite.security.AbstractSecurityConfig","title":"starlite.security.AbstractSecurityConfig","text":"<p>         Bases: <code>ABC</code>, <code>Generic[UserType, AuthType]</code>, <code>GenericModel</code></p> <p>A base class for Security Configs - this class can be used on the application level or be manually configured on the router / controller level to provide auth.</p>"},{"location":"reference/security/0-base/#starlite.security.base.AbstractSecurityConfig.authentication_middleware_class","title":"authentication_middleware_class  <code>class-attribute</code>","text":"<pre><code>authentication_middleware_class: Type[AbstractAuthenticationMiddleware]\n</code></pre>  <p>The authentication middleware class to use.</p> <p>Must inherit from AbstractAuthenticationMiddleware</p>"},{"location":"reference/security/0-base/#starlite.security.base.AbstractSecurityConfig.dependencies","title":"dependencies  <code>class-attribute</code>","text":"<pre><code>dependencies: Optional[Dict[str, Provide]] = None\n</code></pre>  <p>An optional dictionary of dependency providers.</p>"},{"location":"reference/security/0-base/#starlite.security.base.AbstractSecurityConfig.exclude","title":"exclude  <code>class-attribute</code>","text":"<pre><code>exclude: Optional[Union[str, List[str]]] = None\n</code></pre>  <p>A pattern or list of patterns to skip in the authentication middleware.</p>"},{"location":"reference/security/0-base/#starlite.security.base.AbstractSecurityConfig.exclude_opt_key","title":"exclude_opt_key  <code>class-attribute</code>","text":"<pre><code>exclude_opt_key: str = 'exclude_from_auth'\n</code></pre>  <p>An identifier to use on routes to disable authentication and authorization checks for a particular route.</p>"},{"location":"reference/security/0-base/#starlite.security.base.AbstractSecurityConfig.guards","title":"guards  <code>class-attribute</code>","text":"<pre><code>guards: Optional[Iterable[Guard]] = None\n</code></pre>  <p>An iterable of guards to call for requests, providing authorization functionalities.</p>"},{"location":"reference/security/0-base/#starlite.security.base.AbstractSecurityConfig.middleware","title":"middleware  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>middleware: DefineMiddleware\n</code></pre>  <p>Create an instance of the config's 'authentication_middleware_class' attribute and any required kwargs, wrapping it in Starlite's <code>DefineMiddleware</code>.</p> <p>Returns:</p>    Type Description      <code>DefineMiddleware</code>  <p>An instance of DefineMiddleware.</p>"},{"location":"reference/security/0-base/#starlite.security.base.AbstractSecurityConfig.openapi_components","title":"openapi_components  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>openapi_components: Components\n</code></pre>  <p>Create OpenAPI documentation for the JWT auth schema used.</p> <p>Returns:</p>    Type Description      <code>Components</code>  <p>An Components instance.</p>"},{"location":"reference/security/0-base/#starlite.security.base.AbstractSecurityConfig.retrieve_user_handler","title":"retrieve_user_handler  <code>class-attribute</code>","text":"<pre><code>retrieve_user_handler: Callable[[Any, ASGIConnection], SyncOrAsyncUnion[Optional[Any]]]\n</code></pre>  <p>Callable that receives the 'auth' value from the authentication middleware and returns a 'user' value.</p> <p>Notes: - User and Auth can be any arbitrary values specified by the security backend. - The User and Auth values will be set by the middleware as <code>scope[\"user\"]</code> and <code>scope[\"auth\"]</code> respectively.     Once provided, they can access via the <code>connection.user</code> and <code>connection.auth</code> properties. - The callable can be sync or async. If it is sync, it will be wrapped to support async.</p>"},{"location":"reference/security/0-base/#starlite.security.base.AbstractSecurityConfig.route_handlers","title":"route_handlers  <code>class-attribute</code>","text":"<pre><code>route_handlers: Optional[Iterable[ControllerRouterHandler]] = None\n</code></pre>  <p>An optional iterable of route handlers to register.</p>"},{"location":"reference/security/0-base/#starlite.security.base.AbstractSecurityConfig.scopes","title":"scopes  <code>class-attribute</code>","text":"<pre><code>scopes: Optional[Scopes] = None\n</code></pre>  <p>ASGI scopes processed by the authentication middleware, if None both 'http' and 'websocket' will be processed.</p>"},{"location":"reference/security/0-base/#starlite.security.base.AbstractSecurityConfig.security_requirement","title":"security_requirement  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>security_requirement: SecurityRequirement\n</code></pre>  <p>Return OpenAPI 3.1.</p> <p>SecurityRequirement for the auth backend.</p> <p>Returns:</p>    Type Description      <code>SecurityRequirement</code>  <p>An OpenAPI 3.1 SecurityRequirement dictionary.</p>"},{"location":"reference/security/0-base/#starlite.security.base.AbstractSecurityConfig.on_app_init","title":"on_app_init","text":"<pre><code>on_app_init(app_config)\n</code></pre>  <p>Handle app init by injecting middleware, guards etc. into the app. This method can be used only on the app level.</p> <p>Parameters:</p>    Name Type Description Default     <code>app_config</code>  <code>AppConfig</code>  <p>An instance of AppConfig</p>  required     <p>Returns:</p>    Type Description      <code>AppConfig</code>  <p>The AppConfig.</p>"},{"location":"reference/security/1-session-auth/","title":"Session Auth","text":""},{"location":"reference/security/1-session-auth/#starlite.security.session_auth.SessionAuth","title":"starlite.security.session_auth.SessionAuth","text":"<p>         Bases: <code>Generic[UserType]</code>, <code>AbstractSecurityConfig[UserType, Dict[str, Any]]</code></p> <p>Session Based Security Backend.</p>"},{"location":"reference/security/1-session-auth/#starlite.security.session_auth.auth.SessionAuth.authentication_middleware_class","title":"authentication_middleware_class  <code>class-attribute</code>","text":"<pre><code>authentication_middleware_class: Type[SessionAuthMiddleware] = SessionAuthMiddleware\n</code></pre>  <p>The authentication middleware class to use.</p> <p>Must inherit from SessionAuthMiddleware</p>"},{"location":"reference/security/1-session-auth/#starlite.security.session_auth.auth.SessionAuth.middleware","title":"middleware  <code>property</code>","text":"<pre><code>middleware: DefineMiddleware\n</code></pre>  <p>Use this property to insert the config into a middleware list on one of the application layers.</p> <p>Examples:</p> <pre><code>from typing import Any\nfrom os import urandom\n\nfrom starlite import Starlite, Request, get\nfrom starlite_session import SessionAuth\n\n\nasync def retrieve_user_from_session(session: dict[str, Any]) -&gt; Any:\n    # implement logic here to retrieve a 'user' datum given the session dictionary\n    ...\n\n\nsession_auth_config = SessionAuth(\n    secret=urandom(16), retrieve_user_handler=retrieve_user_from_session\n)\n\n\n@get(\"/\")\ndef my_handler(request: Request) -&gt; None:\n    ...\n\n\napp = Starlite(route_handlers=[my_handler], middleware=[session_auth_config.middleware])\n</code></pre> <p>Returns:</p>    Type Description      <code>DefineMiddleware</code>  <p>An instance of DefineMiddleware including 'self' as the config kwarg value.</p>"},{"location":"reference/security/1-session-auth/#starlite.security.session_auth.auth.SessionAuth.openapi_components","title":"openapi_components  <code>property</code>","text":"<pre><code>openapi_components: Components\n</code></pre>  <p>Create OpenAPI documentation for the Session Authentication schema used.</p> <p>Returns:</p>    Type Description      <code>Components</code>  <p>An Components instance.</p>"},{"location":"reference/security/1-session-auth/#starlite.security.session_auth.auth.SessionAuth.security_requirement","title":"security_requirement  <code>property</code>","text":"<pre><code>security_requirement: SecurityRequirement\n</code></pre>  <p>Return OpenAPI 3.1.</p> <p>SecurityRequirement for the auth backend.</p> <p>Returns:</p>    Type Description      <code>SecurityRequirement</code>  <p>An OpenAPI 3.1 SecurityRequirement dictionary.</p>"},{"location":"reference/security/1-session-auth/#starlite.security.session_auth.middleware.SessionAuthMiddleware","title":"starlite.security.session_auth.middleware.SessionAuthMiddleware","text":"<p>         Bases: <code>AbstractAuthenticationMiddleware</code></p> <p>Session Authentication Middleware.</p>"},{"location":"reference/security/1-session-auth/#starlite.security.session_auth.middleware.SessionAuthMiddleware.__init__","title":"__init__","text":"<pre><code>__init__(app, exclude, exclude_opt_key, scopes, retrieve_user_handler)\n</code></pre>  <p>Session based authentication middleware.</p> <p>Parameters:</p>    Name Type Description Default     <code>app</code>  <code>ASGIApp</code>  <p>An ASGIApp, this value is the next ASGI handler to call in the middleware stack.</p>  required    <code>exclude</code>  <code>Optional[Union[str, List[str]]]</code>  <p>A pattern or list of patterns to skip in the authentication middleware.</p>  required    <code>exclude_opt_key</code>  <code>str</code>  <p>An identifier to use on routes to disable authentication and authorization checks for a particular route.</p>  required    <code>scopes</code>  <code>Optional[Scopes]</code>  <p>ASGI scopes processed by the authentication middleware.</p>  required    <code>retrieve_user_handler</code>  <code>AsyncCallable[[Dict[str, Any], ASGIConnection[Any, Any, Any]], Awaitable[Any]]</code>  <p>Callable that receives the 'session' value from the authentication middleware and returns a 'user' value.</p>  required"},{"location":"reference/template/base/","title":"Templating","text":""},{"location":"reference/template/base/#starlite.template.base.TemplateProtocol","title":"starlite.template.base.TemplateProtocol","text":"<p>         Bases: <code>Protocol</code></p> <p>Protocol Defining a 'Template'.</p> <p>Template is a class that has a render method which renders the template into a string.</p>"},{"location":"reference/template/base/#starlite.template.base.TemplateProtocol.render","title":"render","text":"<pre><code>render(*args, **kwargs)\n</code></pre>  <p>Return the rendered template as a string.</p> <p>Parameters:</p>    Name Type Description Default     <code>**kwargs</code>  <code>Any</code>  <p>A string keyed mapping of values passed to the TemplateEngine</p>  <code>{}</code>     <p>Returns:</p>    Type Description      <code>str</code>  <p>The rendered template string</p>"},{"location":"reference/template/base/#starlite.template.base.T_co","title":"starlite.template.base.T_co  <code>module-attribute</code>","text":"<pre><code>starlite.template.base.T_co = TypeVar('T_co', bound=TemplateProtocol, covariant=True)\n</code></pre>"},{"location":"reference/template/base/#starlite.template.base.TemplateEngineProtocol","title":"starlite.template.base.TemplateEngineProtocol","text":"<p>         Bases: <code>Protocol[T_co]</code></p> <p>Protocol for template engines.</p>"},{"location":"reference/template/base/#starlite.template.base.TemplateEngineProtocol.__init__","title":"__init__","text":"<pre><code>__init__(directory)\n</code></pre>  <p>Initialize the template engine with a directory.</p> <p>Parameters:</p>    Name Type Description Default     <code>directory</code>  <code>Union[DirectoryPath, List[DirectoryPath]]</code>  <p>Direct path or list of directory paths from which to serve templates.</p>  required"},{"location":"reference/template/base/#starlite.template.base.TemplateEngineProtocol.get_template","title":"get_template","text":"<pre><code>get_template(template_name)\n</code></pre>  <p>Retrieve a template by matching its name (dotted path) with files in the directory or directories provided.</p> <p>Parameters:</p>    Name Type Description Default     <code>template_name</code>  <code>str</code>  <p>A dotted path</p>  required     <p>Returns:</p>    Type Description      <code>T_co</code>  <p>Template instance</p>    <p>Raises:</p>    Type Description      <code>[TemplateNotFoundException][starlite.exceptions.TemplateNotFoundException]</code>  <p>if no template is found.</p>"},{"location":"reference/template/base/#starlite.template.base.TemplateEngineProtocol.register_template_callable","title":"register_template_callable","text":"<pre><code>register_template_callable(key, template_callable)\n</code></pre>  <p>Register a callable on the template engine.</p> <p>Parameters:</p>    Name Type Description Default     <code>key</code>  <code>str</code>  <p>The callable key, i.e. the value to use inside the template to call the callable.</p>  required    <code>template_callable</code>  <code>Callable[[Dict[str, Any]], Any]</code>  <p>A callable to register.</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/testing/0-test-client/","title":"Test Client","text":""},{"location":"reference/testing/0-test-client/#starlite.testing.TestClient","title":"starlite.testing.TestClient","text":"<p>         Bases: <code>Client</code>, <code>Generic[T]</code></p>"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.__init__","title":"__init__","text":"<pre><code>__init__(\n    app,\n    base_url=\"http://testserver.local\",\n    raise_server_exceptions=True,\n    root_path=\"\",\n    backend=\"asyncio\",\n    backend_options=None,\n    session_config=None,\n    cookies=None,\n)\n</code></pre>  <p>A client implementation providing a context manager for testing applications.</p> <p>Parameters:</p>    Name Type Description Default     <code>app</code>  <code>T</code>  <p>The instance of Starlite under test.</p>  required    <code>base_url</code>  <code>str</code>  <p>URL scheme and domain for test request paths, e.g. 'http://testserver'.</p>  <code>'http://testserver.local'</code>    <code>raise_server_exceptions</code>  <code>bool</code>  <p>Flag for the underlying test client to raise server exceptions instead of wrapping them in an HTTP response.</p>  <code>True</code>    <code>root_path</code>  <code>str</code>  <p>Path prefix for requests.</p>  <code>''</code>    <code>backend</code>  <code>AnyIOBackend</code>  <p>The async backend to use, options are \"asyncio\" or \"trio\".</p>  <code>'asyncio'</code>    <code>backend_options</code>  <code>Optional[Dict[str, Any]]</code>  <p>'anyio' options.</p>  <code>None</code>    <code>session_config</code>  <code>Optional[BaseBackendConfig]</code>  <p>Configuration for Session Middleware class to create raw session cookies for request to the route handlers.</p>  <code>None</code>    <code>cookies</code>  <code>Optional[CookieTypes]</code>  <p>Cookies to set on the client.</p>  <code>None</code>"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.__enter__","title":"__enter__","text":"<pre><code>__enter__()\n</code></pre>"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.request","title":"request","text":"<pre><code>request(\n    method,\n    url,\n    *,\n    content=None,\n    data=None,\n    files=None,\n    json=None,\n    params=None,\n    headers=None,\n    cookies=None,\n    auth=USE_CLIENT_DEFAULT,\n    follow_redirects=USE_CLIENT_DEFAULT,\n    timeout=USE_CLIENT_DEFAULT,\n    extensions=None\n)\n</code></pre>  <p>Sends a request.</p> <p>Parameters:</p>    Name Type Description Default     <code>method</code>  <code>str</code>  <p>An HTTP method.</p>  required    <code>url</code>  <code>URLTypes</code>  <p>URL or path for the request.</p>  required    <code>content</code>  <code>Optional[RequestContent]</code>  <p>Request content.</p>  <code>None</code>    <code>data</code>  <code>Optional[RequestData]</code>  <p>Form encoded data.</p>  <code>None</code>    <code>files</code>  <code>Optional[RequestFiles]</code>  <p>Multipart files to send.</p>  <code>None</code>    <code>json</code>  <code>Optional[Any]</code>  <p>JSON data to send.</p>  <code>None</code>    <code>params</code>  <code>Optional[QueryParamTypes]</code>  <p>Query parameters.</p>  <code>None</code>    <code>headers</code>  <code>Optional[HeaderTypes]</code>  <p>Request headers.</p>  <code>None</code>    <code>cookies</code>  <code>Optional[CookieTypes]</code>  <p>Request cookies.</p>  <code>None</code>    <code>auth</code>  <code>Optional[Union[AuthTypes, UseClientDefault]]</code>  <p>Auth headers.</p>  <code>USE_CLIENT_DEFAULT</code>    <code>follow_redirects</code>  <code>Union[bool, UseClientDefault]</code>  <p>Whether to follow redirects.</p>  <code>USE_CLIENT_DEFAULT</code>    <code>timeout</code>  <code>Union[TimeoutTypes, UseClientDefault]</code>  <p>Request timeout.</p>  <code>USE_CLIENT_DEFAULT</code>    <code>extensions</code>  <code>Optional[Mapping[str, Any]]</code>  <p>Dictionary of ASGI extensions.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>Response</code>  <p>An HTTPX Response.</p>"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.get","title":"get","text":"<pre><code>get(\n    url,\n    *,\n    params=None,\n    headers=None,\n    cookies=None,\n    auth=USE_CLIENT_DEFAULT,\n    follow_redirects=USE_CLIENT_DEFAULT,\n    timeout=USE_CLIENT_DEFAULT,\n    extensions=None\n)\n</code></pre>  <p>Sends a GET request.</p> <p>Parameters:</p>    Name Type Description Default     <code>url</code>  <code>URLTypes</code>  <p>URL or path for the request.</p>  required    <code>params</code>  <code>Optional[QueryParamTypes]</code>  <p>Query parameters.</p>  <code>None</code>    <code>headers</code>  <code>Optional[HeaderTypes]</code>  <p>Request headers.</p>  <code>None</code>    <code>cookies</code>  <code>Optional[CookieTypes]</code>  <p>Request cookies.</p>  <code>None</code>    <code>auth</code>  <code>Union[AuthTypes, UseClientDefault]</code>  <p>Auth headers.</p>  <code>USE_CLIENT_DEFAULT</code>    <code>follow_redirects</code>  <code>Union[bool, UseClientDefault]</code>  <p>Whether to follow redirects.</p>  <code>USE_CLIENT_DEFAULT</code>    <code>timeout</code>  <code>Union[TimeoutTypes, UseClientDefault]</code>  <p>Request timeout.</p>  <code>USE_CLIENT_DEFAULT</code>    <code>extensions</code>  <code>Optional[Mapping[str, Any]]</code>  <p>Dictionary of ASGI extensions.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>Response</code>  <p>An HTTPX Response.</p>"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.post","title":"post","text":"<pre><code>post(\n    url,\n    *,\n    content=None,\n    data=None,\n    files=None,\n    json=None,\n    params=None,\n    headers=None,\n    cookies=None,\n    auth=USE_CLIENT_DEFAULT,\n    follow_redirects=USE_CLIENT_DEFAULT,\n    timeout=USE_CLIENT_DEFAULT,\n    extensions=None\n)\n</code></pre>  <p>Sends a POST request.</p> <p>Parameters:</p>    Name Type Description Default     <code>url</code>  <code>URLTypes</code>  <p>URL or path for the request.</p>  required    <code>content</code>  <code>Optional[RequestContent]</code>  <p>Request content.</p>  <code>None</code>    <code>data</code>  <code>Optional[RequestData]</code>  <p>Form encoded data.</p>  <code>None</code>    <code>files</code>  <code>Optional[RequestFiles]</code>  <p>Multipart files to send.</p>  <code>None</code>    <code>json</code>  <code>Optional[Any]</code>  <p>JSON data to send.</p>  <code>None</code>    <code>params</code>  <code>Optional[QueryParamTypes]</code>  <p>Query parameters.</p>  <code>None</code>    <code>headers</code>  <code>Optional[HeaderTypes]</code>  <p>Request headers.</p>  <code>None</code>    <code>cookies</code>  <code>Optional[CookieTypes]</code>  <p>Request cookies.</p>  <code>None</code>    <code>auth</code>  <code>Union[AuthTypes, UseClientDefault]</code>  <p>Auth headers.</p>  <code>USE_CLIENT_DEFAULT</code>    <code>follow_redirects</code>  <code>Union[bool, UseClientDefault]</code>  <p>Whether to follow redirects.</p>  <code>USE_CLIENT_DEFAULT</code>    <code>timeout</code>  <code>Union[TimeoutTypes, UseClientDefault]</code>  <p>Request timeout.</p>  <code>USE_CLIENT_DEFAULT</code>    <code>extensions</code>  <code>Optional[Mapping[str, Any]]</code>  <p>Dictionary of ASGI extensions.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>Response</code>  <p>An HTTPX Response.</p>"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.patch","title":"patch","text":"<pre><code>patch(\n    url,\n    *,\n    content=None,\n    data=None,\n    files=None,\n    json=None,\n    params=None,\n    headers=None,\n    cookies=None,\n    auth=USE_CLIENT_DEFAULT,\n    follow_redirects=USE_CLIENT_DEFAULT,\n    timeout=USE_CLIENT_DEFAULT,\n    extensions=None\n)\n</code></pre>  <p>Sends a PATCH request.</p> <p>Parameters:</p>    Name Type Description Default     <code>url</code>  <code>URLTypes</code>  <p>URL or path for the request.</p>  required    <code>content</code>  <code>Optional[RequestContent]</code>  <p>Request content.</p>  <code>None</code>    <code>data</code>  <code>Optional[RequestData]</code>  <p>Form encoded data.</p>  <code>None</code>    <code>files</code>  <code>Optional[RequestFiles]</code>  <p>Multipart files to send.</p>  <code>None</code>    <code>json</code>  <code>Optional[Any]</code>  <p>JSON data to send.</p>  <code>None</code>    <code>params</code>  <code>Optional[QueryParamTypes]</code>  <p>Query parameters.</p>  <code>None</code>    <code>headers</code>  <code>Optional[HeaderTypes]</code>  <p>Request headers.</p>  <code>None</code>    <code>cookies</code>  <code>Optional[CookieTypes]</code>  <p>Request cookies.</p>  <code>None</code>    <code>auth</code>  <code>Union[AuthTypes, UseClientDefault]</code>  <p>Auth headers.</p>  <code>USE_CLIENT_DEFAULT</code>    <code>follow_redirects</code>  <code>Union[bool, UseClientDefault]</code>  <p>Whether to follow redirects.</p>  <code>USE_CLIENT_DEFAULT</code>    <code>timeout</code>  <code>Union[TimeoutTypes, UseClientDefault]</code>  <p>Request timeout.</p>  <code>USE_CLIENT_DEFAULT</code>    <code>extensions</code>  <code>Optional[Mapping[str, Any]]</code>  <p>Dictionary of ASGI extensions.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>Response</code>  <p>An HTTPX Response.</p>"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.put","title":"put","text":"<pre><code>put(\n    url,\n    *,\n    content=None,\n    data=None,\n    files=None,\n    json=None,\n    params=None,\n    headers=None,\n    cookies=None,\n    auth=USE_CLIENT_DEFAULT,\n    follow_redirects=USE_CLIENT_DEFAULT,\n    timeout=USE_CLIENT_DEFAULT,\n    extensions=None\n)\n</code></pre>  <p>Sends a PUT request.</p> <p>Parameters:</p>    Name Type Description Default     <code>url</code>  <code>URLTypes</code>  <p>URL or path for the request.</p>  required    <code>content</code>  <code>Optional[RequestContent]</code>  <p>Request content.</p>  <code>None</code>    <code>data</code>  <code>Optional[RequestData]</code>  <p>Form encoded data.</p>  <code>None</code>    <code>files</code>  <code>Optional[RequestFiles]</code>  <p>Multipart files to send.</p>  <code>None</code>    <code>json</code>  <code>Optional[Any]</code>  <p>JSON data to send.</p>  <code>None</code>    <code>params</code>  <code>Optional[QueryParamTypes]</code>  <p>Query parameters.</p>  <code>None</code>    <code>headers</code>  <code>Optional[HeaderTypes]</code>  <p>Request headers.</p>  <code>None</code>    <code>cookies</code>  <code>Optional[CookieTypes]</code>  <p>Request cookies.</p>  <code>None</code>    <code>auth</code>  <code>Union[AuthTypes, UseClientDefault]</code>  <p>Auth headers.</p>  <code>USE_CLIENT_DEFAULT</code>    <code>follow_redirects</code>  <code>Union[bool, UseClientDefault]</code>  <p>Whether to follow redirects.</p>  <code>USE_CLIENT_DEFAULT</code>    <code>timeout</code>  <code>Union[TimeoutTypes, UseClientDefault]</code>  <p>Request timeout.</p>  <code>USE_CLIENT_DEFAULT</code>    <code>extensions</code>  <code>Optional[Mapping[str, Any]]</code>  <p>Dictionary of ASGI extensions.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>Response</code>  <p>An HTTPX Response.</p>"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.delete","title":"delete","text":"<pre><code>delete(\n    url,\n    *,\n    params=None,\n    headers=None,\n    cookies=None,\n    auth=USE_CLIENT_DEFAULT,\n    follow_redirects=USE_CLIENT_DEFAULT,\n    timeout=USE_CLIENT_DEFAULT,\n    extensions=None\n)\n</code></pre>  <p>Sends a DELETE request.</p> <p>Parameters:</p>    Name Type Description Default     <code>url</code>  <code>URLTypes</code>  <p>URL or path for the request.</p>  required    <code>params</code>  <code>Optional[QueryParamTypes]</code>  <p>Query parameters.</p>  <code>None</code>    <code>headers</code>  <code>Optional[HeaderTypes]</code>  <p>Request headers.</p>  <code>None</code>    <code>cookies</code>  <code>Optional[CookieTypes]</code>  <p>Request cookies.</p>  <code>None</code>    <code>auth</code>  <code>Union[AuthTypes, UseClientDefault]</code>  <p>Auth headers.</p>  <code>USE_CLIENT_DEFAULT</code>    <code>follow_redirects</code>  <code>Union[bool, UseClientDefault]</code>  <p>Whether to follow redirects.</p>  <code>USE_CLIENT_DEFAULT</code>    <code>timeout</code>  <code>Union[TimeoutTypes, UseClientDefault]</code>  <p>Request timeout.</p>  <code>USE_CLIENT_DEFAULT</code>    <code>extensions</code>  <code>Optional[Mapping[str, Any]]</code>  <p>Dictionary of ASGI extensions.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>Response</code>  <p>An HTTPX Response.</p>"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.options","title":"options","text":"<pre><code>options(\n    url,\n    *,\n    params=None,\n    headers=None,\n    cookies=None,\n    auth=USE_CLIENT_DEFAULT,\n    follow_redirects=USE_CLIENT_DEFAULT,\n    timeout=USE_CLIENT_DEFAULT,\n    extensions=None\n)\n</code></pre>  <p>Sends an OPTIONS request.</p> <p>Parameters:</p>    Name Type Description Default     <code>url</code>  <code>URLTypes</code>  <p>URL or path for the request.</p>  required    <code>params</code>  <code>Optional[QueryParamTypes]</code>  <p>Query parameters.</p>  <code>None</code>    <code>headers</code>  <code>Optional[HeaderTypes]</code>  <p>Request headers.</p>  <code>None</code>    <code>cookies</code>  <code>Optional[CookieTypes]</code>  <p>Request cookies.</p>  <code>None</code>    <code>auth</code>  <code>Union[AuthTypes, UseClientDefault]</code>  <p>Auth headers.</p>  <code>USE_CLIENT_DEFAULT</code>    <code>follow_redirects</code>  <code>Union[bool, UseClientDefault]</code>  <p>Whether to follow redirects.</p>  <code>USE_CLIENT_DEFAULT</code>    <code>timeout</code>  <code>Union[TimeoutTypes, UseClientDefault]</code>  <p>Request timeout.</p>  <code>USE_CLIENT_DEFAULT</code>    <code>extensions</code>  <code>Optional[Mapping[str, Any]]</code>  <p>Dictionary of ASGI extensions.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>Response</code>  <p>An HTTPX Response.</p>"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.head","title":"head","text":"<pre><code>head(\n    url,\n    *,\n    params=None,\n    headers=None,\n    cookies=None,\n    auth=USE_CLIENT_DEFAULT,\n    follow_redirects=USE_CLIENT_DEFAULT,\n    timeout=USE_CLIENT_DEFAULT,\n    extensions=None\n)\n</code></pre>  <p>Sends a HEAD request.</p> <p>Parameters:</p>    Name Type Description Default     <code>url</code>  <code>URLTypes</code>  <p>URL or path for the request.</p>  required    <code>params</code>  <code>Optional[QueryParamTypes]</code>  <p>Query parameters.</p>  <code>None</code>    <code>headers</code>  <code>Optional[HeaderTypes]</code>  <p>Request headers.</p>  <code>None</code>    <code>cookies</code>  <code>Optional[CookieTypes]</code>  <p>Request cookies.</p>  <code>None</code>    <code>auth</code>  <code>Union[AuthTypes, UseClientDefault]</code>  <p>Auth headers.</p>  <code>USE_CLIENT_DEFAULT</code>    <code>follow_redirects</code>  <code>Union[bool, UseClientDefault]</code>  <p>Whether to follow redirects.</p>  <code>USE_CLIENT_DEFAULT</code>    <code>timeout</code>  <code>Union[TimeoutTypes, UseClientDefault]</code>  <p>Request timeout.</p>  <code>USE_CLIENT_DEFAULT</code>    <code>extensions</code>  <code>Optional[Mapping[str, Any]]</code>  <p>Dictionary of ASGI extensions.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>Response</code>  <p>An HTTPX Response.</p>"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.set_session_data","title":"set_session_data","text":"<pre><code>set_session_data(data)\n</code></pre>  <p>Set session data.</p> <p>Parameters:</p>    Name Type Description Default     <code>data</code>  <code>Dict[str, Any]</code>  <p>Session data</p>  required     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>    <p>Examples:</p> <pre><code>from starlite import Starlite, get\nfrom starlite.middleware.session.memory_backend import MemoryBackendConfig\n\nsession_config = MemoryBackendConfig()\n\n\n@get(path=\"/test\")\ndef get_session_data(request: Request) -&gt; Dict[str, Any]:\n    return request.session\n\n\napp = Starlite(\n    route_handlers=[get_session_data], middleware=[session_config.middleware]\n)\n\nwith TestClient(app=app, session_config=session_config) as client:\n    client.set_session_data({\"foo\": \"bar\"})\n    assert client.get(\"/test\").json() == {\"foo\": \"bar\"}\n</code></pre>"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.get_session_data","title":"get_session_data","text":"<pre><code>get_session_data()\n</code></pre>  <p>Get session data.</p> <p>Returns:</p>    Type Description      <code>Dict[str, Any]</code>  <p>A dictionary containing session data.</p>    <p>Examples:</p> <pre><code>from starlite import Starlite, post\nfrom starlite.middleware.session.memory_backend import MemoryBackendConfig\n\nsession_config = MemoryBackendConfig()\n\n\n@post(path=\"/test\")\ndef set_session_data(request: Request) -&gt; None:\n    request.session[\"foo\"] == \"bar\"\n\n\napp = Starlite(\n    route_handlers=[set_session_data], middleware=[session_config.middleware]\n)\n\nwith TestClient(app=app, session_config=session_config) as client:\n    client.post(\"/test\")\n    assert client.get_session_data() == {\"foo\": \"bar\"}\n</code></pre>"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.portal","title":"portal","text":"<pre><code>portal()\n</code></pre>  <p>Get a BlockingPortal.</p> <p>Returns:</p>    Type Description      <code>Generator[BlockingPortal, None, None]</code>  <p>A contextmanager for a BlockingPortal.</p>"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.WebSocketTestSession","title":"starlite.testing.test_client.WebSocketTestSession","text":""},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.websocket_test_session.WebSocketTestSession.close","title":"close","text":"<pre><code>close(code=WS_1000_NORMAL_CLOSURE)\n</code></pre>  <p>Sends an 'websocket.disconnect' event.</p> <p>Parameters:</p>    Name Type Description Default     <code>code</code>  <code>int</code>  <p>status code for closing the connection.</p>  <code>WS_1000_NORMAL_CLOSURE</code>     <p>Returns:</p>    Type Description      <code>None</code>  <p>None.</p>"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.websocket_test_session.WebSocketTestSession.receive","title":"receive","text":"<pre><code>receive()\n</code></pre>  <p>This is the base receive method.</p>  Notes <ul> <li>you can use one of the other receive methods to extract the data from the message.</li> </ul>  <p>Returns:</p>    Type Description      <code>WebSocketSendMessage</code>  <p>A websocket message.</p>"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.websocket_test_session.WebSocketTestSession.receive_bytes","title":"receive_bytes","text":"<pre><code>receive_bytes()\n</code></pre>  <p>Returns:</p>    Type Description      <code>bytes</code>  <p>A bytes string value.</p>"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.websocket_test_session.WebSocketTestSession.receive_json","title":"receive_json","text":"<pre><code>receive_json(mode='text')\n</code></pre>  <p>Receives JSON.</p> <p>Parameters:</p>    Name Type Description Default     <code>mode</code>  <code>Literal['text', 'binary']</code>  <p>Either 'text' or 'binary'</p>  <code>'text'</code>     <p>Returns:</p>    Type Description      <code>Any</code>  <p>An arbitrary value</p>"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.websocket_test_session.WebSocketTestSession.receive_text","title":"receive_text","text":"<pre><code>receive_text()\n</code></pre>  <p>Returns:</p>    Type Description      <code>str</code>  <p>A string value.</p>"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.websocket_test_session.WebSocketTestSession.send","title":"send","text":"<pre><code>send(data, mode='text', encoding='utf-8')\n</code></pre>  <p>Sends a \"receive\" event. This is the inverse of the ASGI send method.</p> <p>Parameters:</p>    Name Type Description Default     <code>data</code>  <code>Union[str, bytes]</code>  <p>Either a string or a byte string.</p>  required    <code>mode</code>  <code>Literal['text', 'binary']</code>  <p>The key to use - 'text' or 'bytes'</p>  <code>'text'</code>    <code>encoding</code>  <code>str</code>  <p>The encoding to use when encoding or decoding data.</p>  <code>'utf-8'</code>     <p>Returns:</p>    Type Description      <code>None</code>  <p>None.</p>"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.websocket_test_session.WebSocketTestSession.send_bytes","title":"send_bytes","text":"<pre><code>send_bytes(data, encoding='utf-8')\n</code></pre>  <p>Sends the data using the 'bytes' key.</p> <p>Parameters:</p>    Name Type Description Default     <code>data</code>  <code>bytes</code>  <p>Data to send.</p>  required    <code>encoding</code>  <code>str</code>  <p>Encoding to use.</p>  <code>'utf-8'</code>     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.websocket_test_session.WebSocketTestSession.send_json","title":"send_json","text":"<pre><code>send_json(data, mode='text')\n</code></pre>  <p>Sends the given data as JSON.</p> <p>Parameters:</p>    Name Type Description Default     <code>data</code>  <code>Any</code>  <p>The data to send.</p>  required    <code>mode</code>  <code>Literal['text', 'binary']</code>  <p>Either 'text' or 'binary'</p>  <code>'text'</code>     <p>Returns:</p>    Type Description      <code>None</code>  <p>None.</p>"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.websocket_test_session.WebSocketTestSession.send_text","title":"send_text","text":"<pre><code>send_text(data, encoding='utf-8')\n</code></pre>  <p>Sends the data using the 'text' key.</p> <p>Parameters:</p>    Name Type Description Default     <code>data</code>  <code>str</code>  <p>Data to send.</p>  required    <code>encoding</code>  <code>str</code>  <p>Encoding to use.</p>  <code>'utf-8'</code>     <p>Returns:</p>    Type Description      <code>None</code>  <p>None</p>"},{"location":"reference/testing/0-test-client/#starlite.testing.create_test_client","title":"<code>starlite.testing.create_test_client</code>","text":""},{"location":"reference/testing/1-request-factory/","title":"Request Factory","text":""},{"location":"reference/testing/1-request-factory/#starlite.testing.RequestFactory","title":"starlite.testing.RequestFactory","text":"<p>Factory to create Request instances.</p>"},{"location":"reference/testing/1-request-factory/#starlite.testing.request_factory.RequestFactory.__init__","title":"__init__","text":"<pre><code>__init__(app=None, server='test.org', port=3000, root_path='', scheme='http')\n</code></pre>  <p>Initialize <code>RequestFactory</code></p> <p>Parameters:</p>    Name Type Description Default     <code>app</code>  <code>Optional[Starlite]</code>  <p>An instance of Starlite to set as <code>request.scope[\"app\"]</code>.</p>  <code>None</code>    <code>server</code>  <code>str</code>  <p>The server's domain.</p>  <code>'test.org'</code>    <code>port</code>  <code>int</code>  <p>The server's port.</p>  <code>3000</code>    <code>root_path</code>  <code>str</code>  <p>Root path for the server.</p>  <code>''</code>    <code>scheme</code>  <code>str</code>  <p>Scheme for the server.</p>  <code>'http'</code>     <p>Examples:</p> <pre><code>from starlite import RequestEncodingType, Starlite, RequestFactory\n\nfrom tests import PersonFactory\n\nmy_app = Starlite(route_handlers=[])\nmy_server = \"starlite.org\"\n\n# Create a GET request\nquery_params = {\"id\": 1}\nget_user_request = RequestFactory(app=my_app, server=my_server).get(\n    \"/person\", query_params=query_params\n)\n\n# Create a POST request\nnew_person = PersonFactory.build()\ncreate_user_request = RequestFactory(app=my_app, server=my_server).post(\n    \"/person\", data=person\n)\n\n# Create a request with a special header\nheaders = {\"header1\": \"value1\"}\nrequest_with_header = RequestFactory(app=my_app, server=my_server).get(\n    \"/person\", query_params=query_params, headers=headers\n)\n\n# Create a request with a media type\nrequest_with_media_type = RequestFactory(app=my_app, server=my_server).post(\n    \"/person\", data=person, request_media_type=RequestEncodingType.MULTI_PART\n)\n</code></pre>"},{"location":"reference/testing/1-request-factory/#starlite.testing.request_factory.RequestFactory.get","title":"get","text":"<pre><code>get(\n    path=\"/\",\n    headers=None,\n    cookies=None,\n    session=None,\n    user=None,\n    auth=None,\n    query_params=None,\n    state=None,\n    path_params=None,\n    http_version=\"1.1\",\n    route_handler=None,\n)\n</code></pre>  <p>Create a GET Request instance.</p> <p>Parameters:</p>    Name Type Description Default     <code>path</code>  <code>str</code>  <p>The request's path.</p>  <code>'/'</code>    <code>headers</code>  <code>Optional[Dict[str, str]]</code>  <p>A dictionary of headers.</p>  <code>None</code>    <code>cookies</code>  <code>Optional[Union[List[Cookie], str]]</code>  <p>A string representing the cookie header or a list of \"Cookie\" instances. This value can include multiple cookies.</p>  <code>None</code>    <code>session</code>  <code>Optional[Dict[str, Any]]</code>  <p>A dictionary of session data.</p>  <code>None</code>    <code>user</code>  <code>Any</code>  <p>A value for <code>request.scope[\"user\"]</code>.</p>  <code>None</code>    <code>auth</code>  <code>Any</code>  <p>A value for <code>request.scope[\"auth\"]</code>.</p>  <code>None</code>    <code>query_params</code>  <code>Optional[Dict[str, Union[str, List[str]]]]</code>  <p>A dictionary of values from which the request's query will be generated.</p>  <code>None</code>    <code>state</code>  <code>Optional[Dict[str, Any]]</code>  <p>Arbitrary request state.</p>  <code>None</code>    <code>path_params</code>  <code>Optional[Dict[str, str]]</code>  <p>A string keyed dictionary of path parameter values.</p>  <code>None</code>    <code>http_version</code>  <code>Optional[str]</code>  <p>HTTP version. Defaults to \"1.1\".</p>  <code>'1.1'</code>    <code>route_handler</code>  <code>Optional[RouteHandlerType]</code>  <p>A route handler instance or method. If not provided a default handler is set.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>Request[Any, Any]</code>  <p>A Request instance</p>"},{"location":"reference/testing/1-request-factory/#starlite.testing.request_factory.RequestFactory.post","title":"post","text":"<pre><code>post(\n    path=\"/\",\n    headers=None,\n    cookies=None,\n    session=None,\n    user=None,\n    auth=None,\n    request_media_type=RequestEncodingType.JSON,\n    data=None,\n    query_params=None,\n    state=None,\n    path_params=None,\n    http_version=\"1.1\",\n    route_handler=None,\n)\n</code></pre>  <p>Create a POST Request instance.</p> <p>Parameters:</p>    Name Type Description Default     <code>path</code>  <code>str</code>  <p>The request's path.</p>  <code>'/'</code>    <code>headers</code>  <code>Optional[Dict[str, str]]</code>  <p>A dictionary of headers.</p>  <code>None</code>    <code>cookies</code>  <code>Optional[Union[List[Cookie], str]]</code>  <p>A string representing the cookie header or a list of \"Cookie\" instances. This value can include multiple cookies.</p>  <code>None</code>    <code>session</code>  <code>Optional[Dict[str, Any]]</code>  <p>A dictionary of session data.</p>  <code>None</code>    <code>user</code>  <code>Any</code>  <p>A value for <code>request.scope[\"user\"]</code>.</p>  <code>None</code>    <code>auth</code>  <code>Any</code>  <p>A value for <code>request.scope[\"auth\"]</code>.</p>  <code>None</code>    <code>request_media_type</code>  <code>RequestEncodingType</code>  <p>The 'Content-Type' header of the request.</p>  <code>RequestEncodingType.JSON</code>    <code>data</code>  <code>Optional[Union[Dict[str, Any], BaseModel]]</code>  <p>A value for the request's body. Can be either a pydantic model instance or a string keyed dictionary.</p>  <code>None</code>    <code>query_params</code>  <code>Optional[Dict[str, Union[str, List[str]]]]</code>  <p>A dictionary of values from which the request's query will be generated.</p>  <code>None</code>    <code>state</code>  <code>Optional[Dict[str, Any]]</code>  <p>Arbitrary request state.</p>  <code>None</code>    <code>path_params</code>  <code>Optional[Dict[str, str]]</code>  <p>A string keyed dictionary of path parameter values.</p>  <code>None</code>    <code>http_version</code>  <code>Optional[str]</code>  <p>HTTP version. Defaults to \"1.1\".</p>  <code>'1.1'</code>    <code>route_handler</code>  <code>Optional[RouteHandlerType]</code>  <p>A route handler instance or method. If not provided a default handler is set.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>Request[Any, Any]</code>  <p>A Request instance</p>"},{"location":"reference/testing/1-request-factory/#starlite.testing.request_factory.RequestFactory.put","title":"put","text":"<pre><code>put(\n    path=\"/\",\n    headers=None,\n    cookies=None,\n    session=None,\n    user=None,\n    auth=None,\n    request_media_type=RequestEncodingType.JSON,\n    data=None,\n    query_params=None,\n    state=None,\n    path_params=None,\n    http_version=\"1.1\",\n    route_handler=None,\n)\n</code></pre>  <p>Create a PUT Request instance.</p> <p>Parameters:</p>    Name Type Description Default     <code>path</code>  <code>str</code>  <p>The request's path.</p>  <code>'/'</code>    <code>headers</code>  <code>Optional[Dict[str, str]]</code>  <p>A dictionary of headers.</p>  <code>None</code>    <code>cookies</code>  <code>Optional[Union[List[Cookie], str]]</code>  <p>A string representing the cookie header or a list of \"Cookie\" instances. This value can include multiple cookies.</p>  <code>None</code>    <code>session</code>  <code>Optional[Dict[str, Any]]</code>  <p>A dictionary of session data.</p>  <code>None</code>    <code>user</code>  <code>Any</code>  <p>A value for <code>request.scope[\"user\"]</code>.</p>  <code>None</code>    <code>auth</code>  <code>Any</code>  <p>A value for <code>request.scope[\"auth\"]</code>.</p>  <code>None</code>    <code>request_media_type</code>  <code>RequestEncodingType</code>  <p>The 'Content-Type' header of the request.</p>  <code>RequestEncodingType.JSON</code>    <code>data</code>  <code>Optional[Union[Dict[str, Any], BaseModel]]</code>  <p>A value for the request's body. Can be either a pydantic model instance or a string keyed dictionary.</p>  <code>None</code>    <code>query_params</code>  <code>Optional[Dict[str, Union[str, List[str]]]]</code>  <p>A dictionary of values from which the request's query will be generated.</p>  <code>None</code>    <code>state</code>  <code>Optional[Dict[str, Any]]</code>  <p>Arbitrary request state.</p>  <code>None</code>    <code>path_params</code>  <code>Optional[Dict[str, str]]</code>  <p>A string keyed dictionary of path parameter values.</p>  <code>None</code>    <code>http_version</code>  <code>Optional[str]</code>  <p>HTTP version. Defaults to \"1.1\".</p>  <code>'1.1'</code>    <code>route_handler</code>  <code>Optional[RouteHandlerType]</code>  <p>A route handler instance or method. If not provided a default handler is set.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>Request[Any, Any]</code>  <p>A Request instance</p>"},{"location":"reference/testing/1-request-factory/#starlite.testing.request_factory.RequestFactory.patch","title":"patch","text":"<pre><code>patch(\n    path=\"/\",\n    headers=None,\n    cookies=None,\n    session=None,\n    user=None,\n    auth=None,\n    request_media_type=RequestEncodingType.JSON,\n    data=None,\n    query_params=None,\n    state=None,\n    path_params=None,\n    http_version=\"1.1\",\n    route_handler=None,\n)\n</code></pre>  <p>Create a PATCH Request instance.</p> <p>Parameters:</p>    Name Type Description Default     <code>path</code>  <code>str</code>  <p>The request's path.</p>  <code>'/'</code>    <code>headers</code>  <code>Optional[Dict[str, str]]</code>  <p>A dictionary of headers.</p>  <code>None</code>    <code>cookies</code>  <code>Optional[Union[List[Cookie], str]]</code>  <p>A string representing the cookie header or a list of \"Cookie\" instances. This value can include multiple cookies.</p>  <code>None</code>    <code>session</code>  <code>Optional[Dict[str, Any]]</code>  <p>A dictionary of session data.</p>  <code>None</code>    <code>user</code>  <code>Any</code>  <p>A value for <code>request.scope[\"user\"]</code>.</p>  <code>None</code>    <code>auth</code>  <code>Any</code>  <p>A value for <code>request.scope[\"auth\"]</code>.</p>  <code>None</code>    <code>request_media_type</code>  <code>RequestEncodingType</code>  <p>The 'Content-Type' header of the request.</p>  <code>RequestEncodingType.JSON</code>    <code>data</code>  <code>Optional[Union[Dict[str, Any], BaseModel]]</code>  <p>A value for the request's body. Can be either a pydantic model instance or a string keyed dictionary.</p>  <code>None</code>    <code>query_params</code>  <code>Optional[Dict[str, Union[str, List[str]]]]</code>  <p>A dictionary of values from which the request's query will be generated.</p>  <code>None</code>    <code>state</code>  <code>Optional[Dict[str, Any]]</code>  <p>Arbitrary request state.</p>  <code>None</code>    <code>path_params</code>  <code>Optional[Dict[str, str]]</code>  <p>A string keyed dictionary of path parameter values.</p>  <code>None</code>    <code>http_version</code>  <code>Optional[str]</code>  <p>HTTP version. Defaults to \"1.1\".</p>  <code>'1.1'</code>    <code>route_handler</code>  <code>Optional[RouteHandlerType]</code>  <p>A route handler instance or method. If not provided a default handler is set.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>Request[Any, Any]</code>  <p>A Request instance</p>"},{"location":"reference/testing/1-request-factory/#starlite.testing.request_factory.RequestFactory.delete","title":"delete","text":"<pre><code>delete(\n    path=\"/\",\n    headers=None,\n    cookies=None,\n    session=None,\n    user=None,\n    auth=None,\n    query_params=None,\n    state=None,\n    path_params=None,\n    http_version=\"1.1\",\n    route_handler=None,\n)\n</code></pre>  <p>Create a POST Request instance.</p> <p>Parameters:</p>    Name Type Description Default     <code>path</code>  <code>str</code>  <p>The request's path.</p>  <code>'/'</code>    <code>headers</code>  <code>Optional[Dict[str, str]]</code>  <p>A dictionary of headers.</p>  <code>None</code>    <code>cookies</code>  <code>Optional[Union[List[Cookie], str]]</code>  <p>A string representing the cookie header or a list of \"Cookie\" instances. This value can include multiple cookies.</p>  <code>None</code>    <code>session</code>  <code>Optional[Dict[str, Any]]</code>  <p>A dictionary of session data.</p>  <code>None</code>    <code>user</code>  <code>Any</code>  <p>A value for <code>request.scope[\"user\"]</code>.</p>  <code>None</code>    <code>auth</code>  <code>Any</code>  <p>A value for <code>request.scope[\"auth\"]</code>.</p>  <code>None</code>    <code>query_params</code>  <code>Optional[Dict[str, Union[str, List[str]]]]</code>  <p>A dictionary of values from which the request's query will be generated.</p>  <code>None</code>    <code>state</code>  <code>Optional[Dict[str, Any]]</code>  <p>Arbitrary request state.</p>  <code>None</code>    <code>path_params</code>  <code>Optional[Dict[str, str]]</code>  <p>A string keyed dictionary of path parameter values.</p>  <code>None</code>    <code>http_version</code>  <code>Optional[str]</code>  <p>HTTP version. Defaults to \"1.1\".</p>  <code>'1.1'</code>    <code>route_handler</code>  <code>Optional[RouteHandlerType]</code>  <p>A route handler instance or method. If not provided a default handler is set.</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>Request[Any, Any]</code>  <p>A Request instance</p>"},{"location":"reference/types/0-types-intro/","title":"Types","text":"<p>Starlite exports many types. Some types are meant for internal usage only, and are as such undocumented in this section.</p>"},{"location":"reference/types/1-callable-types/","title":"Callable Types","text":"<p>Callables types represent callables - functions, methods or classes that implement the <code>__call__</code> dunder method.</p>"},{"location":"reference/types/1-callable-types/#starlite.types.AfterExceptionHookHandler","title":"starlite.types.AfterExceptionHookHandler  <code>module-attribute</code>","text":"<pre><code>starlite.types.AfterExceptionHookHandler = Callable[\n    [Exception, Scope, State], SyncOrAsyncUnion[None]\n]\n</code></pre>"},{"location":"reference/types/1-callable-types/#starlite.types.AfterRequestHookHandler","title":"starlite.types.AfterRequestHookHandler  <code>module-attribute</code>","text":"<pre><code>starlite.types.AfterRequestHookHandler = Union[\n    Callable[[ASGIApp], SyncOrAsyncUnion[ASGIApp]], Callable[[Response], SyncOrAsyncUnion[Response]]\n]\n</code></pre>"},{"location":"reference/types/1-callable-types/#starlite.types.AfterResponseHookHandler","title":"starlite.types.AfterResponseHookHandler  <code>module-attribute</code>","text":"<pre><code>starlite.types.AfterResponseHookHandler = Callable[[Request], SyncOrAsyncUnion[None]]\n</code></pre>"},{"location":"reference/types/1-callable-types/#starlite.types.AnyCallable","title":"starlite.types.AnyCallable  <code>module-attribute</code>","text":"<pre><code>starlite.types.AnyCallable = Callable[Ellipsis, Any]\n</code></pre>"},{"location":"reference/types/1-callable-types/#starlite.types.AsyncAnyCallable","title":"starlite.types.AsyncAnyCallable  <code>module-attribute</code>","text":"<pre><code>starlite.types.AsyncAnyCallable = Callable[Ellipsis, Awaitable[Any]]\n</code></pre>"},{"location":"reference/types/1-callable-types/#starlite.types.BeforeMessageSendHookHandler","title":"starlite.types.BeforeMessageSendHookHandler  <code>module-attribute</code>","text":"<pre><code>starlite.types.BeforeMessageSendHookHandler = Union[\n    Callable[[Message, State, Scope], SyncOrAsyncUnion[None]],\n    Callable[[Message, State], SyncOrAsyncUnion[None]],\n]\n</code></pre>"},{"location":"reference/types/1-callable-types/#starlite.types.BeforeRequestHookHandler","title":"starlite.types.BeforeRequestHookHandler  <code>module-attribute</code>","text":"<pre><code>starlite.types.BeforeRequestHookHandler = Callable[[Request], Union[Any, Awaitable[Any]]]\n</code></pre>"},{"location":"reference/types/1-callable-types/#starlite.types.CacheKeyBuilder","title":"starlite.types.CacheKeyBuilder  <code>module-attribute</code>","text":"<pre><code>starlite.types.CacheKeyBuilder = Callable[[Request], str]\n</code></pre>"},{"location":"reference/types/1-callable-types/#starlite.types.ExceptionHandler","title":"starlite.types.ExceptionHandler  <code>module-attribute</code>","text":"<pre><code>starlite.types.ExceptionHandler = Callable[[Request, _ExceptionT], Response]\n</code></pre>"},{"location":"reference/types/1-callable-types/#starlite.types.Guard","title":"starlite.types.Guard  <code>module-attribute</code>","text":"<pre><code>starlite.types.Guard = Callable[[ASGIConnection, BaseRouteHandler], SyncOrAsyncUnion[None]]\n</code></pre>"},{"location":"reference/types/1-callable-types/#starlite.types.LifeSpanHandler","title":"starlite.types.LifeSpanHandler  <code>module-attribute</code>","text":"<pre><code>starlite.types.LifeSpanHandler = Union[\n    Callable[[], SyncOrAsyncUnion[Any]], Callable[[State], SyncOrAsyncUnion[Any]]\n]\n</code></pre>"},{"location":"reference/types/1-callable-types/#starlite.types.LifeSpanHookHandler","title":"starlite.types.LifeSpanHookHandler  <code>module-attribute</code>","text":"<pre><code>starlite.types.LifeSpanHookHandler = Callable[[StarliteType], SyncOrAsyncUnion[None]]\n</code></pre>"},{"location":"reference/types/1-callable-types/#starlite.types.OnAppInitHandler","title":"starlite.types.OnAppInitHandler  <code>module-attribute</code>","text":"<pre><code>starlite.types.OnAppInitHandler = Callable[[AppConfig], AppConfig]\n</code></pre>"},{"location":"reference/types/1-callable-types/#starlite.types.Serializer","title":"starlite.types.Serializer  <code>module-attribute</code>","text":"<pre><code>starlite.types.Serializer = Callable[[Any], Any]\n</code></pre>"},{"location":"reference/types/2-asgi-types/","title":"ASGI Types","text":""},{"location":"reference/types/2-asgi-types/#starlite.types.Method","title":"starlite.types.Method  <code>module-attribute</code>","text":"<pre><code>starlite.types.Method = Literal[\"GET\", \"POST\", \"DELETE\", \"PATCH\", \"PUT\", \"HEAD\", \"TRACE\", \"OPTIONS\"]\n</code></pre>"},{"location":"reference/types/2-asgi-types/#asgi-application","title":"ASGI Application","text":""},{"location":"reference/types/2-asgi-types/#starlite.types.ASGIApp","title":"starlite.types.ASGIApp  <code>module-attribute</code>","text":"<pre><code>starlite.types.ASGIApp = Callable[[Scope, Receive, Send], Awaitable[None]]\n</code></pre>"},{"location":"reference/types/2-asgi-types/#asgi-application-parameters","title":"ASGI Application Parameters","text":""},{"location":"reference/types/2-asgi-types/#starlite.types.Scope","title":"starlite.types.Scope  <code>module-attribute</code>","text":"<pre><code>starlite.types.Scope = Union[HTTPScope, WebSocketScope]\n</code></pre>"},{"location":"reference/types/2-asgi-types/#starlite.types.Receive","title":"starlite.types.Receive  <code>module-attribute</code>","text":"<pre><code>starlite.types.Receive = Callable[\n    Ellipsis, Awaitable[Union[HTTPReceiveMessage, WebSocketReceiveMessage]]\n]\n</code></pre>"},{"location":"reference/types/2-asgi-types/#starlite.types.Send","title":"starlite.types.Send  <code>module-attribute</code>","text":"<pre><code>starlite.types.Send = Callable[[Message], Awaitable[None]]\n</code></pre>"},{"location":"reference/types/2-asgi-types/#asgi-scopes","title":"ASGI Scopes","text":""},{"location":"reference/types/2-asgi-types/#starlite.types.ASGIVersion","title":"starlite.types.ASGIVersion","text":"<p>         Bases: <code>TypedDict</code></p> <p>ASGI spec version.</p>"},{"location":"reference/types/2-asgi-types/#starlite.types.BaseScope","title":"starlite.types.BaseScope","text":"<p>         Bases: <code>HeaderScope</code></p> <p>Base ASGI-scope.</p>"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketScope","title":"starlite.types.WebSocketScope","text":"<p>         Bases: <code>BaseScope</code></p> <p>WebSocket-ASGI-scope.</p>"},{"location":"reference/types/2-asgi-types/#starlite.types.HTTPScope","title":"starlite.types.HTTPScope","text":"<p>         Bases: <code>BaseScope</code></p> <p>HTTP-ASGI-scope.</p>"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanScope","title":"starlite.types.LifeSpanScope","text":"<p>         Bases: <code>TypedDict</code></p> <p>Lifespan-ASGI-scope.</p>"},{"location":"reference/types/2-asgi-types/#asgi-events","title":"ASGI Events","text":""},{"location":"reference/types/2-asgi-types/#starlite.types.HTTPRequestEvent","title":"starlite.types.HTTPRequestEvent","text":"<p>         Bases: <code>TypedDict</code></p> <p>ASGI <code>http.request</code> event.</p>"},{"location":"reference/types/2-asgi-types/#starlite.types.HTTPResponseStartEvent","title":"starlite.types.HTTPResponseStartEvent","text":"<p>         Bases: <code>HeaderScope</code></p> <p>ASGI <code>http.response.start</code> event.</p>"},{"location":"reference/types/2-asgi-types/#starlite.types.HTTPResponseBodyEvent","title":"starlite.types.HTTPResponseBodyEvent","text":"<p>         Bases: <code>TypedDict</code></p> <p>ASGI <code>http.response.body</code> event.</p>"},{"location":"reference/types/2-asgi-types/#starlite.types.HTTPServerPushEvent","title":"starlite.types.HTTPServerPushEvent","text":"<p>         Bases: <code>HeaderScope</code></p> <p>ASGI <code>http.response.push</code> event.</p>"},{"location":"reference/types/2-asgi-types/#starlite.types.HTTPDisconnectEvent","title":"starlite.types.HTTPDisconnectEvent","text":"<p>         Bases: <code>TypedDict</code></p> <p>ASGI <code>http.disconnect</code> event.</p>"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketConnectEvent","title":"starlite.types.WebSocketConnectEvent","text":"<p>         Bases: <code>TypedDict</code></p> <p>ASGI <code>websocket.connect</code> event.</p>"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketAcceptEvent","title":"starlite.types.WebSocketAcceptEvent","text":"<p>         Bases: <code>HeaderScope</code></p> <p>ASGI <code>websocket.accept</code> event.</p>"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketReceiveEvent","title":"starlite.types.WebSocketReceiveEvent","text":"<p>         Bases: <code>TypedDict</code></p> <p>ASGI <code>websocket.receive</code> event.</p>"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketSendEvent","title":"starlite.types.WebSocketSendEvent","text":"<p>         Bases: <code>TypedDict</code></p> <p>ASGI <code>websocket.send</code> event.</p>"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketResponseStartEvent","title":"starlite.types.WebSocketResponseStartEvent","text":"<p>         Bases: <code>HeaderScope</code></p> <p>ASGI <code>websocket.http.response.start</code> event.</p>"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketResponseBodyEvent","title":"starlite.types.WebSocketResponseBodyEvent","text":"<p>         Bases: <code>TypedDict</code></p> <p>ASGI <code>websocket.http.response.body</code> event.</p>"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketDisconnectEvent","title":"starlite.types.WebSocketDisconnectEvent","text":"<p>         Bases: <code>TypedDict</code></p> <p>ASGI <code>websocket.disconnect</code> event.</p>"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketCloseEvent","title":"starlite.types.WebSocketCloseEvent","text":"<p>         Bases: <code>TypedDict</code></p> <p>ASGI <code>websocket.close</code> event.</p>"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanStartupEvent","title":"starlite.types.LifeSpanStartupEvent","text":"<p>         Bases: <code>TypedDict</code></p> <p>ASGI <code>lifespan.startup</code> event.</p>"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanShutdownEvent","title":"starlite.types.LifeSpanShutdownEvent","text":"<p>         Bases: <code>TypedDict</code></p> <p>ASGI <code>lifespan.shutdown</code> event.</p>"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanStartupCompleteEvent","title":"starlite.types.LifeSpanStartupCompleteEvent","text":"<p>         Bases: <code>TypedDict</code></p> <p>ASGI <code>lifespan.startup.complete</code> event.</p>"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanStartupFailedEvent","title":"starlite.types.LifeSpanStartupFailedEvent","text":"<p>         Bases: <code>TypedDict</code></p> <p>ASGI <code>lifespan.startup.failed</code> event.</p>"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanShutdownCompleteEvent","title":"starlite.types.LifeSpanShutdownCompleteEvent","text":"<p>         Bases: <code>TypedDict</code></p> <p>ASGI <code>lifespan.shutdown.complete</code> event.</p>"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanShutdownFailedEvent","title":"starlite.types.LifeSpanShutdownFailedEvent","text":"<p>         Bases: <code>TypedDict</code></p> <p>ASGI <code>lifespan.shutdown.failed</code> event.</p>"},{"location":"reference/types/2-asgi-types/#event-groupings","title":"Event Groupings","text":""},{"location":"reference/types/2-asgi-types/#starlite.types.HTTPReceiveMessage","title":"starlite.types.HTTPReceiveMessage  <code>module-attribute</code>","text":"<pre><code>starlite.types.HTTPReceiveMessage = Union[HTTPRequestEvent, HTTPDisconnectEvent]\n</code></pre>"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketReceiveMessage","title":"starlite.types.WebSocketReceiveMessage  <code>module-attribute</code>","text":"<pre><code>starlite.types.WebSocketReceiveMessage = Union[\n    WebSocketConnectEvent, WebSocketReceiveEvent, WebSocketDisconnectEvent\n]\n</code></pre>"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanReceiveMessage","title":"starlite.types.LifeSpanReceiveMessage  <code>module-attribute</code>","text":"<pre><code>starlite.types.LifeSpanReceiveMessage = Union[LifeSpanStartupEvent, LifeSpanShutdownEvent]\n</code></pre>"},{"location":"reference/types/2-asgi-types/#starlite.types.HTTPSendMessage","title":"starlite.types.HTTPSendMessage  <code>module-attribute</code>","text":"<pre><code>starlite.types.HTTPSendMessage = Union[\n    HTTPResponseStartEvent, HTTPResponseBodyEvent, HTTPServerPushEvent, HTTPDisconnectEvent\n]\n</code></pre>"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketSendMessage","title":"starlite.types.WebSocketSendMessage  <code>module-attribute</code>","text":"<pre><code>starlite.types.WebSocketSendMessage = Union[\n    WebSocketAcceptEvent,\n    WebSocketSendEvent,\n    WebSocketResponseStartEvent,\n    WebSocketResponseBodyEvent,\n    WebSocketCloseEvent,\n]\n</code></pre>"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanSendMessage","title":"starlite.types.LifeSpanSendMessage  <code>module-attribute</code>","text":"<pre><code>starlite.types.LifeSpanSendMessage = Union[\n    LifeSpanStartupCompleteEvent,\n    LifeSpanStartupFailedEvent,\n    LifeSpanShutdownCompleteEvent,\n    LifeSpanShutdownFailedEvent,\n]\n</code></pre>"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanReceive","title":"starlite.types.LifeSpanReceive  <code>module-attribute</code>","text":"<pre><code>starlite.types.LifeSpanReceive = Callable[Ellipsis, Awaitable[LifeSpanReceiveMessage]]\n</code></pre>"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanSend","title":"starlite.types.LifeSpanSend  <code>module-attribute</code>","text":"<pre><code>starlite.types.LifeSpanSend = Callable[[LifeSpanSendMessage], Awaitable[None]]\n</code></pre>"},{"location":"reference/types/2-asgi-types/#send-receive-parameter-types","title":"Send / Receive Parameter Types","text":""},{"location":"reference/types/2-asgi-types/#starlite.types.Message","title":"starlite.types.Message  <code>module-attribute</code>","text":"<pre><code>starlite.types.Message = Union[HTTPSendMessage, WebSocketSendMessage]\n</code></pre>"},{"location":"reference/types/2-asgi-types/#starlite.types.ReceiveMessage","title":"starlite.types.ReceiveMessage  <code>module-attribute</code>","text":"<pre><code>starlite.types.ReceiveMessage = Union[HTTPReceiveMessage, WebSocketReceiveMessage]\n</code></pre>"},{"location":"reference/types/3-helper-types/","title":"Helper Types","text":"<p>Helper types are useful generic types that can be used.</p>"},{"location":"reference/types/3-helper-types/#starlite.types.SyncOrAsyncUnion","title":"starlite.types.SyncOrAsyncUnion  <code>module-attribute</code>","text":"<pre><code>starlite.types.SyncOrAsyncUnion = Union[T, Awaitable[T]]\n</code></pre>  <p>Types 'T' as a union of T and awaitable T.</p>"},{"location":"reference/types/3-helper-types/#starlite.types.SingleOrList","title":"starlite.types.SingleOrList  <code>module-attribute</code>","text":"<pre><code>starlite.types.SingleOrList = Union[T, List[T]]\n</code></pre>  <p>Types 'T' as a single value or a list T.</p>"},{"location":"reference/types/4-protocol-types/","title":"Protocols","text":""},{"location":"reference/types/4-protocol-types/#starlite.types.Logger","title":"starlite.types.Logger","text":"<p>         Bases: <code>Protocol</code></p> <p>Logger protocol.</p>"},{"location":"reference/types/5-composite-types/","title":"Composite Types","text":""},{"location":"reference/types/5-composite-types/#starlite.types.Dependencies","title":"starlite.types.Dependencies  <code>module-attribute</code>","text":"<pre><code>starlite.types.Dependencies = Dict[str, Provide]\n</code></pre>"},{"location":"reference/types/5-composite-types/#starlite.types.ExceptionHandlersMap","title":"starlite.types.ExceptionHandlersMap  <code>module-attribute</code>","text":"<pre><code>starlite.types.ExceptionHandlersMap = Dict[Union[int, Type[Exception]], ExceptionHandler]\n</code></pre>"},{"location":"reference/types/5-composite-types/#starlite.types.Middleware","title":"starlite.types.Middleware  <code>module-attribute</code>","text":"<pre><code>starlite.types.Middleware = Union[\n    Callable[Ellipsis, ASGIApp],\n    DefineMiddleware,\n    Iterator[Tuple[ASGIApp, Dict[str, Any]]],\n    Type[MiddlewareProtocol],\n]\n</code></pre>"},{"location":"reference/types/5-composite-types/#starlite.types.ResponseCookies","title":"starlite.types.ResponseCookies  <code>module-attribute</code>","text":"<pre><code>starlite.types.ResponseCookies = List[Cookie]\n</code></pre>"},{"location":"reference/types/5-composite-types/#starlite.types.ResponseHeadersMap","title":"starlite.types.ResponseHeadersMap  <code>module-attribute</code>","text":"<pre><code>starlite.types.ResponseHeadersMap = Dict[str, ResponseHeader]\n</code></pre>"},{"location":"reference/types/5-composite-types/#starlite.types.PathType","title":"starlite.types.PathType  <code>module-attribute</code>","text":"<pre><code>starlite.types.PathType = Union[Path, PathLike, str]\n</code></pre>"},{"location":"reference/types/6-partial-types/","title":"Partial","text":""},{"location":"reference/types/6-partial-types/#starlite.types.partial.T","title":"starlite.types.partial.T  <code>module-attribute</code>","text":"<pre><code>starlite.types.partial.T = TypeVar('T')\n</code></pre>"},{"location":"reference/types/6-partial-types/#starlite.types.partial.Partial","title":"starlite.types.partial.Partial","text":"<p>         Bases: <code>Generic[T]</code></p> <p>Type generation for PATCH routes.</p> <p>Partial is a special typing helper that takes a generic T, which must be a <code>TypedDict</code>, dataclass or pydantic model class, and returns to static type checkers a version of this T in which all fields - and nested fields - are optional.</p>"},{"location":"reference/types/7-file-types/","title":"File Types","text":""},{"location":"reference/types/7-file-types/#starlite.types.FileInfo","title":"starlite.types.FileInfo","text":"<p>         Bases: <code>TypedDict</code></p> <p>File information gathered from a file system.</p>"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileInfo.created","title":"created  <code>class-attribute</code>","text":"<pre><code>created: float\n</code></pre>  <p>Created time stamp, equal to 'stat_result.st_ctime'.</p>"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileInfo.destination","title":"destination  <code>class-attribute</code>","text":"<pre><code>destination: NotRequired[Optional[bytes]]\n</code></pre>  <p>Output of loading a symbolic link.</p>"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileInfo.gid","title":"gid  <code>class-attribute</code>","text":"<pre><code>gid: int\n</code></pre>  <p>Group ID of owner.</p>"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileInfo.ino","title":"ino  <code>class-attribute</code>","text":"<pre><code>ino: int\n</code></pre>  <p>inode value.</p>"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileInfo.islink","title":"islink  <code>class-attribute</code>","text":"<pre><code>islink: bool\n</code></pre>  <p>True if the file is a symbolic link.</p>"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileInfo.mode","title":"mode  <code>class-attribute</code>","text":"<pre><code>mode: int\n</code></pre>  <p>Protection mode.</p>"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileInfo.mtime","title":"mtime  <code>class-attribute</code>","text":"<pre><code>mtime: float\n</code></pre>  <p>Modified time stamp.</p>"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileInfo.name","title":"name  <code>class-attribute</code>","text":"<pre><code>name: str\n</code></pre>  <p>The path of the file.</p>"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileInfo.nlink","title":"nlink  <code>class-attribute</code>","text":"<pre><code>nlink: int\n</code></pre>  <p>Number of hard links.</p>"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileInfo.size","title":"size  <code>class-attribute</code>","text":"<pre><code>size: int\n</code></pre>  <p>Total size, in bytes.</p>"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileInfo.type","title":"type  <code>class-attribute</code>","text":"<pre><code>type: Literal['file', 'directory', 'other']\n</code></pre>  <p>The type of the file system object.</p>"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileInfo.uid","title":"uid  <code>class-attribute</code>","text":"<pre><code>uid: int\n</code></pre>  <p>User ID of owner.</p>"},{"location":"reference/types/7-file-types/#starlite.types.FileSystemProtocol","title":"starlite.types.FileSystemProtocol","text":"<p>         Bases: <code>Protocol</code></p> <p>Base protocol used to interact with a file-system.</p> <p>This protocol is commensurable with the file systems exported by the fsspec library.</p>"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileSystemProtocol.info","title":"info","text":"<pre><code>info(path, **kwargs)\n</code></pre>  <p>Retrieve information about a given file path.</p> <p>Parameters:</p>    Name Type Description Default     <code>path</code>  <code>PathType</code>  <p>A file path.</p>  required    <code>**kwargs</code>  <code>Any</code>  <p>Any additional kwargs.</p>  <code>{}</code>     <p>Returns:</p>    Type Description      <code>Union[FileInfo, Awaitable[FileInfo]]</code>  <p>A dictionary of file info.</p>"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileSystemProtocol.open","title":"open","text":"<pre><code>open(file, mode, buffering=-1)\n</code></pre>  <p>Return a file-like object from the filesystem.</p>  Notes <ul> <li>The return value must function correctly in a context <code>with</code> block.</li> </ul>  <p>Parameters:</p>    Name Type Description Default     <code>file</code>  <code>PathType</code>  <p>Path to the target file.</p>  required    <code>mode</code>  <code>str</code>  <p>Mode, similar to the built <code>open</code>.</p>  required    <code>buffering</code>  <code>int</code>  <p>Buffer size.</p>  <code>-1</code>"},{"location":"reference/utils/0-predicate-utils/","title":"Predicate Utils","text":""},{"location":"reference/utils/0-predicate-utils/#starlite.utils.predicates.P","title":"starlite.utils.predicates.P  <code>module-attribute</code>","text":"<pre><code>starlite.utils.predicates.P = ParamSpec('P')\n</code></pre>"},{"location":"reference/utils/0-predicate-utils/#starlite.utils.predicates.T","title":"starlite.utils.predicates.T  <code>module-attribute</code>","text":"<pre><code>starlite.utils.predicates.T = TypeVar('T')\n</code></pre>"},{"location":"reference/utils/0-predicate-utils/#starlite.utils.predicates.is_class_and_subclass","title":"starlite.utils.predicates.is_class_and_subclass","text":"<pre><code>starlite.utils.predicates.is_class_and_subclass(value, t_type)\n</code></pre>  <p>Return <code>True</code> if <code>value</code> is a <code>class</code> and is a subtype of <code>t_type</code>.</p> <p>See https://github.com/starlite-api/starlite/issues/367</p> <p>Parameters:</p>    Name Type Description Default     <code>value</code>  <code>Any</code>  <p>The value to check if is class and subclass of <code>t_type</code>.</p>  required    <code>t_type</code>  <code>Type[T]</code>  <p>Type used for <code>issubclass()</code> check of <code>value</code></p>  required     <p>Returns:</p>    Type Description      <code>TypeGuard[Type[T]]</code>  <p>bool</p>"},{"location":"reference/utils/0-predicate-utils/#starlite.utils.predicates.is_dataclass_class_or_instance_typeguard","title":"starlite.utils.predicates.is_dataclass_class_or_instance_typeguard","text":"<pre><code>starlite.utils.predicates.is_dataclass_class_or_instance_typeguard(value)\n</code></pre>  <p>Wrap <code>is_dataclass()</code> in a <code>TypeGuard</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>value</code>  <code>Any</code>  <p>tested to determine if instance or type of <code>dataclass</code>.</p>  required     <p>Returns:</p>    Type Description      <code>TypeGuard[DataclassClassOrInstance]</code>  <p><code>True</code> if instance or type of <code>dataclass</code>.</p>"},{"location":"reference/utils/0-predicate-utils/#starlite.utils.predicates.is_dataclass_class_typeguard","title":"starlite.utils.predicates.is_dataclass_class_typeguard","text":"<pre><code>starlite.utils.predicates.is_dataclass_class_typeguard(value)\n</code></pre>  <p>Wrap <code>is_dataclass()</code> in a <code>TypeGuard</code>, narrowing to type only, not instance.</p> <p>Parameters:</p>    Name Type Description Default     <code>value</code>  <code>Any</code>  <p>tested to determine if type of <code>dataclass</code>.</p>  required     <p>Returns:</p>    Type Description      <code>TypeGuard[DataclassClass]</code>  <p><code>True</code> if <code>value</code> is a <code>dataclass</code> type.</p>"},{"location":"reference/utils/0-predicate-utils/#starlite.utils.predicates.is_optional_union","title":"starlite.utils.predicates.is_optional_union","text":"<pre><code>starlite.utils.predicates.is_optional_union(annotation)\n</code></pre>  <p>Given a type annotation determine if the annotation infers an optional union.</p> <p>Parameters:</p>    Name Type Description Default     <code>annotation</code>  <code>Any</code>  <p>A type.</p>  required     <p>Returns:</p>    Type Description      <code>bool</code>  <p>True for a union, False otherwise.</p>"},{"location":"reference/utils/0-predicate-utils/#starlite.utils.predicates.is_typeddict_typeguard","title":"starlite.utils.predicates.is_typeddict_typeguard","text":"<pre><code>starlite.utils.predicates.is_typeddict_typeguard(value)\n</code></pre>  <p>Wrap <code>is_typeddict()</code> in a <code>TypeGuard</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>value</code>  <code>Any</code>  <p>tested to determine if instance or type of <code>dataclass</code>.</p>  required     <p>Returns:</p>    Type Description      <code>TypeGuard[TypedDictClass]</code>  <p><code>True</code> if instance or type of <code>dataclass</code>.</p>"},{"location":"reference/utils/1-sync-utils/","title":"Async Utils","text":""},{"location":"reference/utils/1-sync-utils/#starlite.utils.sync.P","title":"starlite.utils.sync.P  <code>module-attribute</code>","text":"<pre><code>starlite.utils.sync.P = ParamSpec('P')\n</code></pre>"},{"location":"reference/utils/1-sync-utils/#starlite.utils.sync.T","title":"starlite.utils.sync.T  <code>module-attribute</code>","text":"<pre><code>starlite.utils.sync.T = TypeVar('T')\n</code></pre>"},{"location":"reference/utils/1-sync-utils/#starlite.utils.is_async_callable","title":"starlite.utils.is_async_callable","text":"<pre><code>starlite.utils.is_async_callable(value)\n</code></pre>  <p>Extend <code>asyncio.iscoroutinefunction()</code> to additionally detect async <code>partial</code> objects and class instances with <code>async def __call__()</code> defined.</p> <p>Parameters:</p>    Name Type Description Default     <code>value</code>  <code>Callable[P, T]</code>  <p>Any</p>  required     <p>Returns:</p>    Type Description      <code>TypeGuard[Callable[P, Awaitable[T]]]</code>  <p>Bool determining if type of <code>value</code> is an awaitable.</p>"},{"location":"reference/utils/1-sync-utils/#starlite.utils.AsyncCallable","title":"starlite.utils.AsyncCallable","text":"<p>         Bases: <code>Generic[P, T]</code></p> <p>Wrap a callable into an asynchronous callable.</p>"},{"location":"reference/utils/1-sync-utils/#starlite.utils.sync.AsyncCallable.__init__","title":"__init__","text":"<pre><code>__init__(fn)\n</code></pre>  <p>Initialize the wrapper from any callable.</p> <p>Parameters:</p>    Name Type Description Default     <code>fn</code>  <code>Callable[P, T]</code>  <p>Callable to wrap - can be any sync or async callable.</p>  required"},{"location":"reference/utils/1-sync-utils/#starlite.utils.sync.AsyncCallable.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__(*args, **kwargs)\n</code></pre>  <p>Proxy the wrapped function's call method.</p> <p>Parameters:</p>    Name Type Description Default     <code>*args</code>  <code>P.args</code>  <p>Args of the wrapped function.</p>  <code>()</code>    <code>**kwargs</code>  <code>P.kwargs</code>  <p>Kwargs of the wrapper function.</p>  <code>{}</code>     <p>Returns:</p>    Type Description      <code>T</code>  <p>The return value of the wrapped function.</p>"},{"location":"reference/utils/1-sync-utils/#starlite.utils.as_async_callable_list","title":"starlite.utils.as_async_callable_list","text":"<pre><code>starlite.utils.as_async_callable_list(value)\n</code></pre>  <p>Wrap callables in <code>AsyncCallable</code>s.</p> <p>Parameters:</p>    Name Type Description Default     <code>value</code>  <code>Union[Callable, List[Callable]]</code>  <p>A callable or list of callables.</p>  required     <p>Returns:</p>    Type Description      <code>List[AsyncCallable]</code>  <p>A list of AsyncCallable instances</p>"},{"location":"reference/utils/1-sync-utils/#starlite.utils.async_partial","title":"starlite.utils.async_partial","text":"<pre><code>starlite.utils.async_partial(fn)\n</code></pre>  <p>Wrap a given sync function making it async.</p> <p>In difference to the 'asyncio.run_sync' function, it allows for passing kwargs.</p> <p>Parameters:</p>    Name Type Description Default     <code>fn</code>  <code>Callable</code>  <p>A sync callable to wrap.</p>  required     <p>Returns:</p>    Type Description      <code>Callable</code>  <p>A wrapper</p>"},{"location":"reference/utils/1-sync-utils/#starlite.utils.AsyncIteratorWrapper","title":"starlite.utils.AsyncIteratorWrapper","text":"<p>         Bases: <code>Generic[T]</code></p> <p>Asynchronous generator, wrapping an iterable or iterator.</p>"},{"location":"reference/utils/1-sync-utils/#starlite.utils.sync.AsyncIteratorWrapper.__init__","title":"__init__","text":"<pre><code>__init__(iterator)\n</code></pre>  <p>Take a sync iterator or iterable and yields values from it asynchronously.</p> <p>Parameters:</p>    Name Type Description Default     <code>iterator</code>  <code>Union[Iterator[T], Iterable[T]]</code>  <p>A sync iterator or iterable.</p>  required"},{"location":"reference/utils/2-scope-utils/","title":"Scope Utils","text":""},{"location":"reference/utils/2-scope-utils/#starlite.utils.get_serializer_from_scope","title":"starlite.utils.get_serializer_from_scope","text":"<pre><code>starlite.utils.get_serializer_from_scope(scope)\n</code></pre>  <p>Return a serializer given a scope object.</p> <p>Parameters:</p>    Name Type Description Default     <code>scope</code>  <code>Scope</code>  <p>The ASGI connection scope.</p>  required     <p>Returns:</p>    Type Description      <code>Optional[Serializer]</code>  <p>A serializer function</p>"},{"location":"reference/utils/3-exception-utils/","title":"Exception Utils","text":""},{"location":"reference/utils/3-exception-utils/#starlite.utils.get_exception_handler","title":"starlite.utils.get_exception_handler","text":"<pre><code>starlite.utils.get_exception_handler(exception_handlers, exc)\n</code></pre>  <p>Given a dictionary that maps exceptions and status codes to handler functions, and an exception, returns the appropriate handler if existing.</p> <p>Status codes are given preference over exception type.</p> <p>If no status code match exists, each class in the MRO of the exception type is checked and the first matching handler is returned.</p> <p>Finally, if a <code>500</code> handler is registered, it will be returned for any exception that isn't a subclass of <code>HTTPException</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>exception_handlers</code>  <code>ExceptionHandlersMap</code>  <p>Mapping of status codes and exception types to handlers.</p>  required    <code>exc</code>  <code>Exception</code>  <p>Exception Instance to be resolved to a handler.</p>  required     <p>Returns:</p>    Type Description      <code>Optional[ExceptionHandler]</code>  <p>Optional exception handler callable.</p>"},{"location":"reference/utils/3-exception-utils/#starlite.utils.ExceptionResponseContent","title":"starlite.utils.ExceptionResponseContent","text":"<p>         Bases: <code>BaseModel</code></p> <p>Represent the contents of an exception-response.</p>"},{"location":"reference/utils/3-exception-utils/#starlite.utils.create_exception_response","title":"starlite.utils.create_exception_response","text":"<pre><code>starlite.utils.create_exception_response(exc)\n</code></pre>  <p>Construct a response from an exception.</p> <p>Notes: - For instances of HTTPException or other exception classes that have a     <code>status_code</code> attribute (e.g. Starlette exceptions), the status code is drawn from the exception, otherwise     response status is <code>HTTP_500_INTERNAL_SERVER_ERROR</code>.</p> <p>Parameters:</p>    Name Type Description Default     <code>exc</code>  <code>Exception</code>  <p>An exception.</p>  required     <p>Returns:</p>    Name Type Description     <code>Response</code>  <code>Response</code>  <p>HTTP response constructed from exception details.</p>"},{"location":"reference/utils/4-extractor-utils/","title":"Extraction Utils","text":""},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.ResponseExtractorField","title":"starlite.utils.extractors.ResponseExtractorField  <code>module-attribute</code>","text":"<pre><code>starlite.utils.extractors.ResponseExtractorField = Literal[\n    \"status_code\", \"headers\", \"body\", \"cookies\"\n]\n</code></pre>"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.ConnectionDataExtractor","title":"starlite.utils.extractors.ConnectionDataExtractor","text":"<p>Utility class to extract data from an.</p> <p>ASGIConnection, Request or WebSocket instance.</p>"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.ConnectionDataExtractor.__init__","title":"__init__","text":"<pre><code>__init__(\n    extract_body=True,\n    extract_client=True,\n    extract_content_type=True,\n    extract_cookies=True,\n    extract_headers=True,\n    extract_method=True,\n    extract_path=True,\n    extract_path_params=True,\n    extract_query=True,\n    extract_scheme=True,\n    obfuscate_cookies=None,\n    obfuscate_headers=None,\n    parse_body=False,\n    parse_query=False,\n)\n</code></pre>  <p>Initialize <code>ConnectionDataExtractor</code></p> <p>Parameters:</p>    Name Type Description Default     <code>extract_body</code>  <code>bool</code>  <p>Whether to extract body, (for requests only).</p>  <code>True</code>    <code>extract_client</code>  <code>bool</code>  <p>Whether to extract the client (host, port) mapping.</p>  <code>True</code>    <code>extract_content_type</code>  <code>bool</code>  <p>Whether to extract the content type and any options.</p>  <code>True</code>    <code>extract_cookies</code>  <code>bool</code>  <p>Whether to extract cookies.</p>  <code>True</code>    <code>extract_headers</code>  <code>bool</code>  <p>Whether to extract headers.</p>  <code>True</code>    <code>extract_method</code>  <code>bool</code>  <p>Whether to extract the HTTP method, (for requests only).</p>  <code>True</code>    <code>extract_path</code>  <code>bool</code>  <p>Whether to extract the path.</p>  <code>True</code>    <code>extract_path_params</code>  <code>bool</code>  <p>Whether to extract path parameters.</p>  <code>True</code>    <code>extract_query</code>  <code>bool</code>  <p>Whether to extract query parameters.</p>  <code>True</code>    <code>extract_scheme</code>  <code>bool</code>  <p>Whether to extract the http scheme.</p>  <code>True</code>    <code>obfuscate_headers</code>  <code>Optional[Set[str]]</code>  <p>headers keys to obfuscate. Obfuscated values are replaced with '*'.</p>  <code>None</code>    <code>obfuscate_cookies</code>  <code>Optional[Set[str]]</code>  <p>cookie keys to obfuscate. Obfuscated values are replaced with '*'.</p>  <code>None</code>    <code>parse_body</code>  <code>bool</code>  <p>Whether to parse the body value or return the raw byte string, (for requests only).</p>  <code>False</code>    <code>parse_query</code>  <code>bool</code>  <p>Whether to parse query parameters or return the raw byte string.</p>  <code>False</code>"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.ConnectionDataExtractor.__call__","title":"__call__","text":"<pre><code>__call__(connection)\n</code></pre>  <p>Extract data from the connection, returning a dictionary of values.</p>  Notes <ul> <li>The value for 'body' - if present - is an unresolved Coroutine and as such should be awaited by the receiver.</li> </ul>  <p>Parameters:</p>    Name Type Description Default     <code>connection</code>  <code>ASGIConnection[Any, Any, Any]</code>  <p>An ASGI connection or its subclasses.</p>  required     <p>Returns:</p>    Type Description      <code>ExtractedRequestData</code>  <p>A string keyed dictionary of extracted values.</p>"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.ExtractedResponseData","title":"starlite.utils.extractors.ExtractedResponseData","text":"<p>         Bases: <code>TypedDict</code></p> <p>Dictionary representing extracted response data.</p>"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.ResponseExtractorField","title":"starlite.utils.extractors.ResponseExtractorField  <code>module-attribute</code>","text":"<pre><code>starlite.utils.extractors.ResponseExtractorField = Literal[\n    \"status_code\", \"headers\", \"body\", \"cookies\"\n]\n</code></pre>"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.RequestExtractorField","title":"starlite.utils.extractors.RequestExtractorField  <code>module-attribute</code>","text":"<pre><code>starlite.utils.extractors.RequestExtractorField = Literal[\n    \"path\",\n    \"method\",\n    \"content_type\",\n    \"headers\",\n    \"cookies\",\n    \"query\",\n    \"path_params\",\n    \"body\",\n    \"scheme\",\n    \"client\",\n]\n</code></pre>"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.ExtractedRequestData","title":"starlite.utils.extractors.ExtractedRequestData","text":"<p>         Bases: <code>TypedDict</code></p> <p>Dictionary representing extracted request data.</p>"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.obfuscate","title":"starlite.utils.extractors.obfuscate","text":"<pre><code>starlite.utils.extractors.obfuscate(values, fields_to_obfuscate)\n</code></pre>  <p>Obfuscate values in a dictionary, replacing values with <code>******</code></p> <p>Parameters:</p>    Name Type Description Default     <code>values</code>  <code>Dict[str, Any]</code>  <p>A dictionary of strings</p>  required    <code>fields_to_obfuscate</code>  <code>Set[str]</code>  <p>keys to obfuscate</p>  required     <p>Returns:</p>    Type Description      <code>Dict[str, Any]</code>  <p>A dictionary with obfuscated strings</p>"},{"location":"reference/utils/5-sequence-utils/","title":"Sequence Utils","text":""},{"location":"reference/utils/5-sequence-utils/#starlite.utils.sequence.T","title":"starlite.utils.sequence.T  <code>module-attribute</code>","text":"<pre><code>starlite.utils.sequence.T = TypeVar('T')\n</code></pre>"},{"location":"reference/utils/5-sequence-utils/#starlite.utils.find_index","title":"starlite.utils.find_index","text":"<pre><code>starlite.utils.find_index(target_list, predicate)\n</code></pre>  <p>Find element in list given a key and value.</p> <p>List elements can be dicts or classes</p>"},{"location":"reference/utils/5-sequence-utils/#starlite.utils.unique","title":"starlite.utils.unique","text":"<pre><code>starlite.utils.unique(value)\n</code></pre>  <p>Return all unique values in a given sequence or iterator.</p>"},{"location":"reference/utils/6-path-utils/","title":"Path Utils","text":""},{"location":"reference/utils/6-path-utils/#starlite.utils.normalize_path","title":"starlite.utils.normalize_path","text":"<pre><code>starlite.utils.normalize_path(path)\n</code></pre>  <p>Normalize a given path by ensuring it starts with a slash and does not end with a slash.</p> <p>Parameters:</p>    Name Type Description Default     <code>path</code>  <code>str</code>  <p>Path string</p>  required     <p>Returns:</p>    Type Description      <code>str</code>  <p>Path string</p>"},{"location":"reference/utils/6-path-utils/#starlite.utils.join_paths","title":"starlite.utils.join_paths","text":"<pre><code>starlite.utils.join_paths(paths)\n</code></pre>  <p>Normalize and joins path fragments.</p> <p>Parameters:</p>    Name Type Description Default     <code>paths</code>  <code>Iterable[str]</code>  <p>An iterable of path fragments.</p>  required     <p>Returns:</p>    Type Description      <code>str</code>  <p>A normalized joined path string.</p>"},{"location":"reference/utils/7-serialization-utils/","title":"Serialization Utils","text":""},{"location":"reference/utils/7-serialization-utils/#starlite.utils.default_serializer","title":"starlite.utils.default_serializer","text":"<pre><code>starlite.utils.default_serializer(value, type_encoders=None)\n</code></pre>  <p>Transform values non-natively supported by <code>msgspec</code></p> <p>Parameters:</p>    Name Type Description Default     <code>value</code>  <code>Any</code>  <p>A value to serialize#</p>  required    <code>type_encoders</code>  <code>Optional[Dict[Any, Callable[[Any], Any]]]</code>  <p>Mapping of types to callables to transforming types</p>  <code>None</code>     <p>Returns:</p>    Type Description      <code>Any</code>  <p>A serialized value</p>    <p>Raises:</p>    Type Description      <code>TypeError</code>  <p>if value is not supported</p>"},{"location":"usage/0-the-starlite-app/","title":"The Starlite App","text":""},{"location":"usage/0-the-starlite-app/#application-object","title":"Application object","text":"<p>At the root of every Starlite application is an instance of the <code>Starlite</code> class. Typically, this code will be placed in a file called <code>main.py</code> at the project's root directory.</p> <p>Creating an app is straightforward \u2013 the only required arg is a list of Controllers, Routers or Route Handlers:</p> Python 3.8+Python 3.9+   Hello World<pre><code>from typing import Dict\n\nfrom starlite import Starlite, get\n\n\n@get(\"/\")\ndef hello_world() -&gt; Dict[str, str]:\n    \"\"\"Handler function that returns a greeting dictionary.\"\"\"\n    return {\"hello\": \"world\"}\n\n\napp = Starlite(route_handlers=[hello_world])\n</code></pre>   Hello World<pre><code>from starlite import Starlite, get\n\n\n@get(\"/\")\ndef hello_world() -&gt; dict[str, str]:\n    \"\"\"Handler function that returns a greeting dictionary.\"\"\"\n    return {\"hello\": \"world\"}\n\n\napp = Starlite(route_handlers=[hello_world])\n</code></pre>     <p>Run it</p> <pre><code>&gt; curl http://127.0.0.1:8000/\n{\"hello\":\"world\"}\n</code></pre>  <p>The app instance is the root level of the app - it has the base path of <code>/</code> and all root level Controllers, Routers and Route Handlers should be registered on it.</p>  <p>Learn more</p> <p>To learn more about registering routes, check out this chapter in the documentation: registering routes</p> <p>See the API Reference for details on the <code>Starlite</code> class and the kwargs it accepts.</p>"},{"location":"usage/0-the-starlite-app/#startup-and-shutdown","title":"Startup and Shutdown","text":"<p>You can pass a list of callables - either sync or async functions, methods or class instances - to the <code>on_startup</code> / <code>on_shutdown</code> kwargs of the Starlite instance. Those will be called in order, once the ASGI server (uvicorn, daphne etc.) emits the respective event.</p> <pre><code>flowchart LR\n    Startup[ASGI-Event: lifespan.startup] --&gt; before_startup --&gt; on_startup --&gt; after_startup\n    Shutdown[ASGI-Event: lifespan.shutdown] --&gt; before_shutdown --&gt; on_shutdown --&gt; after_shutdown</code></pre> <p>A classic use case for this is database connectivity. Often, we want to establish a database connection on application startup, and then close it gracefully upon shutdown.</p> <p>For example, lets create a database connection using the async engine from SQLAlchemy. We create two functions, one to get or establish the connection, and another to close it, and then pass them to the Starlite constructor:</p> Startup and Shutdown<pre><code>from typing import cast\n\nfrom pydantic import BaseSettings\nfrom sqlalchemy.ext.asyncio import AsyncEngine, create_async_engine\n\nfrom starlite import Starlite, State\n\n\nclass AppSettings(BaseSettings):\n    DATABASE_URI: str = \"postgresql+asyncpg://postgres:mysecretpassword@pg.db:5432/db\"\n\n\nsettings = AppSettings()\n\n\ndef get_db_connection(state: State) -&gt; AsyncEngine:\n    \"\"\"Returns the db engine.\n\n    If it doesn't exist, creates it and saves it in on the application state object\n    \"\"\"\n    if not getattr(state, \"engine\", None):\n        state.engine = create_async_engine(settings.DATABASE_URI)\n    return cast(\"AsyncEngine\", state.engine)\n\n\nasync def close_db_connection(state: State) -&gt; None:\n    \"\"\"Closes the db connection stored in the application State object.\"\"\"\n    if getattr(state, \"engine\", None):\n        await cast(\"AsyncEngine\", state.engine).dispose()\n\n\napp = Starlite(route_handlers=[], on_startup=[get_db_connection], on_shutdown=[close_db_connection])\n</code></pre>"},{"location":"usage/0-the-starlite-app/#using-application-state","title":"Using Application State","text":"<p>As seen in the examples for the on_startup / on_shutdown, callables passed to these hooks can receive an optional kwarg called <code>state</code>, which is the application's state object.</p>  <p>The advantage of using application <code>state</code>, is that it can be accessed during multiple stages of the connection, and it can be injected into dependencies and route handlers.</p> <p>The Application State is an instance of the <code>State</code> datastructure, and it is accessible via the <code>app.state</code> attribute. As such it can be accessed wherever the app instance is accessible.</p> <p>It's important to understand in this context that the application instance is injected into the ASGI <code>scope</code> mapping for each connection (i.e. request or websocket connection) as <code>scope[\"app\"].state</code>. This makes the application accessible wherever the scope mapping is available, e.g. in middleware, on <code>Request</code> and <code>Websocket</code> instances (accessible as <code>request.app</code> / <code>socket.app</code>) and many other places.</p> <p>Therefore, state offers an easy way to share contextual data between disparate parts of the application, as seen below:</p> Using Application State<pre><code>import logging\nfrom typing import TYPE_CHECKING, Any\n\nfrom starlite import Provide, Request, Starlite, State, get\n\nif TYPE_CHECKING:\n    from starlite.types import ASGIApp, Receive, Scope, Send\n\nlogger = logging.getLogger(__name__)\n\n\ndef set_state_on_startup(state: State) -&gt; None:\n    \"\"\"Startup and shutdown hooks can receive `State` as a keyword arg.\"\"\"\n    state.value = \"abc123\"\n\n\ndef middleware_factory(*, app: \"ASGIApp\") -&gt; \"ASGIApp\":\n    \"\"\"A middleware can access application state via `scope`.\"\"\"\n\n    async def my_middleware(scope: \"Scope\", receive: \"Receive\", send: \"Send\") -&gt; None:\n        state = scope[\"app\"].state\n        logger.info(\"state value in middleware: %s\", state.value)\n        await app(scope, receive, send)\n\n    return my_middleware\n\n\ndef my_dependency(state: State) -&gt; Any:\n    \"\"\"Dependencies can receive state via injection.\"\"\"\n    logger.info(\"state value in dependency: %s\", state.value)\n\n\n@get(\"/\", dependencies={\"dep\": Provide(my_dependency)}, middleware=[middleware_factory])\ndef get_handler(state: State, request: Request, dep: Any) -&gt; None:  # pylint: disable=unused-argument\n    \"\"\"Handlers can receive state via injection.\"\"\"\n    logger.info(\"state value in handler from `State`: %s\", state.value)\n    logger.info(\"state value in handler from `Request`: %s\", request.app.state.value)\n\n\napp = Starlite(route_handlers=[get_handler], on_startup=[set_state_on_startup], debug=True)\n</code></pre>"},{"location":"usage/0-the-starlite-app/#initializing-application-state","title":"Initializing Application State","text":"<p>You can pass an object from which the application state will be instantiated using the <code>initial_state</code> kwarg of the Starlite constructor:</p> Using Application State<pre><code>from starlite import Starlite, State, get\n\n\n@get(\"/\")\ndef handler(state: State) -&gt; dict:\n    return state.dict()\n\n\napp = Starlite(route_handlers=[handler], initial_state={\"count\": 100})\n</code></pre>  <p>Note</p> <p>The <code>initial_state</code> can be a dictionary, an instance of <code>ImmutableState</code> or <code>State</code>, or a list of tuples containing key/value pairs.</p>   <p>Important</p> <p>Any value passed to <code>initial_state</code> will be deep copied - to prevent mutation from outside the application context.</p>"},{"location":"usage/0-the-starlite-app/#injecting-application-state-into-route-handlers-and-dependencies","title":"Injecting Application State into Route Handlers and Dependencies","text":"<p>As seen in the above example, Starlite offers an easy way to inject state into route handlers and dependencies - simply by specifying <code>state</code> as a kwarg to the handler function. I.e., you can simply do this in handler function or dependency to access the application state:</p> <pre><code>from starlite import get, State\n\n\n@get(\"/\")\ndef handler(state: State) -&gt; None:\n    ...\n</code></pre> <p>When using this pattern you can specify the class to use for the state object. This type is not merely for type checkers, rather Starlite will instantiate a new state instance based on the type you set there. This allows users to use custom classes for State, e.g.:</p> <p>While this is very powerful, it might encourage users to follow anti-patterns: it's important to emphasize that using state can lead to code that's hard to reason about and bugs that are difficult to understand, due to changes in different ASGI contexts. As such, this pattern should be used only when it is the best choice and in a limited fashion. To discourage its use, Starlite also offers a builtin <code>ImmutableState</code> class. You can use this class to type state and ensure that no mutation of state is allowed:</p> Using Custom State<pre><code>from starlite import ImmutableState, Starlite, get\n\n\n@get(\"/\")\ndef handler(state: ImmutableState) -&gt; dict:\n    setattr(state, \"count\", 1)  # raises AttributeError\n    return state.dict()\n\n\napp = Starlite(route_handlers=[handler])\n</code></pre>"},{"location":"usage/0-the-starlite-app/#static-files","title":"Static Files","text":"<p>Static files are served by the app from predefined locations. To configure static file serving, either pass an instance of <code>StaticFilesConfig</code> or a list thereof to the Starlite constructor using the <code>static_files_config</code> kwarg.</p> <p>For example, lets say our Starlite app is going to serve regular files from the <code>my_app/static</code> folder and html documents from the <code>my_app/html</code> folder, and we would like to serve the static files on the <code>/files</code> path, and the html files on the <code>/html</code> path:</p> <pre><code>from starlite import Starlite, StaticFilesConfig\n\napp = Starlite(\n    route_handlers=[...],\n    static_files_config=[\n        StaticFilesConfig(directories=[\"static\"], path=\"/files\"),\n        StaticFilesConfig(directories=[\"html\"], path=\"/html\", html_mode=True),\n    ],\n)\n</code></pre> <p>Matching is done based on filename, for example, assume we have a request that is trying to retrieve the path <code>/files/file.txt</code>, the directory for the base path <code>/files</code> will be searched for the file <code>file.txt</code>. If it is found, the file will be sent, otherwise a 404 response will be sent.</p> <p>If <code>html_mode</code> is enabled and no specific file is requested, the application will fall back to serving <code>index.html</code>. If no file is found the application will look for a <code>404.html</code> file in order to render a response, otherwise a 404 <code>NotFoundException</code> will be returned.</p> <p>You can provide a <code>name</code> parameter to <code>StaticFilesConfig</code> to identify the given config and generate links to files in folders belonging to that config. <code>name</code> should be a unique string across all static configs and route handlers.</p> <pre><code>from starlite import Starlite, StaticFilesConfig\n\napp = Starlite(\n    route_handlers=[...],\n    static_files_config=[\n        StaticFilesConfig(\n            directories=[\"static\"], path=\"/some_folder/static/path\", name=\"static\"\n        ),\n    ],\n)\n\nurl_path = app.url_for_static_asset(\"static\", \"file.pdf\")\n# /some_folder/static/path/file.pdf\n</code></pre>"},{"location":"usage/0-the-starlite-app/#sending-files-as-attachments","title":"Sending files as attachments","text":"<p>By default, files are sent \"inline\", meaning they will have a <code>Content-Disposition: inline</code> header. To send them as attachments, use the <code>send_as_attachment=True</code> flag, which will add a <code>Content-Disposition: attachment</code> header:</p> <pre><code>from starlite import Starlite, StaticFilesConfig\n\napp = Starlite(\n    route_handlers=[...],\n    static_files_config=[\n        StaticFilesConfig(\n            directories=[\"static\"],\n            path=\"/some_folder/static/path\",\n            name=\"static\",\n            send_as_attachment=True,\n        ),\n    ],\n)\n</code></pre>"},{"location":"usage/0-the-starlite-app/#file-system-support-and-cloud-files","title":"File System support and Cloud Files","text":"<p>The <code>StaticFilesConfig</code> class accepts a value called <code>file_system</code>, which can be any class adhering to the Starlite <code>FileSystemProtocol</code>.</p> <p>This protocol is similar to the file systems defined by fsspec, which cover all major cloud providers and a wide range of other use cases (e.g. HTTP based file service, <code>ftp</code> etc.).</p> <p>In order to use any file system, simply use fsspec or one of the libraries based upon it, or provide a custom implementation adhering to the <code>FileSystemProtocol</code>.</p>"},{"location":"usage/0-the-starlite-app/#logging","title":"Logging","text":"<p>Starlite has builtin pydantic based logging configuration that allows users to easily define logging:</p> <pre><code>from starlite import Starlite, LoggingConfig, Request, get\n\n\n@get(\"/\")\ndef my_router_handler(request: Request) -&gt; None:\n    request.logger.info(\"inside a request\")\n    return None\n\n\nlogging_config = LoggingConfig(\n    loggers={\n        \"my_app\": {\n            \"level\": \"INFO\",\n            \"handlers\": [\"queue_listener\"],\n        }\n    }\n)\n\napp = Starlite(route_handlers=[my_router_handler], logging_config=logging_config)\n</code></pre>  <p>Important</p> <p>Starlite configures a non-blocking <code>QueueListenerHandler</code> which is keyed as <code>queue_listener</code> in the logging configuration. The above example is using this handler, which is optimal for async applications. Make sure to use it in your own loggers as in the above example.</p>"},{"location":"usage/0-the-starlite-app/#using-picologging","title":"Using Picologging","text":"<p>Picologging is a high performance logging library that is developed by Microsoft. Starlite will default to using this library automatically if its installed - requiring zero configuration on the part of the user. That is, if <code>picologging</code> is present the previous example will work with it automatically.</p>"},{"location":"usage/0-the-starlite-app/#using-structlog","title":"Using StructLog","text":"<p>StructLog is a powerful structured-logging library. Starlite ships with a dedicated logging config for using it:</p> <pre><code>from starlite import Starlite, StructLoggingConfig, Request, get\n\n\n@get(\"/\")\ndef my_router_handler(request: Request) -&gt; None:\n    request.logger.info(\"inside a request\")\n    return None\n\n\nlogging_config = StructLoggingConfig()\n\napp = Starlite(route_handlers=[my_router_handler], logging_config=logging_config)\n</code></pre>"},{"location":"usage/0-the-starlite-app/#subclass-logging-configs","title":"Subclass Logging Configs","text":"<p>You can easily create you own <code>LoggingConfig</code> class by subclassing <code>BaseLoggingConfig</code> and implementing the <code>configure</code> method.</p>"},{"location":"usage/0-the-starlite-app/#application-hooks","title":"Application Hooks","text":"<p>Starlite includes several application level hooks that allow users to run their own sync or async callables. While you are free to use these hooks as you see fit, the design intention behind them is to allow for easy instrumentation for observability (monitoring, tracing, logging etc.).</p>  <p>Note</p> <p>All application hook kwargs detailed below receive either a single callable or a list of callables. If a list is provided, it is called in the order it is given.</p>"},{"location":"usage/0-the-starlite-app/#before-after-startup","title":"Before / After Startup","text":"<p>The <code>before_startup</code> and <code>after_startup</code> hooks take a sync or async callable that receives the Starlite application as an argument and run during the ASGI startup event. The callable is invoked respectively before or after the list of callables defined in the <code>on_startup</code> list of callables.</p> Before and After Startup Hooks<pre><code>import logging\nfrom asyncio import sleep\nfrom datetime import datetime\n\nfrom starlite import Starlite\n\nlogger = logging.getLogger()\n\n\nasync def startup_callable() -&gt; None:\n    \"\"\"Function called during 'on_startup'.\"\"\"\n    await sleep(0.5)\n\n\ndef before_startup_handler(app_instance: Starlite) -&gt; None:\n    \"\"\"Function called before 'on_startup'.\"\"\"\n    start_time = datetime.now()\n    app_instance.state.start_time = start_time.timestamp()\n    logger.info(\"startup sequence begin at %s\", start_time.isoformat())\n\n\ndef after_startup_handler(app_instance: Starlite) -&gt; None:\n    \"\"\"Function called after 'on_startup'.\"\"\"\n    logger.info(\n        \"startup sequence ended at: %s, time elapsed: %d\",\n        datetime.now().isoformat(),\n        datetime.now().timestamp() - app_instance.state.start_time,\n    )\n\n\napp = Starlite(\n    [],\n    on_startup=[startup_callable],\n    before_startup=before_startup_handler,\n    after_startup=after_startup_handler,\n)\n</code></pre>"},{"location":"usage/0-the-starlite-app/#before-after-shutdown","title":"Before / After Shutdown","text":"<p>The <code>before_shutdown</code> and <code>after_shutdown</code> are basically identical, with the difference being that the callable they receive in callable is invoked respectively before or after the list of callables defined in the <code>on_shutdown</code> list of callables.</p> Before and After Shutdown Hooks<pre><code>import logging\nfrom asyncio import sleep\nfrom datetime import datetime\n\nfrom starlite import Starlite\n\nlogger = logging.getLogger()\n\n\nasync def shutdown_callable() -&gt; None:\n    \"\"\"Function called during 'on_shutdown'.\"\"\"\n    await sleep(0.5)\n\n\ndef before_shutdown_handler(app_instance: Starlite) -&gt; None:\n    \"\"\"Function called before 'on_shutdown'.\"\"\"\n    start_time = datetime.now()\n    app_instance.state.start_time = start_time.timestamp()\n    logger.info(\"shutdown sequence begin at %s\", start_time.isoformat())\n\n\ndef after_shutdown_handler(app_instance: Starlite) -&gt; None:\n    \"\"\"Function called after 'on_shutdown'.\"\"\"\n    logger.info(\n        \"shutdown sequence ended at: %s, time elapsed: %d\",\n        datetime.now().isoformat(),\n        datetime.now().timestamp() - app_instance.state.start_time,\n    )\n\n\napp = Starlite(\n    [],\n    on_shutdown=[shutdown_callable],\n    before_shutdown=before_shutdown_handler,\n    after_shutdown=after_shutdown_handler,\n)\n</code></pre>"},{"location":"usage/0-the-starlite-app/#after-exception","title":"After Exception","text":"<p>The <code>after_exception</code> hook takes a sync or async callable that is called with three arguments: the <code>exception</code> that occurred, the ASGI <code>scope</code> of the request or websocket connection and the application <code>state</code>.</p> After Exception Hook<pre><code>import logging\nfrom typing import TYPE_CHECKING\n\nfrom starlite import HTTPException, Starlite, get\nfrom starlite.status_codes import HTTP_400_BAD_REQUEST\n\nlogger = logging.getLogger()\n\nif TYPE_CHECKING:\n    from starlite.datastructures import State\n    from starlite.types import Scope\n\n\n@get(\"/some-path\")\ndef my_handler() -&gt; None:\n    \"\"\"Route handler that raises an exception.\"\"\"\n    raise HTTPException(detail=\"bad request\", status_code=HTTP_400_BAD_REQUEST)\n\n\nasync def after_exception_handler(exc: Exception, scope: \"Scope\", state: \"State\") -&gt; None:\n    \"\"\"Hook function that will be invoked after each exception.\"\"\"\n    if not hasattr(state, \"error_count\"):\n        state.error_count = 1\n    else:\n        state.error_count += 1\n\n    logger.info(\n        \"an exception of type %s has occurred for requested path %s and the application error count is %d.\",\n        type(exc).__name__,\n        scope[\"path\"],\n        state.error_count,\n    )\n\n\napp = Starlite([my_handler], after_exception=after_exception_handler)\n</code></pre>  <p>Important</p> <p>This hook is not meant to handle exceptions - it just receives them to allow for side effects. To handle exceptions you should define exception handlers.</p>"},{"location":"usage/0-the-starlite-app/#before-send","title":"Before Send","text":"<p>The <code>before_send</code> hook takes a sync or async callable that is called when an ASGI message is sent. The hook receives the message instance and the application state.</p> Python 3.8+Python 3.9+   Before Send Hook<pre><code>from typing import TYPE_CHECKING, Dict\n\nfrom starlite import Starlite, get\nfrom starlite.datastructures import MutableScopeHeaders\n\nif TYPE_CHECKING:\n    from starlite.datastructures import State\n    from starlite.types import Message\n\n\n@get(\"/test\")\ndef handler() -&gt; Dict[str, str]:\n    \"\"\"Example Handler function.\"\"\"\n    return {\"key\": \"value\"}\n\n\nasync def before_send_hook_handler(message: \"Message\", state: \"State\") -&gt; None:\n    \"\"\"The function will be called on each ASGI message.\n\n    We therefore ensure it runs only on the message start event.\n    \"\"\"\n    if message[\"type\"] == \"http.response.start\":\n        headers = MutableScopeHeaders.from_message(message=message)\n        headers[\"My Header\"] = state.message\n\n\ndef on_startup(state: \"State\") -&gt; None:\n    \"\"\"A function that will populate the app state before any requests are received.\"\"\"\n    state.message = \"value injected during send\"\n\n\napp = Starlite(route_handlers=[handler], on_startup=[on_startup], before_send=before_send_hook_handler)\n</code></pre>   Before Send Hook<pre><code>from typing import TYPE_CHECKING\n\nfrom starlite import Starlite, get\nfrom starlite.datastructures import MutableScopeHeaders\n\nif TYPE_CHECKING:\n    from starlite.datastructures import State\n    from starlite.types import Message\n\n\n@get(\"/test\")\ndef handler() -&gt; dict[str, str]:\n    \"\"\"Example Handler function.\"\"\"\n    return {\"key\": \"value\"}\n\n\nasync def before_send_hook_handler(message: \"Message\", state: \"State\") -&gt; None:\n    \"\"\"The function will be called on each ASGI message.\n\n    We therefore ensure it runs only on the message start event.\n    \"\"\"\n    if message[\"type\"] == \"http.response.start\":\n        headers = MutableScopeHeaders.from_message(message=message)\n        headers[\"My Header\"] = state.message\n\n\ndef on_startup(state: \"State\") -&gt; None:\n    \"\"\"A function that will populate the app state before any requests are received.\"\"\"\n    state.message = \"value injected during send\"\n\n\napp = Starlite(route_handlers=[handler], on_startup=[on_startup], before_send=before_send_hook_handler)\n</code></pre>"},{"location":"usage/0-the-starlite-app/#application-init","title":"Application Init","text":"<p>Starlite includes a hook for intercepting the arguments passed to the Starlite constructor, before they are used to instantiate the application.</p> <p>Handlers can be passed to the <code>on_app_init</code> parameter on construction of the application, and in turn, each will receive an instance of <code>AppConfig</code> and must return an instance of same.</p> <p>This hook is useful for applying common configuration between applications, and for use by developers who may wish to develop third-party application configuration systems.</p>  <p>Note</p> <p><code>on_app_init</code> handlers cannot be <code>async def</code> functions, as they are called within <code>Starlite.__init__()</code>, outside of an async context.</p>  After Exception Hook<pre><code>from typing import TYPE_CHECKING\n\nfrom starlite import Starlite\n\nif TYPE_CHECKING:\n    from starlite.config import AppConfig\n\n\nasync def close_db_connection() -&gt; None:\n    \"\"\"Closes the database connection on application shutdown.\"\"\"\n\n\ndef receive_app_config(app_config: \"AppConfig\") -&gt; \"AppConfig\":\n    \"\"\"Receives parameters from the application.\n\n    In reality, this would be a library of boilerplate that is carried from one application to another, or a third-party\n    developed application configuration tool.\n    \"\"\"\n    app_config.on_shutdown.append(close_db_connection)\n    return app_config\n\n\napp = Starlite([], on_app_init=[receive_app_config])\n</code></pre>"},{"location":"usage/0-the-starlite-app/#layered-architecture","title":"Layered architecture","text":"<p>Starlite has a layered architecture compromising of (generally speaking) 4 layers:</p> <ol> <li>The application object</li> <li>Routers</li> <li>Controllers</li> <li>Handlers</li> </ol> <p>There are many parameters that can be defined on every layer, in which case the parameter defined on the layer closest to the handler takes precedence. This allows for maximum flexibility and simplicity when configuring complex applications and enables transparent overriding of parameters.</p> <p>Parameters that support layering are:</p> <ul> <li><code>after_request</code></li> <li><code>after_response</code></li> <li><code>before_request</code></li> <li><code>cache_control</code></li> <li><code>dependencies</code></li> <li><code>etag</code></li> <li><code>exception_handlers</code></li> <li><code>guards</code></li> <li><code>middleware</code></li> <li><code>opt</code></li> <li><code>response_class</code></li> <li><code>response_cookies</code></li> <li><code>response_headers</code></li> <li><code>security</code></li> <li><code>tags</code></li> <li><code>type_encoders</code></li> </ul>"},{"location":"usage/13-lifecycle-hooks/","title":"Life Cycle Hooks","text":"<p>Life cycle hooks allows a user to execute a function at a certain point, as indicated by the hook's name, during the request-response cycle.</p>"},{"location":"usage/13-lifecycle-hooks/#before-request","title":"Before Request","text":"<p>The <code>before_request</code> hook runs immediately before calling the route handler function. It accepts either a sync or async function that receives the <code>Request</code> instance as its sole parameter. While the handler function does not need to return a value, if it does return a value other than <code>None</code>, then the route handler will not be called and this value will instead be used for the response. Thus, the <code>before_request</code> handler allows bypassing the route handler selectively.</p> <pre><code>from starlite import Starlite, Request\n\n\nasync def my_before_request_handler(request: Request) -&gt; None:\n    ...\n\n\napp = Starlite(route_handlers=[...], before_request=my_before_request_handler)\n</code></pre>"},{"location":"usage/13-lifecycle-hooks/#after-request","title":"After Request","text":"<p>The <code>after_request</code> hook is called after the route handler function returned and the response object has been resolved. It receives either a sync or async function that receives the <code>Response</code> object, which can be either an instance of <code>starlite.response.Response</code> or any subclass of the Starlette <code>Response</code> object. This function must return a <code>Response</code> object - either the one that was passed in, or a different one. The <code>after_response</code> hook allows users to modify responses, e.g. placing cookies or headers on them, or even to completely replace them given certain conditions.</p> <pre><code>from starlite import Starlite, Response\n\n\nasync def my_after_request_handler(response: Response) -&gt; Response:\n    ...\n\n\napp = Starlite(route_handlers=[...], after_request=my_after_request_handler)\n</code></pre>"},{"location":"usage/13-lifecycle-hooks/#after-response","title":"After Response","text":"<p>The <code>after_response</code> hook is called after the response has been awaited, that is - after a response has been sent to the requester. It receives either a sync or async function that receives the <code>Request</code> object. The function should not return any values. This hook is meant for data post-processing, transmission of data to third party services, gathering of metrics etc.</p> <pre><code>from starlite import Starlite, Request\n\n\nasync def my_after_response_handler(request: Request) -&gt; None:\n    ...\n\n\napp = Starlite(route_handlers=[...], after_response=my_after_response_handler)\n</code></pre>"},{"location":"usage/13-lifecycle-hooks/#overriding-handlers","title":"Overriding Handlers","text":"<p>You can configure life cycle hook handlers on all layers of your application, that is - on the Starlite instance itself, on routers, controllers or individual route handlers.</p> <p>Each layer overrides the layer above it - thus, the handlers defined for a specific function will override those defined on its router, which will in turn override those defined on the app level.</p> <pre><code>from starlite import Starlite, Router, Controller, get\n\n\n# this overrides the router and app\nclass MyController(Controller):\n    path = \"/my-path\"\n\n    # this overrides the controller, router and app\n    @get(after_request=..., before_request=...)\n    def my_handler(self) -&gt; None:\n        ...\n\n\n# this overrides the app, for all routes below the router these functions will be used\nrouter = Router(route_handlers=[MyController], after_request=..., before_request=...)\n\n# this is top level\napp = Starlite(route_handlers=[router], after_request=..., before_request=...)\n</code></pre>"},{"location":"usage/16-templating/","title":"Templates","text":"<p>Starlite has built-in support for both the Jinja2 and Mako template engines, as well as abstractions to make use of any template engine you wish.</p>"},{"location":"usage/16-templating/#template-engines","title":"Template engines","text":"<p>To stay lightweight, a Starlite installation does not include the Jinja or Mako libraries themselves. Before you can start using them, you have to install it via the respective extra:</p> <ul> <li><code>pip install starlite[jinja]</code> for Jinja2</li> <li><code>pip install starlite[mako]</code> for Mako</li> </ul>  <p>Info</p> <p>Jinja is included in the <code>standard</code> extra. If you installed Starlite using <code>starlite[standard]</code>, you do not need to explicitly add the <code>jinja</code> extra.</p>"},{"location":"usage/16-templating/#registering-a-template-engine","title":"Registering a template engine","text":"<p>To register one of the built-in template engines you simply need to pass it to the Starlite constructor:</p> JinjaMako   <pre><code>from pathlib import Path\n\nfrom starlite import Starlite, TemplateConfig\nfrom starlite.contrib.jinja import JinjaTemplateEngine\n\napp = Starlite(\n    route_handlers=[],\n    template_config=TemplateConfig(\n        directory=Path(\"templates\"),\n        engine=JinjaTemplateEngine,\n    ),\n)\n</code></pre>   <pre><code>from pathlib import Path\n\nfrom starlite import Starlite, TemplateConfig\nfrom starlite.contrib.mako import MakoTemplateEngine\n\napp = Starlite(\n    route_handlers=[],\n    template_config=TemplateConfig(\n        directory=Path(\"templates\"),\n        engine=MakoTemplateEngine,\n    ),\n)\n</code></pre>     <p>Info</p> <p>The <code>directory</code> parameter passed to <code>TemplateConfig</code> can be either a directory or list of directories to use for loading templates.</p>"},{"location":"usage/16-templating/#defining-a-custom-template-engine","title":"Defining a custom template engine","text":"<p>If you wish to use another templating engine, you can easily do so by implementing <code>TemplateEngineProtocol</code>. This class accepts a generic argument <code>T</code> which should be the template class, and it specifies two methods:</p> Python 3.8+Python 3.9+Python 3.10+   <pre><code>from typing import Protocol, Union, List\nfrom pydantic import DirectoryPath\n\n# the template class of the respective library\nfrom some_lib import SomeTemplate\n\n\nclass TemplateEngineProtocol(Protocol[SomeTemplate]):\n    def __init__(self, directory: Union[DirectoryPath, List[DirectoryPath]]) -&gt; None:\n        \"\"\"Builds a template engine.\"\"\"\n        ...\n\n    def get_template(self, template_name: str) -&gt; SomeTemplate:\n        \"\"\"Loads the template with template_name and returns it.\"\"\"\n        ...\n</code></pre>   <pre><code>from typing import Protocol, Union\nfrom pydantic import DirectoryPath\n\n# the template class of the respective library\nfrom some_lib import SomeTemplate\n\n\nclass TemplateEngineProtocol(Protocol[SomeTemplate]):\n    def __init__(self, directory: Union[DirectoryPath, list[DirectoryPath]]) -&gt; None:\n        \"\"\"Builds a template engine.\"\"\"\n        ...\n\n    def get_template(self, template_name: str) -&gt; SomeTemplate:\n        \"\"\"Loads the template with template_name and returns it.\"\"\"\n        ...\n</code></pre>   <pre><code>from typing import Protocol\nfrom pydantic import DirectoryPath\n\n# the template class of the respective library\nfrom some_lib import SomeTemplate\n\n\nclass TemplateEngineProtocol(Protocol[SomeTemplate]):\n    def __init__(self, directory: DirectoryPath | list[DirectoryPath]) -&gt; None:\n        \"\"\"Builds a template engine.\"\"\"\n        ...\n\n    def get_template(self, template_name: str) -&gt; SomeTemplate:\n        \"\"\"Loads the template with template_name and returns it.\"\"\"\n        ...\n</code></pre>    <p>Once you have your custom engine you can register it as you would the built-in engines.</p>"},{"location":"usage/16-templating/#accessing-the-template-engine-instance","title":"Accessing the template engine instance","text":"<p>If you need to access the template engine instance, you can do so via the <code>TemplateConfig.engine</code> attribute:</p> JinjaMako   <pre><code>from starlite import TemplateConfig\nfrom starlite.contrib.jinja import JinjaTemplateEngine\n\ntemplate_config = TemplateConfig(engine=JinjaTemplateEngine)\ntemplate_config.engine_instance.engine.globals[\"foo\"] = \"bar\"\n</code></pre>   <pre><code>from starlite import TemplateConfig\nfrom starlite.contrib.mako import MakoTemplateEngine\n\ntemplate_config = TemplateConfig(engine=MakoTemplateEngine)\ntemplate_config.engine_instance.engine.has_template(\"foo\")\n</code></pre>"},{"location":"usage/16-templating/#template-responses","title":"Template responses","text":"<p>Once you have a template engine registered you can return <code>Template</code>s from your route handlers:</p> JinjaMako   <pre><code>from pathlib import Path\n\nfrom starlite import Starlite, Template, TemplateConfig, get\nfrom starlite.contrib.jinja import JinjaTemplateEngine\n\n\n@get(path=\"/\")\ndef index(name: str) -&gt; Template:\n    return Template(name=\"hello.html.jinja2\", context={\"name\": name})\n\n\napp = Starlite(\n    route_handlers=[index],\n    template_config=TemplateConfig(\n        directory=Path(\"templates\"),\n        engine=JinjaTemplateEngine,\n    ),\n)\n</code></pre>   <pre><code>from pathlib import Path\n\nfrom starlite import Starlite, Template, TemplateConfig, get\nfrom starlite.contrib.mako import MakoTemplateEngine\n\n\n@get(path=\"/\")\ndef index(name: str) -&gt; Template:\n    return Template(name=\"hello.html.mako\", context={\"name\": name})\n\n\napp = Starlite(\n    route_handlers=[index],\n    template_config=TemplateConfig(\n        directory=Path(\"templates\"),\n        engine=MakoTemplateEngine,\n    ),\n)\n</code></pre>    <ul> <li><code>name</code> is the name of the template file within on of the specified directories. If no file with that name is found, a <code>TemplateNotFoundException</code> exception will be raised.</li> <li><code>context</code> is a dictionary containing arbitrary data that will be passed to the template engine's <code>render</code> method. For Jinja and Mako, this data will be available in the template context</li> </ul>"},{"location":"usage/16-templating/#template-context","title":"Template context","text":"<p>Both Jinja2 and Mako support passing a context object to the template as well as defining callables that will be available inside the template.</p>"},{"location":"usage/16-templating/#accessing-the-request-instance","title":"Accessing the request instance","text":"<p>The current <code>Request</code> is available within the template context under <code>request</code>, which also provides access to the app instance.</p> <p>Accessing <code>app.state.key</code> for example would look like this:</p> JinjaMako   <pre><code>&lt;html&gt;\n    &lt;body&gt;\n        &lt;div&gt;\n            &lt;span&gt;My state value: {{request.app.state.some_key}}&lt;/span&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>   <pre><code>&lt;html&gt;\n    &lt;body&gt;\n        &lt;div&gt;\n            &lt;span&gt;My state value: ${request.app.state.some_key}&lt;/span&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"usage/16-templating/#adding-csrf-inputs","title":"Adding CSRF inputs","text":"<p>If you want to add a hidden <code>&lt;input&gt;</code> tag containing a CSRF token, you first need to configure CSRF protection. With that in place, you can now insert the CSRF input field inside an HTML form:</p> JinjaMako   <pre><code>&lt;html&gt;\n    &lt;body&gt;\n        &lt;div&gt;\n            &lt;form action=\"https://myserverurl.com/some-endpoint\" method=\"post\"&gt;\n                {{ csrf_input }}\n                &lt;label for=\"fname\"&gt;First name:&lt;/label&gt;&lt;br&gt;\n                &lt;input type=\"text\" id=\"fname\" name=\"fname\"&gt;\n                &lt;label for=\"lname\"&gt;Last name:&lt;/label&gt;&lt;br&gt;\n                &lt;input type=\"text\" id=\"lname\" name=\"lname\"&gt;\n            &lt;/form&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>   <pre><code>&lt;html&gt;\n    &lt;body&gt;\n        &lt;div&gt;\n            &lt;form action=\"https://myserverurl.com/some-endpoint\" method=\"post\"&gt;\n                ${csrf_input}\n                &lt;label for=\"fname\"&gt;First name:&lt;/label&gt;&lt;br&gt;\n                &lt;input type=\"text\" id=\"fname\" name=\"fname\"&gt;\n                &lt;label for=\"lname\"&gt;Last name:&lt;/label&gt;&lt;br&gt;\n                &lt;input type=\"text\" id=\"lname\" name=\"lname\"&gt;\n            &lt;/form&gt;\n        &lt;/div&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>    <p>The input holds a CSRF token as its value and is hidden so users cannot see or interact with it. The token is sent back to the server when the form is submitted, and is checked by the CSRF middleware.</p>"},{"location":"usage/16-templating/#passing-template-context","title":"Passing template context","text":"<p>Passing context to the template is very simple - its one of the kwargs expected by the <code>Template</code> container, so simply pass a string keyed dictionary of values:</p> <pre><code>from starlite import Template, get\n\n\n@get(path=\"/info\")\ndef info() -&gt; Template:\n    return Template(name=\"info.html\", context={\"numbers\": \"1234567890\"})\n</code></pre>"},{"location":"usage/16-templating/#template-callables","title":"Template callables","text":"<p>Both Jinja2 and Mako allow users to define custom callables that are ran inside the template. Starlite builds on this and offers some functions out of the box.</p>"},{"location":"usage/16-templating/#built-in-callables","title":"Built-in callables","text":"<p><code>url_for</code>:   To access urls for route handlers you can use the <code>url_for</code> function. Its signature and behaviour     matches <code>route_reverse</code> behaviour. More details about route handler indexing     can be found here.</p> <p><code>csrf_token</code>:   This function returns the request's unique <code>csrf_token</code>. You can use this     if you wish to insert the <code>csrf_token</code> into non-HTML based templates, or insert it into HTML templates not using a hidden input field but     by some other means, for example inside a special <code>&lt;meta&gt;</code> tag.</p> <p><code>url_for_static_asset</code>:   URLs for static files can be created using the <code>url_for_static_asset</code> function. It's signature and behaviour are identical to     <code>app.url_for_static_asset</code>.</p>"},{"location":"usage/16-templating/#registering-template-callables","title":"Registering template callables","text":"<p>The Starlite <code>TemplateEngineProtocol</code> specifies the method <code>register_template_callable</code> that allows defining a custom callable on a template engine. This method is implemented for the two built in engines, and it can be used to register callables that will be injected into the template. The callable should expect one argument - the context dictionary. It can be any callable - a function, method or class that defines the call method. For example:</p> JinjaMako   Python 3.8+Python 3.9+   template_functions.py<pre><code>from pathlib import Path\nfrom typing import Dict\n\nfrom starlite import Starlite, Template, TemplateConfig, get\nfrom starlite.contrib.jinja import JinjaTemplateEngine\n\n\ndef my_template_function(ctx: Dict) -&gt; str:\n    return ctx.get(\"my_context_key\", \"nope\")\n\n\ndef register_template_callables(engine: JinjaTemplateEngine) -&gt; None:\n    engine.register_template_callable(\n        key=\"check_context_key\",\n        template_callable=my_template_function,\n    )\n\n\ntemplate_config = TemplateConfig(\n    directory=Path(\"templates\"),\n    engine=JinjaTemplateEngine,\n    engine_callback=register_template_callables,\n)\n\n\n@get(\"/\")\ndef index() -&gt; Template:\n    return Template(name=\"index.html.jinja2\")\n\n\napp = Starlite(\n    route_handlers=[index],\n    template_config=template_config,\n)\n</code></pre>   template_functions.py<pre><code>from pathlib import Path\n\nfrom starlite import Starlite, Template, TemplateConfig, get\nfrom starlite.contrib.jinja import JinjaTemplateEngine\n\n\ndef my_template_function(ctx: dict) -&gt; str:\n    return ctx.get(\"my_context_key\", \"nope\")\n\n\ndef register_template_callables(engine: JinjaTemplateEngine) -&gt; None:\n    engine.register_template_callable(\n        key=\"check_context_key\",\n        template_callable=my_template_function,\n    )\n\n\ntemplate_config = TemplateConfig(\n    directory=Path(\"templates\"),\n    engine=JinjaTemplateEngine,\n    engine_callback=register_template_callables,\n)\n\n\n@get(\"/\")\ndef index() -&gt; Template:\n    return Template(name=\"index.html.jinja2\")\n\n\napp = Starlite(\n    route_handlers=[index],\n    template_config=template_config,\n)\n</code></pre>    templates/index.html.jinja2<pre><code>&lt;strong&gt;check_context_key: &lt;/strong&gt;{{ check_context_key() }}\n</code></pre>   Python 3.8+Python 3.9+   template_functions.py<pre><code>from pathlib import Path\nfrom typing import Dict\n\nfrom starlite import Starlite, Template, TemplateConfig, get\nfrom starlite.contrib.mako import MakoTemplateEngine\n\n\ndef my_template_function(ctx: Dict) -&gt; str:\n    return ctx.get(\"my_context_key\", \"nope\")\n\n\ndef register_template_callables(engine: MakoTemplateEngine) -&gt; None:\n    engine.register_template_callable(\n        key=\"check_context_key\",\n        template_callable=my_template_function,\n    )\n\n\ntemplate_config = TemplateConfig(\n    directory=Path(\"templates\"),\n    engine=MakoTemplateEngine,\n    engine_callback=register_template_callables,\n)\n\n\n@get(\"/\")\ndef index() -&gt; Template:\n    return Template(name=\"index.html.mako\")\n\n\napp = Starlite(\n    route_handlers=[index],\n    template_config=template_config,\n)\n</code></pre>   template_functions.py<pre><code>from pathlib import Path\n\nfrom starlite import Starlite, Template, TemplateConfig, get\nfrom starlite.contrib.mako import MakoTemplateEngine\n\n\ndef my_template_function(ctx: dict) -&gt; str:\n    return ctx.get(\"my_context_key\", \"nope\")\n\n\ndef register_template_callables(engine: MakoTemplateEngine) -&gt; None:\n    engine.register_template_callable(\n        key=\"check_context_key\",\n        template_callable=my_template_function,\n    )\n\n\ntemplate_config = TemplateConfig(\n    directory=Path(\"templates\"),\n    engine=MakoTemplateEngine,\n    engine_callback=register_template_callables,\n)\n\n\n@get(\"/\")\ndef index() -&gt; Template:\n    return Template(name=\"index.html.mako\")\n\n\napp = Starlite(\n    route_handlers=[index],\n    template_config=template_config,\n)\n</code></pre>    templates/index.html.jinja2    <p>Run the example with <code>uvicorn template_functions:app</code>, visit  http://127.0.0.1:8000, and you'll see</p>"},{"location":"usage/17-exceptions/","title":"Exceptions and Exception Handling","text":"<p>Starlite define a base error called <code>StarliteException</code> which serves as a basis to all other exceptions.</p> <p>In general, Starlite will raise two types of exceptions - exceptions that arise during application init, which fall under the broad scope of configurations errors, and exceptions that are raised as part of the normal application flow, i.e. exceptions in route handlers, dependencies and middleware that should be serialized in some fashion.</p>"},{"location":"usage/17-exceptions/#configuration-exceptions","title":"Configuration Exceptions","text":"<p>For missing extra dependencies, Starlite will raise either <code>MissingDependencyException</code>. For example, if you try to use the <code>SQLAlchemyPLugin</code> without having SQLAlchemy installed, this will be raised when you start the application.</p> <p>For other configuration issues, Starlite will raise <code>ImproperlyConfiguredException</code> with a message explaining the issue.</p>"},{"location":"usage/17-exceptions/#application-exceptions","title":"Application Exceptions","text":"<p>For application exceptions, Starlite uses the class <code>HTTPException</code>, which inherits from <code>StarliteException</code>. See the API Reference for full details on the <code>HTTPException</code> class and the kwargs it accepts.</p> <pre><code>{\n  \"status_code\": 500,\n  \"detail\": \"Internal Server Error\",\n  \"extra\": {}\n}\n</code></pre> <p>Starlite also offers several pre-configured exception subclasses with pre-set error codes that you can use, such as:</p> <ul> <li><code>ImproperlyConfiguredException</code>: status code 500. Used internally for configuration errors.</li> <li><code>ValidationException</code>: status code 400. This is the exception raised when validation or parsing fails.</li> <li><code>NotFoundException</code>: status code 404.</li> <li><code>NotAuthorizedException</code>: status code 401.</li> <li><code>PermissionDeniedException</code>: status code 403.</li> <li><code>InternalServerException</code>: status code 500.</li> <li><code>ServiceUnavailableException</code>: status code 503.</li> </ul> <p>When a value fails <code>pydantic</code> validation, the result will be a <code>ValidationException</code> with the <code>extra</code> key set to the pydantic validation errors. Thus, this data will be made available for the API consumers by default.</p> <p>See the API Reference section for exceptions for full reference.</p>"},{"location":"usage/17-exceptions/#exception-handling","title":"Exception Handling","text":"<p>Starlite handles all errors by default by transforming them into JSON responses. If the errors are instances of <code>HTTPException</code>, the responses will include the appropriate <code>status_code</code>. Otherwise, the responses will default to 500 - \"Internal Server Error\".</p> <p>You can customize exception handling by passing a dictionary \u2013 mapping either <code>error status codes</code>, or <code>exception classes</code>, to callables. For example, if you would like to replace the default exception handler with a handler that returns plain-text responses you could do this:</p> <pre><code>from starlite.status_codes import HTTP_500_INTERNAL_SERVER_ERROR\nfrom starlite import HTTPException, MediaType, Request, Response, Starlite\n\n\ndef plain_text_exception_handler(_: Request, exc: Exception) -&gt; Response:\n    \"\"\"Default handler for exceptions subclassed from HTTPException\"\"\"\n    status_code = HTTP_500_INTERNAL_SERVER_ERROR\n    detail = \"\"\n    if hasattr(exc, \"detail\"):\n        detail = exc.detail\n    if hasattr(exc, \"status_code\"):\n        status_code = exc.status_code\n    return Response(\n        media_type=MediaType.TEXT,\n        content=detail,\n        status_code=status_code,\n    )\n\n\napp = Starlite(\n    route_handlers=[...],\n    exception_handlers={HTTPException: plain_text_exception_handler},\n)\n</code></pre> <p>The above will define a top level exception handler that will apply the <code>plain_text_exception_handler</code> function to all exceptions that inherit from <code>HTTPException</code>. You could of course be more granular:</p> <pre><code>from starlite.status_codes import HTTP_500_INTERNAL_SERVER_ERROR\nfrom starlite import ValidationException, Request, Response, Starlite\n\n\ndef first_exception_handler(request: Request, exc: Exception) -&gt; Response:\n    ...\n\n\ndef second_exception_handler(request: Request, exc: Exception) -&gt; Response:\n    ...\n\n\ndef third_exception_handler(request: Request, exc: Exception) -&gt; Response:\n    ...\n\n\napp = Starlite(\n    route_handlers=[...],\n    exception_handlers={\n        ValidationException: first_exception_handler,\n        HTTP_500_INTERNAL_SERVER_ERROR: second_exception_handler,\n        ValueError: third_exception_handler,\n    },\n)\n</code></pre> <p>The choice whether to use a single function that has switching logic inside it, or multiple functions depends on your specific needs.</p> <p>While it does not make much sense to have different functions with a top-level exception handling, Starlite supports defining exception handlers on all levels of the app, with the lower levels overriding levels above them. Thus, in the following example, the exception handler for the route handler function will handle the <code>ValidationException</code> related to it:</p> <pre><code>from starlite import (\n    HTTPException,\n    ValidationException,\n    Request,\n    Response,\n    Starlite,\n    get,\n)\n\n\ndef top_level_handler(request: Request, exc: Exception) -&gt; Response:\n    ...\n\n\ndef handler_level_handler(request: Request, exc: Exception) -&gt; Response:\n    ...\n\n\n@get(\"/greet\", exception_handlers={ValidationException: top_level_handler})\ndef my_route_handler(name: str) -&gt; str:\n    return f\"hello {name}\"\n\n\napp = Starlite(\n    route_handlers=[my_route_handler],\n    exception_handlers={HTTPException: top_level_handler},\n)\n</code></pre>"},{"location":"usage/17-exceptions/#exception-handling-layers","title":"Exception Handling Layers","text":"<p>Since Starlite allows users to define both exception handlers and middlewares in a layered fashion, i.e. on individual route handlers, controllers, routers or the app layer, multiple layers of exception handlers are required to ensure that exceptions are handled correctly:</p>   Exception Handlers  <p>Because of the above structure, the exceptions raised by the ASGI Router itself, namely <code>404 Not Found</code> and <code>405 Method Not Allowed</code> are handled only by exception handlers defined on the app layer. Thus, if you want to affect these exceptions, you will need to pass the exception handlers for them to the Starlite constructor and cannot use other layers for this purpose.</p>"},{"location":"usage/17-exceptions/#examples","title":"Examples","text":""},{"location":"usage/17-exceptions/#logging-exception-handler","title":"Logging Exception Handler","text":"<p>Note</p> <p>The <code>create_exception_response</code> function is used internally to produce default error responses if no handler has been registered to a route. This is available as part of the public API of Starlite so that you can apply it wherever necessary to ensure consistent error responses across your application.</p>  <pre><code>import logging\nfrom starlite.status_codes import HTTP_500_INTERNAL_SERVER_ERROR\nfrom starlite.response import Response\nfrom starlite.utils import create_exception_response\nfrom starlite.connection import Request\nfrom starlite import Starlite\n\nlogger = logging.getLogger(__name__)\n\n\ndef logging_exception_handler(request: Request, exc: Exception) -&gt; Response:\n    \"\"\"\n    Logs exception and returns appropriate response.\n\n    Parameters\n    ----------\n    request : Request\n        The request that caused the exception.\n    exc :\n        The exception caught by the Starlite exception handling middleware and passed to the\n        callback.\n\n    Returns\n    -------\n    Response\n    \"\"\"\n    logger.error(\"Application Exception\", exc_info=exc)\n    return create_exception_response(exc)\n\n\napp = Starlite(\n    ...,\n    exception_handlers={HTTP_500_INTERNAL_SERVER_ERROR: logging_exception_handler},\n)\n</code></pre>"},{"location":"usage/19-cli/","title":"CLI","text":"<p>Starlite optionally provides a simple command line interface, for running and managing Starlite applications, powered by click and rich.</p>"},{"location":"usage/19-cli/#enabling-the-cli","title":"Enabling the CLI","text":"<p>Dependencies for the CLI are not included by default, to keep the packages needed to install Starlite to a minimum. To enable the CLI, Starlite has to be installed with the <code>cli</code> or <code>standard</code> extra:</p> <pre><code>pip install starlite[cli]\n</code></pre> <pre><code>pip install starlite[standard]\n</code></pre> <p>After installing any of these two, the <code>starlite</code> command will be available as the entrypoint to the CLI.</p>"},{"location":"usage/19-cli/#autodiscovery","title":"Autodiscovery","text":"<p>Starlite will automatically discover Starlite applications and application factories in certain places:</p> <ul> <li><code>app.py</code></li> <li><code>application.py</code></li> <li><code>asgi.py</code></li> <li><code>app/__init__.py</code></li> </ul> <p>If any of these files contains an instance of the <code>Starlite</code> class, a function named <code>create_app</code>, or a function annotated as returning a <code>Starlite</code> instance, the CLI will pick it up.</p>"},{"location":"usage/19-cli/#commands","title":"Commands","text":""},{"location":"usage/19-cli/#starlite","title":"Starlite","text":"<p>The <code>starlite</code> command is the main entrypoint to the CLI. If the <code>--app</code> flag is not passed, the app will be automatically discovered as described in the section above</p>"},{"location":"usage/19-cli/#options","title":"Options","text":"Flag Environment variable Description     <code>--app</code> <code>STARLITE_APP</code> Module path to the app in the format of <code>&lt;modulename&gt;.&lt;submodule&gt;:&lt;app instance&gt;</code>"},{"location":"usage/19-cli/#run","title":"Run","text":"<p>The <code>run</code> command runs a Starlite application using uvicorn.</p> <pre><code>starlite run\n</code></pre>  <p>Warning</p> <p>This feature is intended for development purposes only and should not be used to deploy production applications</p>"},{"location":"usage/19-cli/#options_1","title":"Options","text":"Flag Environment variable Description     <code>-r</code>, <code>--reload</code> <code>STARLITE_RELOAD</code> Reload the application when files in its directory are changed   <code>-p</code>, <code>--port</code> <code>STARLITE_PORT</code> Bind the the server to this port [default: 8000]   <code>--host</code> <code>STARLITE_HOST</code> Bind the server to this host [default: 127.0.0.1]   <code>--debug</code> <code>STARLITE_DEBUG</code> Run the application in debug mode   <code>--app</code> <code>STARLITE_APP</code> Module path to the app in the format of <code>&lt;modulename&gt;.&lt;submodule&gt;:&lt;app instance&gt;</code>"},{"location":"usage/19-cli/#info","title":"Info","text":"<p>The <code>info</code> command displays useful information about the selected application and its configuration</p> <pre><code>starlite info\n</code></pre>"},{"location":"usage/19-cli/#routes","title":"Routes","text":"<p>The <code>routes</code> command displays a tree view of the routing table</p> <pre><code>starlite routes\n</code></pre>"},{"location":"usage/19-cli/#sessions","title":"Sessions","text":"<p>This command and its subcommands provide management utilities for server-side session backends.</p>"},{"location":"usage/19-cli/#delete","title":"Delete","text":"<p>The <code>delete</code> subcommand deletes a specific session from the backend.</p> <pre><code>starlite sessions delete cc3debc7-1ab6-4dc8-a220-91934a473717\n</code></pre>"},{"location":"usage/19-cli/#clear","title":"Clear","text":"<p>The <code>clear</code> subcommand clears all sessions from the backend.</p> <pre><code>starlite sessions clear\n</code></pre>"},{"location":"usage/19-cli/#extending-the-cli","title":"Extending the CLI","text":"<p>Starlite's CLI is built with click, and can be easily extended. All that's needed to add subcommands under the <code>starlite</code> command is adding an entry point, pointing to a <code>click.Command</code> or <code>click.Group</code>, under the <code>starlite.commands</code> group.</p> setup.pyPoetry   <pre><code>from setuptools import setup\n\nsetup(\n    name=\"my-starlite-plugin\",\n    ...,\n    entry_points={\n        \"starlite.commands\": [\"my_command=my_starlite_plugin.cli:main\"],\n    },\n)\n</code></pre>   <pre><code>[tool.poetry.plugins.\"starlite.commands\"]\nmy_command = \"my_starlite_plugin.cli:main\"\n</code></pre>"},{"location":"usage/19-cli/#accessing-the-app-instance","title":"Accessing the app instance","text":"<p>When extending the Starlite CLI, you most likely need access to the loaded <code>Starlite</code> instance. This can be achieved by adding the special <code>app</code> parameter to your CLI functions. This will cause <code>Starlite</code> instance to be injected into the function whenever it is being called from a click-context.</p> <pre><code>import click\nfrom starlite import Starlite\n\n\n@click.command()\ndef my_command(app: Starlite) -&gt; None:\n    ...\n</code></pre>"},{"location":"usage/4-request-data/","title":"Request Data","text":""},{"location":"usage/4-request-data/#request-body","title":"Request body","text":"<p>The body of HTTP requests can be accessed using the special <code>data</code> parameter in a handler function.</p> Python 3.8+Python 3.9+   <pre><code>from typing import Dict\n\nfrom starlite import Starlite, post\n\n\n@post(path=\"/\")\nasync def index(data: Dict[str, str]) -&gt; Dict[str, str]:\n    return data\n\n\napp = Starlite(route_handlers=[index])\n</code></pre>   <pre><code>from starlite import Starlite, post\n\n\n@post(path=\"/\")\nasync def index(data: dict[str, str]) -&gt; dict[str, str]:\n    return data\n\n\napp = Starlite(route_handlers=[index])\n</code></pre>    <p>The type of <code>data</code> an be any supported type, including</p> <ul> <li>dataclasses</li> <li><code>TypedDict</code>s</li> <li>Pydantic models</li> <li>Arbitrary stdlib types</li> <li>Typed supported via plugins</li> </ul> <pre><code>from dataclasses import dataclass\n\nfrom starlite import Starlite, post\n\n\n@dataclass\nclass User:\n    id: int\n    name: str\n\n\n@post(path=\"/\")\nasync def index(data: User) -&gt; User:\n    return data\n\n\napp = Starlite(route_handlers=[index])\n</code></pre>"},{"location":"usage/4-request-data/#validation-and-customizing-openapi-documentation","title":"Validation and customizing OpenAPI documentation","text":"<p>With the help of Body, you have fine-grained control over the validation of the request body, and can also customize the OpenAPI documentation:</p> <pre><code>from dataclasses import dataclass\n\nfrom starlite import Body, Starlite, post\n\n\n@dataclass\nclass User:\n    id: int\n    name: str\n\n\n@post(path=\"/\")\nasync def create_user(\n    data: User = Body(title=\"Create User\", description=\"Create a new user.\"),\n) -&gt; User:\n    return data\n\n\napp = Starlite(route_handlers=[create_user])\n</code></pre>"},{"location":"usage/4-request-data/#specifying-a-content-type","title":"Specifying a content-type","text":"<p>By default, Starlite will try to parse the request body as JSON. While this may be desired in most cases, you might want to specify a different type. You can do so by passing a RequestEncodingType to <code>Body</code>. This will also help to generate the correct media-type in the OpenAPI schema.</p>"},{"location":"usage/4-request-data/#url-encoded-form-data","title":"URL Encoded Form Data","text":"<p>To access data sent as url-encoded form data, i.e. <code>application/x-www-form-urlencoded</code> Content-Type header, use <code>Body</code> and specify <code>RequestEncodingType.URL_ENCODED</code> as the <code>media_type</code>:</p> <pre><code>from dataclasses import dataclass\n\nfrom starlite import Body, RequestEncodingType, Starlite, post\n\n\n@dataclass\nclass User:\n    id: int\n    name: str\n\n\n@post(path=\"/\")\nasync def create_user(\n    data: User = Body(media_type=RequestEncodingType.URL_ENCODED),\n) -&gt; User:\n    return data\n\n\napp = Starlite(route_handlers=[create_user])\n</code></pre>  <p>Info</p> <p>URL encoded data is inherently less versatile than JSON data - for example, it cannot handle complex dictionaries and deeply nested data. It should only be used for simple data structures.</p>"},{"location":"usage/4-request-data/#multipart-form-data","title":"MultiPart Form Data","text":"<p>You can access data uploaded using a request with a <code>multipart/form-data</code> Content-Type header by specifying it in the <code>Body</code> function:</p> <pre><code>from dataclasses import dataclass\n\nfrom starlite import Body, RequestEncodingType, Starlite, post\n\n\n@dataclass\nclass User:\n    id: int\n    name: str\n\n\n@post(path=\"/\")\nasync def create_user(\n    data: User = Body(media_type=RequestEncodingType.MULTI_PART),\n) -&gt; User:\n    return data\n\n\napp = Starlite(route_handlers=[create_user])\n</code></pre>"},{"location":"usage/4-request-data/#file-uploads","title":"File uploads","text":"<p>In case of files uploaded, Starlite transforms the results into an instance of <code>UploadFile</code> class, which offer a convenient interface for working with files. Therefore, you need to type your file uploads accordingly.</p> <p>To access a single file simply type <code>data</code> as <code>UploadFile</code>:</p> AsyncSync   <pre><code>from starlite import Body, MediaType, RequestEncodingType, Starlite, UploadFile, post\n\n\n@post(path=\"/\", media_type=MediaType.TEXT)\nasync def handle_file_upload(\n    data: UploadFile = Body(media_type=RequestEncodingType.MULTI_PART),\n) -&gt; str:\n    content = await data.read()\n    filename = data.filename\n    return f\"{filename}, {content.decode()}\"\n\n\napp = Starlite(route_handlers=[handle_file_upload])\n</code></pre>   <pre><code>from starlite import Body, MediaType, RequestEncodingType, Starlite, UploadFile, post\n\n\n@post(path=\"/\", media_type=MediaType.TEXT)\ndef handle_file_upload(\n    data: UploadFile = Body(media_type=RequestEncodingType.MULTI_PART),\n) -&gt; str:\n    content = data.file.read()\n    filename = data.filename\n    return f\"{filename}, {content.decode()}\"\n\n\napp = Starlite(route_handlers=[handle_file_upload])\n</code></pre>  <p>Technical details</p> <p><code>UploadFile.read</code> wraps SpooledTemporaryFile so it can be used asynchronously. Inside of a synchronous function we don't need this wrapper, so we can use <code>SpooledTemporaryFile.read()</code> directly.</p>"},{"location":"usage/4-request-data/#multiple-files","title":"Multiple files","text":"<p>To access multiple files with known filenames, you can use a pydantic model:</p> Python 3.8+Python 3.9+   <pre><code>from typing import Dict\n\nfrom pydantic import BaseConfig, BaseModel\n\nfrom starlite import Body, RequestEncodingType, Starlite, UploadFile, post\n\n\nclass FormData(BaseModel):\n    cv: UploadFile\n    diploma: UploadFile\n\n    class Config(BaseConfig):\n        arbitrary_types_allowed = True\n\n\n@post(path=\"/\")\nasync def handle_file_upload(\n    data: FormData = Body(media_type=RequestEncodingType.MULTI_PART),\n) -&gt; Dict:\n    cv_content = await data.cv.read()\n    diploma_content = await data.diploma.read()\n\n    return {\"cv\": cv_content.decode(), \"diploma\": diploma_content.decode()}\n\n\napp = Starlite(route_handlers=[handle_file_upload])\n</code></pre>   <pre><code>from pydantic import BaseConfig, BaseModel\n\nfrom starlite import Body, RequestEncodingType, Starlite, UploadFile, post\n\n\nclass FormData(BaseModel):\n    cv: UploadFile\n    diploma: UploadFile\n\n    class Config(BaseConfig):\n        arbitrary_types_allowed = True\n\n\n@post(path=\"/\")\nasync def handle_file_upload(\n    data: FormData = Body(media_type=RequestEncodingType.MULTI_PART),\n) -&gt; dict:\n    cv_content = await data.cv.read()\n    diploma_content = await data.diploma.read()\n\n    return {\"cv\": cv_content.decode(), \"diploma\": diploma_content.decode()}\n\n\napp = Starlite(route_handlers=[handle_file_upload])\n</code></pre>"},{"location":"usage/4-request-data/#files-as-a-dictionary","title":"Files as a dictionary","text":"<p>If you do not care about parsing and validation and only want to access the form data as a dictionary, you can use a <code>dict</code> instead:</p> Python 3.8+Python 3.9+   <pre><code>from typing import Dict\n\nfrom starlite import Body, RequestEncodingType, Starlite, UploadFile, post\n\n\n@post(path=\"/\")\nasync def handle_file_upload(\n    data: Dict[str, UploadFile] = Body(media_type=RequestEncodingType.MULTI_PART),\n) -&gt; Dict[str, str]:\n    file_contents = {}\n    for name, file in data.items():\n        content = await file.read()\n        file_contents[name] = content.decode()\n\n    return file_contents\n\n\napp = Starlite(route_handlers=[handle_file_upload])\n</code></pre>   <pre><code>from starlite import Body, RequestEncodingType, Starlite, UploadFile, post\n\n\n@post(path=\"/\")\nasync def handle_file_upload(\n    data: dict[str, UploadFile] = Body(media_type=RequestEncodingType.MULTI_PART),\n) -&gt; dict[str, str]:\n    file_contents = {}\n    for name, file in data.items():\n        content = await file.read()\n        file_contents[name] = content.decode()\n\n    return file_contents\n\n\napp = Starlite(route_handlers=[handle_file_upload])\n</code></pre>"},{"location":"usage/4-request-data/#files-as-a-list","title":"Files as a list","text":"<p>Finally, you can also access the files as a list without the filenames:</p> Python 3.8+Python 3.9+   <pre><code>from typing import Dict, List\n\nfrom starlite import Body, RequestEncodingType, Starlite, UploadFile, post\n\n\n@post(path=\"/\")\nasync def handle_file_upload(\n    data: List[UploadFile] = Body(media_type=RequestEncodingType.MULTI_PART),\n) -&gt; Dict[str, str]:\n    file_contents = {}\n    for file in data:\n        content = await file.read()\n        file_contents[file.filename] = content.decode()\n\n    return file_contents\n\n\napp = Starlite(route_handlers=[handle_file_upload])\n</code></pre>   <pre><code>from starlite import Body, RequestEncodingType, Starlite, UploadFile, post\n\n\n@post(path=\"/\")\nasync def handle_file_upload(\n    data: list[UploadFile] = Body(media_type=RequestEncodingType.MULTI_PART),\n) -&gt; dict[str, str]:\n    file_contents = {}\n    for file in data:\n        content = await file.read()\n        file_contents[file.filename] = content.decode()\n\n    return file_contents\n\n\napp = Starlite(route_handlers=[handle_file_upload])\n</code></pre>"},{"location":"usage/4-request-data/#messagepack-data","title":"MessagePack data","text":"<p>To receive <code>MessagePack</code> data, specify the appropriate <code>Content-Type</code> for <code>Body</code>, by using <code>RequestEncodingType.MESSAGEPACK</code>:</p> Python 3.8+Python 3.9+   msgpack_request.py<pre><code>from typing import Dict\n\nfrom starlite import Body, RequestEncodingType, Starlite, post\n\n\n@post(path=\"/\")\ndef msgpack_handler(data: Dict = Body(media_type=RequestEncodingType.MESSAGEPACK)) -&gt; Dict:\n    # This will try to parse the request body as `MessagePack` regardless of the\n    # `Content-Type`\n    return data\n\n\napp = Starlite(route_handlers=[msgpack_handler])\n</code></pre>   msgpack_request.py<pre><code>from starlite import Body, RequestEncodingType, Starlite, post\n\n\n@post(path=\"/\")\ndef msgpack_handler(data: dict = Body(media_type=RequestEncodingType.MESSAGEPACK)) -&gt; dict:\n    # This will try to parse the request body as `MessagePack` regardless of the\n    # `Content-Type`\n    return data\n\n\napp = Starlite(route_handlers=[msgpack_handler])\n</code></pre>"},{"location":"usage/1-routing/0-routing/","title":"Routing","text":"<p>Starlite implements its routing solution that is based on the concept of a radix tree or <code>trie</code>.</p>"},{"location":"usage/1-routing/0-routing/#why-radix-based-routing","title":"Why Radix Based Routing?","text":"<p>The regex matching used by Starlette (and FastAPI etc.) is very good at resolving path parameters fast, giving it an advantage when a URL has a lot of path parameters - what we can think of as <code>vertical</code> scaling. On the other hand, it is not good at scaling horizontally - the more routes, the less performant it becomes. Thus, there is an inverse relation between performance and application size with this approach that strongly favors very small microservices. The trie based approach used by Starlite is agnostic to the number of routes of the application giving it better horizontal scaling characteristics at the expense of somewhat slower resolution of path parameters.</p>  <p>Tip</p> <p>If you are interested in the technical aspects of the implementation, refer to this GitHub issue - it includes an indepth discussion of the pertinent code.</p>"},{"location":"usage/1-routing/1-registering-routes/","title":"Registering Routes","text":"<p>At the root of every Starlite application there is an instance of the <code>Starlite</code> class, on which the root level controllers, routers and route handler functions are registered using the <code>route_handlers</code> kwarg:</p> <pre><code>from starlite import Starlite, get\n\n\n@get(\"/sub-path\")\ndef sub_path_handler() -&gt; None:\n    ...\n\n\n@get()\ndef root_handler() -&gt; None:\n    ...\n\n\napp = Starlite(route_handlers=[root_handler, sub_path_handler])\n</code></pre> <p>Components registered on the app are appended to the root path. Thus, the <code>root_handler</code> function will be called for the path \"/\", whereas the <code>sub_path_handler</code> will be called for \"/sub-path\". You can also declare a function to handle multiple paths, e.g.:</p> <pre><code>from starlite import get, Starlite\n\n\n@get([\"/\", \"/sub-path\"])\ndef handler() -&gt; None:\n    ...\n\n\napp = Starlite(route_handlers=[handler])\n</code></pre> <p>To handle more complex path schemas you should use routers and controller</p>"},{"location":"usage/1-routing/1-registering-routes/#dynamic-route-registration","title":"Dynamic Route Registration","text":"<p>Occasionally there is a need for dynamic route registration. Starlite supports this via the <code>.register</code> method exposed by the Starlite app instance:</p> <pre><code>from starlite import Starlite, get\n\n\n@get()\ndef root_handler() -&gt; None:\n    ...\n\n\napp = Starlite(route_handlers=[root_handler])\n\n\n@get(\"/sub-path\")\ndef sub_path_handler() -&gt; None:\n    ...\n\n\napp.register(sub_path_handler)\n</code></pre> <p>Since the app instance is attached to all instances of <code>ASGIConnection</code>, <code>Request</code> and <code>WebSocket</code> objects, you can in effect call the <code>.register</code> method inside route handler functions, middlewares and even injected dependencies. For example:</p> <pre><code>from typing import Any\nfrom starlite import Starlite, Request, get\n\n\n@get(\"/some-path\")\ndef route_handler(request: Request[Any, Any]) -&gt; None:\n    @get(\"/sub-path\")\n    def sub_path_handler() -&gt; None:\n        ...\n\n    request.app.register(sub_path_handler)\n\n\napp = Starlite(route_handlers=[route_handler])\n</code></pre> <p>In the above we dynamically created the sub-path_handler and registered it inside the <code>route_handler</code> function.</p>  <p>Warning</p> <p>Although Starlite exposes the <code>.register</code> method, it should not be abused. Dynamic route registration increases the application complexity and makes it harder to reason about the code. It should therefore be used only when absolutely required.</p>"},{"location":"usage/1-routing/2-routers/","title":"Routers","text":"<p>Routers are instances of <code>starlite.router.Router</code>, which is the base class for the Starlite app itself. A router can register Controllers, route handler functions and other routers, similarly to the Starlite constructor:</p> <pre><code>from starlite import Starlite, Router, get\n\n\n@get(\"/{order_id:int}\")\ndef order_handler(order_id: int) -&gt; None:\n    ...\n\n\norder_router = Router(path=\"/orders\", route_handlers=[order_handler])\nbase_router = Router(path=\"/base\", route_handlers=[order_router])\napp = Starlite(route_handlers=[base_router])\n</code></pre> <p>Once <code>order_router</code> is registered on <code>base_router</code>, the handler function registered on <code>order_router</code> will become available on <code>/base/orders/{order_id}</code>.</p> <p>See the API Reference for full details on the Router class and the kwargs it accepts.</p>"},{"location":"usage/1-routing/3-controllers/","title":"Controllers","text":"<p>Controllers are subclasses of the class <code>starlite.controller.Controller</code>. They are used to organize endpoints under a specific sub-path, which is the controller's path. Their purpose is to allow users to utilize python OOP for better code organization and organize code by logical concerns.</p> <pre><code>from pydantic import BaseModel, UUID4\nfrom starlite.controller import Controller\nfrom starlite.handlers import get, post, patch, delete\nfrom starlite.types import Partial\n\n\nclass UserOrder(BaseModel):\n    user_id: int\n    order: str\n\n\nclass UserOrderController(Controller):\n    path = \"/user-order\"\n\n    @post()\n    async def create_user_order(self, data: UserOrder) -&gt; UserOrder:\n        ...\n\n    @get(path=\"/{order_id:uuid}\")\n    async def retrieve_user_order(self, order_id: UUID4) -&gt; UserOrder:\n        ...\n\n    @patch(path=\"/{order_id:uuid}\")\n    async def update_user_order(\n        self, order_id: UUID4, data: Partial[UserOrder]\n    ) -&gt; UserOrder:\n        ...\n\n    @delete(path=\"/{order_id:uuid}\")\n    async def delete_user_order(self, order_id: UUID4) -&gt; None:\n        ...\n</code></pre> <p>The above is a simple example of a \"CRUD\" controller for a model called <code>UserOrder</code>. You can place as many route handler methods on a controller, as long as the combination of path+http method is unique.</p> <p>The <code>path</code> that is defined on the Controller is appended before the path that is defined for the route handlers declared on it. Thus, in the above example, <code>create_user_order</code> has the path of the controller - <code>/user-order/</code>, while <code>retrieve_user_order</code> has the path <code>/user-order/{order_id:uuid}\"</code>.</p>  <p>Note</p> <p>If you do not declare a <code>path</code> class variable on the controller, it will default to the root path of \"/\".</p>  <p>See the API Reference for full details on the Controller class and the kwargs it accepts.</p>"},{"location":"usage/1-routing/4-registering-components-multiple-times/","title":"Registering Components Multiple Times","text":"<p>You can register both standalone route handler functions and controllers multiple times.</p>"},{"location":"usage/1-routing/4-registering-components-multiple-times/#registering-controllers-multiple-times","title":"Registering Controllers Multiple Times","text":"<pre><code>from starlite import Router, Controller, get\n\n\nclass MyController(Controller):\n    path = \"/controller\"\n\n    @get()\n    def handler(self) -&gt; None:\n        ...\n\n\ninternal_router = Router(path=\"/internal\", route_handlers=[MyController])\npartner_router = Router(path=\"/partner\", route_handlers=[MyController])\nconsumer_router = Router(path=\"/consumer\", route_handlers=[MyController])\n</code></pre> <p>In the above, the same <code>MyController</code> class has been registered on three different routers. This is possible because what is passed to the router is not a class instance but rather the class itself. The router creates its own instance of the controller, which ensures encapsulation.</p> <p>Therefore, in the above example, three different instances of <code>MyController</code> will be created, each mounted on a different sub-path, e.g. <code>/internal/controller</code>, <code>/partner/controller</code> and <code>/consumer/controller</code>.</p>"},{"location":"usage/1-routing/4-registering-components-multiple-times/#registering-standalone-route-handlers-multiple-times","title":"Registering Standalone Route Handlers Multiple Times","text":"<p>You can also register standalone route handlers multiple times:</p> <pre><code>from starlite import Starlite, Router, get\n\n\n@get(path=\"/handler\")\ndef my_route_handler() -&gt; None:\n    ...\n\n\ninternal_router = Router(path=\"/internal\", route_handlers=[my_route_handler])\npartner_router = Router(path=\"/partner\", route_handlers=[my_route_handler])\nconsumer_router = Router(path=\"/consumer\", route_handlers=[my_route_handler])\n\nStarlite(route_handlers=[internal_router, partner_router, consumer_router])\n</code></pre> <p>When the handler function is registered, it's actually copied. Thus, each router has its own unique instance of the route handler. Path behaviour is identical to that of controllers above, namely, the route handler function will be accessible in the following paths: <code>/internal/handler</code>, <code>/partner/handler</code> and <code>/consumer/handler</code>.</p>  <p>Important</p> <p>You can nest routers as you see fit - but be aware that once a router has been registered it cannot be re-registered or an exception will be raised.</p>"},{"location":"usage/1-routing/5-mounting-asgi-apps/","title":"Mounting ASGI Apps","text":"<p>Starlite support \"mounting\" ASGI applications on sub paths, that is - specifying a handler function that will handle all requests addressed to a given path.</p> Mounting an ASGI App<pre><code>from typing import TYPE_CHECKING\n\nfrom starlite import Response, Starlite, asgi\n\nif TYPE_CHECKING:\n    from starlite.types import Receive, Scope, Send\n\n\n@asgi(\"/some/sub-path\", is_mount=True)\nasync def my_asgi_app(scope: \"Scope\", receive: \"Receive\", send: \"Send\") -&gt; None:\n    \"\"\"\n    Args:\n        scope: The ASGI connection scope.\n        receive: The ASGI receive function.\n        send: The ASGI send function.\n\n    Returns:\n        None\n    \"\"\"\n    response = Response(content={\"forwarded_path\": scope[\"path\"]})\n    await response(scope, receive, send)\n\n\napp = Starlite(route_handlers=[my_asgi_app])\n</code></pre> <p>The handler function will receive all requests with an url that begins with <code>/some/sub-path</code>, e.g. <code>/some/sub-path</code> and <code>/some/sub-path/abc</code> and <code>/some/sub-path/123/another/sub-path</code> etc.</p>  <p>Info</p> <p>If we are sending a request to the above with the url <code>/some/sub-path</code>, the handler will be invoked and the value of <code>scope[\"path\"]</code> will equal <code>/</code>. If we send a request to <code>/some/sub-path/abc</code>, it will also be invoked, and <code>scope[\"path\"]</code> will equal <code>/abc</code>.</p>  <p>Mounting is especially useful when you need to combine components of other ASGI applications - for example, for 3rd part libraries. The following example is identical in principle to the one above, but it uses <code>Starlette</code>:</p> Mounting a Starlette App<pre><code>from typing import TYPE_CHECKING\n\nfrom starlette.applications import Starlette\nfrom starlette.responses import JSONResponse\nfrom starlette.routing import Route\n\nfrom starlite import Starlite, asgi\n\nif TYPE_CHECKING:\n    from starlette.requests import Request\n\n\nasync def index(request: \"Request\") -&gt; JSONResponse:\n    \"\"\"A generic starlette handler.\"\"\"\n    return JSONResponse({\"forwarded_path\": request.url.path})\n\n\nstarlette_app = asgi(path=\"/some/sub-path\", is_mount=True)(\n    Starlette(\n        debug=True,\n        routes=[\n            Route(\"/\", index),\n            Route(\"/abc/\", index),\n            Route(\"/123/another/sub-path/\", index),\n        ],\n    )\n)\n\n\napp = Starlite(route_handlers=[starlette_app])\n</code></pre>"},{"location":"usage/10-plugins/0-plugins-intro/","title":"Plugins","text":"<p>Starlite supports extension through plugins, which allow for the following:</p> <ol> <li>Updating the Starlite application instance during the init process.</li> <li>Serialization and deserialization of non-pydantic based 3rd party classes.</li> <li>Automatic OpenAPI schema creation for 3rd party classes.</li> </ol> <p>Thus, plugins allow for a wide range of actions - from registering middleware to the parsing and validation of incoming data using non-pydantic classes. Additionally, they allow for seamless serialization and schema generation.</p>"},{"location":"usage/10-plugins/0-plugins-intro/#creating-plugins","title":"Creating Plugins","text":"<p>A plugin is a class that implements the <code>PluginProtocol</code>.</p> <p>If you wish to support the serialization and deserialization of none-pydantic classes, you need to implement the following methods specified by the:</p> Python 3.8+Python 3.9+   <pre><code>from typing import Type, Any, Dict\nfrom starlite import PluginProtocol\nfrom pydantic import BaseModel\n\n\nclass MyClass:\n    ...\n\n\nclass MyPlugin(PluginProtocol[MyClass]):\n    \"\"\"\n    The class for which we create a plugin. For example, could be a base ORM class such as \"Model\" or \"Document\" etc.\n    \"\"\"\n\n    ...\n\n    def to_pydantic_model_class(\n        self, model_class: Type[MyClass], **kwargs: Any\n    ) -&gt; Type[BaseModel]:\n        \"\"\"\n        Given a model_class, convert it to a subclass of the pydantic BaseModel\n        \"\"\"\n        ...\n\n    @staticmethod\n    def is_plugin_supported_type(value: Any) -&gt; bool:\n        \"\"\"\n        Given a value of indeterminate type, determine if this value is supported by the plugin by returning a bool.\n        \"\"\"\n        ...\n\n    def from_pydantic_model_instance(\n        self, model_class: Type[MyClass], pydantic_model_instance: BaseModel\n    ) -&gt; MyClass:\n        \"\"\"\n        Given an instance of a pydantic model created using a plugin's 'to_pydantic_model_class',\n        return an instance of the class from which that pydantic model has been created.\n\n        This class is passed in as the 'model_class' kwarg.\n        \"\"\"\n        ...\n\n    def to_dict(self, model_instance: MyClass) -&gt; Dict[str, Any]:\n        \"\"\"\n        Given an instance of a model supported by the plugin, return a dictionary of serializable values.\n        \"\"\"\n        ...\n\n    def from_dict(self, model_class: Type[MyClass], **kwargs: Any) -&gt; MyClass:\n        \"\"\"\n        Given a class supported by this plugin and a dict of values, create an instance of the class\n        \"\"\"\n        ...\n</code></pre>   <pre><code>from typing import Any\nfrom starlite import PluginProtocol\nfrom pydantic import BaseModel\n\n\nclass MyClass:\n    ...\n\n\nclass MyPlugin(PluginProtocol[MyClass]):\n    \"\"\"\n    The class for which we create a plugin. For example, could be a base ORM class such as \"Model\" or \"Document\" etc.\n    \"\"\"\n\n    ...\n\n    def to_pydantic_model_class(\n        self, model_class: type[MyClass], **kwargs: Any\n    ) -&gt; type[BaseModel]:\n        \"\"\"\n        Given a model_class, convert it to a subclass of the pydantic BaseModel\n        \"\"\"\n        ...\n\n    @staticmethod\n    def is_plugin_supported_type(value: Any) -&gt; bool:\n        \"\"\"\n        Given a value of indeterminate type, determine if this value is supported by the plugin by returning a bool.\n        \"\"\"\n        ...\n\n    def from_pydantic_model_instance(\n        self, model_class: type[MyClass], pydantic_model_instance: BaseModel\n    ) -&gt; MyClass:\n        \"\"\"\n        Given an instance of a pydantic model created using a plugin's 'to_pydantic_model_class',\n        return an instance of the class from which that pydantic model has been created.\n\n        This class is passed in as the 'model_class' kwarg.\n        \"\"\"\n        ...\n\n    def to_dict(self, model_instance: MyClass) -&gt; dict[str, Any]:\n        \"\"\"\n        Given an instance of a model supported by the plugin, return a dictionary of serializable values.\n        \"\"\"\n        ...\n\n    def from_dict(self, model_class: type[MyClass], **kwargs: Any) -&gt; MyClass:\n        \"\"\"\n        Given a class supported by this plugin and a dict of values, create an instance of the class\n        \"\"\"\n        ...\n</code></pre>    <p>If you wish to register middlewares, guards, dependencies and so forth on the application init, you need to implement the <code>on_app_init</code> method:</p> <pre><code>from typing import Any\nfrom starlite import PluginProtocol, Starlite, get\n\n\n@get(\"/some-path\")\ndef my_handler() -&gt; None:\n    ...\n\n\nclass MyPlugin(PluginProtocol[Any]):\n    def on_app_init(self, app: Starlite) -&gt; None:\n        # register a route handler\n        app.register(my_handler)\n\n        # update attributes of the application before init is finished.\n        app.after_request = ...\n        app.after_response = ...\n        app.before_request = ...\n        app.dependencies.update({...})\n        app.exception_handlers.update({...})\n        app.guards.extend(...)\n        app.middleware.extend(...)\n        app.on_shutdown.extend(...)\n        app.on_startup.extend(...)\n        app.parameters.update({...})\n        app.response_class = ...\n        app.response_cookies.extend(...)\n        app.response_headers.update(...)\n        app.tags.extend(...)\n</code></pre>"},{"location":"usage/10-plugins/1-sql-alchemy-plugin/","title":"SQLAlchemy Plugin","text":"<p>Starlite comes with built-in support for SQLAlchemy via the<code>SQLAlchemyPlugin</code>.</p>"},{"location":"usage/10-plugins/1-sql-alchemy-plugin/#features","title":"Features","text":"<ul> <li>Managed sessions (sync and async) including dependency injection</li> <li>Automatic serialization of SQLAlchemy models powered pydantic</li> <li>Data validation based on SQLAlchemy models powered pydantic</li> </ul>  <p>Info</p> <p>The following examples use SQLAlchemy's \"2.0 Style\" introduced in SQLAlchemy 1.4.</p> <p>If you are unfamiliar with it, you can find a comprehensive migration guide in SQLAlchemy's documentation here, and a handy table comparing the ORM usage</p>   <p>Important</p> <p>The <code>SQLAlchemyPlugin</code> supports only mapped classes. Tables are currently not supported since they are not easy to convert to pydantic models.</p>"},{"location":"usage/10-plugins/1-sql-alchemy-plugin/#basic-use","title":"Basic Use","text":"<p>You can simply pass an instance of <code>SQLAlchemyPlugin</code> without passing config to the Starlite constructor. This will extend support for serialization, deserialization and DTO creation for SQLAlchemy declarative models:</p> AsyncSync   Python 3.8+Python 3.10+   sqlalchemy_plugin.py<pre><code>from typing import Optional\n\nfrom sqlalchemy import Column, Float, Integer, String, select\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.orm import Mapped, declarative_base\n\nfrom starlite import DTOFactory, HTTPException, Starlite, get, post\nfrom starlite.plugins.sql_alchemy import SQLAlchemyConfig, SQLAlchemyPlugin\nfrom starlite.status_codes import HTTP_404_NOT_FOUND\n\nBase = declarative_base()\n\nsqlalchemy_config = SQLAlchemyConfig(\n    connection_string=\"sqlite+aiosqlite:///test.sqlite\", dependency_key=\"async_session\"\n)\nsqlalchemy_plugin = SQLAlchemyPlugin(config=sqlalchemy_config)\ndto_factory = DTOFactory(plugins=[sqlalchemy_plugin])\n\n\nclass Company(Base):  # pyright: ignore\n    __tablename__ = \"company\"\n    id: Mapped[int] = Column(Integer, primary_key=True)\n    name: Mapped[str] = Column(String)\n    worth: Mapped[float] = Column(Float)\n\n\nCreateCompanyDTO = dto_factory(\"CreateCompanyDTO\", Company, exclude=[\"id\"])\n\n\nasync def on_startup() -&gt; None:\n    \"\"\"Initialize the database.\"\"\"\n    async with sqlalchemy_config.engine.begin() as conn:  # type: ignore\n        await conn.run_sync(Base.metadata.create_all)  # pyright: ignore\n\n\n@post(path=\"/companies\")\nasync def create_company(\n    data: CreateCompanyDTO,  # type: ignore[valid-type]\n    async_session: AsyncSession,\n) -&gt; Company:\n    \"\"\"Create a new company and return it.\"\"\"\n    company: Company = data.to_model_instance()  # type: ignore[attr-defined]\n    async_session.add(company)\n    await async_session.commit()\n    return company\n\n\n@get(path=\"/companies/{company_id:int}\")\nasync def get_company(company_id: int, async_session: AsyncSession) -&gt; Company:\n    \"\"\"Get a company by its ID and return it.\n\n    If a company with that ID does not exist, return a 404 response\n    \"\"\"\n    result = await async_session.scalars(select(Company).where(Company.id == company_id))\n    company: Optional[Company] = result.one_or_none()\n    if not company:\n        raise HTTPException(detail=f\"Company with ID {company_id} not found\", status_code=HTTP_404_NOT_FOUND)\n    return company\n\n\napp = Starlite(\n    route_handlers=[create_company, get_company],\n    on_startup=[on_startup],\n    plugins=[sqlalchemy_plugin],\n)\n</code></pre>   sqlalchemy_plugin.py<pre><code>from sqlalchemy import Column, Float, Integer, String, select\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.orm import Mapped, declarative_base\n\nfrom starlite import DTOFactory, HTTPException, Starlite, get, post\nfrom starlite.plugins.sql_alchemy import SQLAlchemyConfig, SQLAlchemyPlugin\nfrom starlite.status_codes import HTTP_404_NOT_FOUND\n\nBase = declarative_base()\n\nsqlalchemy_config = SQLAlchemyConfig(\n    connection_string=\"sqlite+aiosqlite:///test.sqlite\", dependency_key=\"async_session\"\n)\nsqlalchemy_plugin = SQLAlchemyPlugin(config=sqlalchemy_config)\ndto_factory = DTOFactory(plugins=[sqlalchemy_plugin])\n\n\nclass Company(Base):  # pyright: ignore\n    __tablename__ = \"company\"\n    id: Mapped[int] = Column(Integer, primary_key=True)\n    name: Mapped[str] = Column(String)\n    worth: Mapped[float] = Column(Float)\n\n\nCreateCompanyDTO = dto_factory(\"CreateCompanyDTO\", Company, exclude=[\"id\"])\n\n\nasync def on_startup() -&gt; None:\n    \"\"\"Initialize the database.\"\"\"\n    async with sqlalchemy_config.engine.begin() as conn:  # type: ignore\n        await conn.run_sync(Base.metadata.create_all)  # pyright: ignore\n\n\n@post(path=\"/companies\")\nasync def create_company(\n    data: CreateCompanyDTO,  # type: ignore[valid-type]\n    async_session: AsyncSession,\n) -&gt; Company:\n    \"\"\"Create a new company and return it.\"\"\"\n    company: Company = data.to_model_instance()  # type: ignore[attr-defined]\n    async_session.add(company)\n    await async_session.commit()\n    return company\n\n\n@get(path=\"/companies/{company_id:int}\")\nasync def get_company(company_id: int, async_session: AsyncSession) -&gt; Company:\n    \"\"\"Get a company by its ID and return it.\n\n    If a company with that ID does not exist, return a 404 response\n    \"\"\"\n    result = await async_session.scalars(select(Company).where(Company.id == company_id))\n    company: Company | None = result.one_or_none()\n    if not company:\n        raise HTTPException(detail=f\"Company with ID {company_id} not found\", status_code=HTTP_404_NOT_FOUND)\n    return company\n\n\napp = Starlite(\n    route_handlers=[create_company, get_company],\n    on_startup=[on_startup],\n    plugins=[sqlalchemy_plugin],\n)\n</code></pre>      Python 3.8+Python 3.10+   sqlalchemy_plugin.py<pre><code>from typing import Optional\n\nfrom sqlalchemy import Column, Float, Integer, String, select\nfrom sqlalchemy.orm import Mapped, Session, declarative_base\n\nfrom starlite import DTOFactory, HTTPException, Starlite, get, post\nfrom starlite.plugins.sql_alchemy import SQLAlchemyConfig, SQLAlchemyPlugin\nfrom starlite.status_codes import HTTP_404_NOT_FOUND\n\nBase = declarative_base()\n\nsqlalchemy_config = SQLAlchemyConfig(connection_string=\"sqlite+pysqlite:///test.sqlite\", use_async_engine=False)\nsqlalchemy_plugin = SQLAlchemyPlugin(config=sqlalchemy_config)\ndto_factory = DTOFactory(plugins=[sqlalchemy_plugin])\n\n\nclass Company(Base):  # pyright: ignore\n    __tablename__ = \"company\"\n    id: Mapped[int] = Column(Integer, primary_key=True)\n    name: Mapped[str] = Column(String)\n    worth: Mapped[float] = Column(Float)\n\n\nCreateCompanyDTO = dto_factory(\"CreateCompanyDTO\", Company, exclude=[\"id\"])\n\n\ndef on_startup() -&gt; None:\n    \"\"\"Initialize the database.\"\"\"\n    Base.metadata.create_all(sqlalchemy_config.engine)  # type: ignore\n\n\n@post(path=\"/companies\")\ndef create_company(\n    data: CreateCompanyDTO,  # type: ignore[valid-type]\n    db_session: Session,\n) -&gt; Company:\n    \"\"\"Create a new company and return it.\"\"\"\n    company: Company = data.to_model_instance()  # type: ignore[attr-defined]\n    db_session.add(company)\n    db_session.commit()\n    return company\n\n\n@get(path=\"/companies/{company_id:int}\")\ndef get_company(company_id: str, db_session: Session) -&gt; Company:\n    \"\"\"Get a company by its ID and return it.\n\n    If a company with that ID does not exist, return a 404 response\n    \"\"\"\n    company: Optional[Company] = db_session.scalars(select(Company).where(Company.id == company_id)).one_or_none()\n    if not company:\n        raise HTTPException(detail=f\"Company with ID {company_id} not found\", status_code=HTTP_404_NOT_FOUND)\n    return company\n\n\napp = Starlite(\n    route_handlers=[create_company, get_company],\n    on_startup=[on_startup],\n    plugins=[sqlalchemy_plugin],\n)\n</code></pre>   sqlalchemy_plugin.py<pre><code>from sqlalchemy import Column, Float, Integer, String, select\nfrom sqlalchemy.orm import Mapped, Session, declarative_base\n\nfrom starlite import DTOFactory, HTTPException, Starlite, get, post\nfrom starlite.plugins.sql_alchemy import SQLAlchemyConfig, SQLAlchemyPlugin\nfrom starlite.status_codes import HTTP_404_NOT_FOUND\n\nBase = declarative_base()\n\nsqlalchemy_config = SQLAlchemyConfig(connection_string=\"sqlite+pysqlite:///test.sqlite\", use_async_engine=False)\nsqlalchemy_plugin = SQLAlchemyPlugin(config=sqlalchemy_config)\ndto_factory = DTOFactory(plugins=[sqlalchemy_plugin])\n\n\nclass Company(Base):  # pyright: ignore\n    __tablename__ = \"company\"\n    id: Mapped[int] = Column(Integer, primary_key=True)\n    name: Mapped[str] = Column(String)\n    worth: Mapped[float] = Column(Float)\n\n\nCreateCompanyDTO = dto_factory(\"CreateCompanyDTO\", Company, exclude=[\"id\"])\n\n\ndef on_startup() -&gt; None:\n    \"\"\"Initialize the database.\"\"\"\n    Base.metadata.create_all(sqlalchemy_config.engine)  # type: ignore\n\n\n@post(path=\"/companies\")\ndef create_company(\n    data: CreateCompanyDTO,  # type: ignore[valid-type]\n    db_session: Session,\n) -&gt; Company:\n    \"\"\"Create a new company and return it.\"\"\"\n    company: Company = data.to_model_instance()  # type: ignore[attr-defined]\n    db_session.add(company)\n    db_session.commit()\n    return company\n\n\n@get(path=\"/companies/{company_id:int}\")\ndef get_company(company_id: str, db_session: Session) -&gt; Company:\n    \"\"\"Get a company by its ID and return it.\n\n    If a company with that ID does not exist, return a 404 response\n    \"\"\"\n    company: Company | None = db_session.scalars(select(Company).where(Company.id == company_id)).one_or_none()\n    if not company:\n        raise HTTPException(detail=f\"Company with ID {company_id} not found\", status_code=HTTP_404_NOT_FOUND)\n    return company\n\n\napp = Starlite(\n    route_handlers=[create_company, get_company],\n    on_startup=[on_startup],\n    plugins=[sqlalchemy_plugin],\n)\n</code></pre>        <p>Using imperative mappings</p> <p>Imperative mappings are supported as well, just make sure to use a mapped class instead of the table itself <pre><code>company_table = Table(\n    \"company\",\n    Base.registry.metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"name\", String),\n    Column(\"worth\", Float),\n)\n\n\nclass Company:\n    pass\n\n\nBase.registry.map_imperatively(Company, company_table)\n</code></pre></p>"},{"location":"usage/10-plugins/1-sql-alchemy-plugin/#relationships","title":"Relationships","text":"<p>Important</p> <p>Currently only to-one relationships are supported because of the way the SQLAlchemy plugin handles relationships. Since it recursively traverses relationships, a cyclic reference will result in an endless loop. To prevent this, these relationships will be type as <code>Any</code> in the pydantic model</p>   <p>Important</p> <p>Relationships are typed as <code>Optional</code> in the pydantic model by default so sending incomplete models won't cause any issues</p>"},{"location":"usage/10-plugins/1-sql-alchemy-plugin/#simple-relationships","title":"Simple relationships","text":"<p>Simple relationships can be handled by the plugin automatically:</p> Python 3.8+Python 3.10+   sqlalchemy_relationships.py<pre><code>from typing import Optional\n\nfrom sqlalchemy import Column, Float, ForeignKey, Integer, String, create_engine, select\nfrom sqlalchemy.orm import Mapped, Session, declarative_base, relationship\n\nfrom starlite import HTTPException, Starlite, get\nfrom starlite.plugins.sql_alchemy import SQLAlchemyConfig, SQLAlchemyPlugin\nfrom starlite.status_codes import HTTP_404_NOT_FOUND\n\nengine = create_engine(\"sqlite+pysqlite://\")\nsqlalchemy_config = SQLAlchemyConfig(engine_instance=engine, use_async_engine=False)\nsqlalchemy_plugin = SQLAlchemyPlugin(config=sqlalchemy_config)\n\nBase = declarative_base()\n\n\nclass Company(Base):  # pyright: ignore\n    __tablename__ = \"company\"\n    id: Mapped[int] = Column(Integer, primary_key=True)\n    name: Mapped[str] = Column(String)\n    worth: Mapped[float] = Column(Float)\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n    id: Mapped[int] = Column(Integer, primary_key=True)\n    name: Mapped[str] = Column(String)\n    company_id: Mapped[int] = Column(Integer, ForeignKey(\"company.id\"))\n    company: Mapped[Company] = relationship(\"Company\", uselist=False)\n\n\nasync def on_startup() -&gt; None:\n    \"\"\"Initialize the database.\"\"\"\n    Base.metadata.create_all(engine)\n    with Session(engine) as session:\n        peter = User(id=1, name=\"Peter\", company=Company(name=\"Peter Co.\", worth=0.0))\n        session.add(peter)\n        session.commit()\n\n\n@get(path=\"/user/{user_id:int}\")\ndef get_user(user_id: int, db_session: Session) -&gt; User:\n    \"\"\"Get a user by its ID and return it.\n\n    If a user with that ID does not exist, return a 404 response\n    \"\"\"\n    user: Optional[User] = db_session.scalars(select(User).where(User.id == user_id)).one_or_none()\n    if not user:\n        raise HTTPException(detail=f\"User with ID {user} not found\", status_code=HTTP_404_NOT_FOUND)\n    return user\n\n\napp = Starlite(\n    route_handlers=[get_user],\n    on_startup=[on_startup],\n    plugins=[sqlalchemy_plugin],\n)\n</code></pre>   sqlalchemy_relationships.py<pre><code>from sqlalchemy import Column, Float, ForeignKey, Integer, String, create_engine, select\nfrom sqlalchemy.orm import Mapped, Session, declarative_base, relationship\n\nfrom starlite import HTTPException, Starlite, get\nfrom starlite.plugins.sql_alchemy import SQLAlchemyConfig, SQLAlchemyPlugin\nfrom starlite.status_codes import HTTP_404_NOT_FOUND\n\nengine = create_engine(\"sqlite+pysqlite://\")\nsqlalchemy_config = SQLAlchemyConfig(engine_instance=engine, use_async_engine=False)\nsqlalchemy_plugin = SQLAlchemyPlugin(config=sqlalchemy_config)\n\nBase = declarative_base()\n\n\nclass Company(Base):  # pyright: ignore\n    __tablename__ = \"company\"\n    id: Mapped[int] = Column(Integer, primary_key=True)\n    name: Mapped[str] = Column(String)\n    worth: Mapped[float] = Column(Float)\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n    id: Mapped[int] = Column(Integer, primary_key=True)\n    name: Mapped[str] = Column(String)\n    company_id: Mapped[int] = Column(Integer, ForeignKey(\"company.id\"))\n    company: Mapped[Company] = relationship(\"Company\", uselist=False)\n\n\nasync def on_startup() -&gt; None:\n    \"\"\"Initialize the database.\"\"\"\n    Base.metadata.create_all(engine)\n    with Session(engine) as session:\n        peter = User(id=1, name=\"Peter\", company=Company(name=\"Peter Co.\", worth=0.0))\n        session.add(peter)\n        session.commit()\n\n\n@get(path=\"/user/{user_id:int}\")\ndef get_user(user_id: int, db_session: Session) -&gt; User:\n    \"\"\"Get a user by its ID and return it.\n\n    If a user with that ID does not exist, return a 404 response\n    \"\"\"\n    user: User | None = db_session.scalars(select(User).where(User.id == user_id)).one_or_none()\n    if not user:\n        raise HTTPException(detail=f\"User with ID {user} not found\", status_code=HTTP_404_NOT_FOUND)\n    return user\n\n\napp = Starlite(\n    route_handlers=[get_user],\n    on_startup=[on_startup],\n    plugins=[sqlalchemy_plugin],\n)\n</code></pre>     <p>In action</p> <p>Run the above with <code>uvicorn sqlalchemy_relationships:app</code>, navigate your browser to <code>http://127.0.0.0:8000/user/1</code> and you will see:</p> <pre><code>{\n  \"id\": 1,\n  \"name\": \"Peter\",\n  \"company_id\": 1,\n  \"company\": {\n    \"id\": 1,\n    \"name\": \"Peter Co.\",\n    \"worth\": 0\n  }\n}\n</code></pre>"},{"location":"usage/10-plugins/1-sql-alchemy-plugin/#to-many-relationships-and-circular-references","title":"To-Many relationships and circular references","text":"<p>For to-many relationships or those that contain circular references you need to define the pydantic models yourself:</p> Python 3.8+Python 3.9+Python 3.10+   sqlalchemy_relationships_to_many<pre><code>from typing import List, Optional\n\nfrom pydantic import BaseModel\nfrom sqlalchemy import Column, ForeignKey, Integer, String, create_engine, select\nfrom sqlalchemy.orm import Mapped, Session, declarative_base, relationship\n\nfrom starlite import HTTPException, Starlite, get\nfrom starlite.plugins.sql_alchemy import SQLAlchemyConfig, SQLAlchemyPlugin\nfrom starlite.status_codes import HTTP_404_NOT_FOUND\n\nengine = create_engine(\"sqlite+pysqlite:///test.sqlite\")\nsqlalchemy_config = SQLAlchemyConfig(engine_instance=engine, use_async_engine=False)\nsqlalchemy_plugin = SQLAlchemyPlugin(config=sqlalchemy_config)\n\nBase = declarative_base()\n\n\nclass Pet(Base):\n    __tablename__ = \"pet\"\n    id: Mapped[int] = Column(Integer, primary_key=True)\n    name: Mapped[str] = Column(String)\n    owner: Mapped[\"User\"] = relationship(\"User\", back_populates=\"pets\", uselist=True)\n    owner_id: Mapped[int] = Column(ForeignKey(\"user.id\"))\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n    id: Mapped[int] = Column(Integer, primary_key=True)\n    name: Mapped[str] = Column(String, default=\"moishe\")\n    pets: Mapped[List[Pet]] = relationship(\"Pet\", uselist=True, back_populates=\"owner\")\n\n\nclass PetModel(BaseModel):\n    class Config:\n        orm_mode = True\n\n    id: int\n    name: str\n\n\nclass UserModel(BaseModel):\n    class Config:\n        orm_mode = True\n\n    id: int\n    name: str\n    pets: List[PetModel]\n\n\ndef on_startup() -&gt; None:\n    \"\"\"Initialize the database.\"\"\"\n    Base.metadata.create_all(engine)\n    with Session(engine) as session:\n        peter = User(id=1, name=\"Peter\", pets=[Pet(id=1, name=\"Paul\")])\n        session.add(peter)\n        session.commit()\n\n\n@get(path=\"/user/{user_id:int}\")\ndef get_user(user_id: int, db_session: Session) -&gt; UserModel:\n    \"\"\"Get a user by its ID and return it.\n\n    If a user with that ID does not exist, return a 404 response\n    \"\"\"\n    user: Optional[User] = db_session.scalars(select(User).where(User.id == user_id)).one_or_none()\n    if not user:\n        raise HTTPException(detail=f\"User with ID {user} not found\", status_code=HTTP_404_NOT_FOUND)\n    return UserModel.from_orm(user)\n\n\napp = Starlite(\n    route_handlers=[get_user],\n    on_startup=[on_startup],\n    plugins=[sqlalchemy_plugin],\n)\n</code></pre>   sqlalchemy_relationships_to_many<pre><code>from typing import Optional\n\nfrom pydantic import BaseModel\nfrom sqlalchemy import Column, ForeignKey, Integer, String, create_engine, select\nfrom sqlalchemy.orm import Mapped, Session, declarative_base, relationship\n\nfrom starlite import HTTPException, Starlite, get\nfrom starlite.plugins.sql_alchemy import SQLAlchemyConfig, SQLAlchemyPlugin\nfrom starlite.status_codes import HTTP_404_NOT_FOUND\n\nengine = create_engine(\"sqlite+pysqlite:///test.sqlite\")\nsqlalchemy_config = SQLAlchemyConfig(engine_instance=engine, use_async_engine=False)\nsqlalchemy_plugin = SQLAlchemyPlugin(config=sqlalchemy_config)\n\nBase = declarative_base()\n\n\nclass Pet(Base):\n    __tablename__ = \"pet\"\n    id: Mapped[int] = Column(Integer, primary_key=True)\n    name: Mapped[str] = Column(String)\n    owner: Mapped[\"User\"] = relationship(\"User\", back_populates=\"pets\", uselist=True)\n    owner_id: Mapped[int] = Column(ForeignKey(\"user.id\"))\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n    id: Mapped[int] = Column(Integer, primary_key=True)\n    name: Mapped[str] = Column(String, default=\"moishe\")\n    pets: Mapped[list[Pet]] = relationship(\"Pet\", uselist=True, back_populates=\"owner\")\n\n\nclass PetModel(BaseModel):\n    class Config:\n        orm_mode = True\n\n    id: int\n    name: str\n\n\nclass UserModel(BaseModel):\n    class Config:\n        orm_mode = True\n\n    id: int\n    name: str\n    pets: list[PetModel]\n\n\ndef on_startup() -&gt; None:\n    \"\"\"Initialize the database.\"\"\"\n    Base.metadata.create_all(engine)\n    with Session(engine) as session:\n        peter = User(id=1, name=\"Peter\", pets=[Pet(id=1, name=\"Paul\")])\n        session.add(peter)\n        session.commit()\n\n\n@get(path=\"/user/{user_id:int}\")\ndef get_user(user_id: int, db_session: Session) -&gt; UserModel:\n    \"\"\"Get a user by its ID and return it.\n\n    If a user with that ID does not exist, return a 404 response\n    \"\"\"\n    user: Optional[User] = db_session.scalars(select(User).where(User.id == user_id)).one_or_none()\n    if not user:\n        raise HTTPException(detail=f\"User with ID {user} not found\", status_code=HTTP_404_NOT_FOUND)\n    return UserModel.from_orm(user)\n\n\napp = Starlite(\n    route_handlers=[get_user],\n    on_startup=[on_startup],\n    plugins=[sqlalchemy_plugin],\n)\n</code></pre>   sqlalchemy_relationships_to_many<pre><code>from pydantic import BaseModel\nfrom sqlalchemy import Column, ForeignKey, Integer, String, create_engine, select\nfrom sqlalchemy.orm import Mapped, Session, declarative_base, relationship\n\nfrom starlite import HTTPException, Starlite, get\nfrom starlite.plugins.sql_alchemy import SQLAlchemyConfig, SQLAlchemyPlugin\nfrom starlite.status_codes import HTTP_404_NOT_FOUND\n\nengine = create_engine(\"sqlite+pysqlite:///test.sqlite\")\nsqlalchemy_config = SQLAlchemyConfig(engine_instance=engine, use_async_engine=False)\nsqlalchemy_plugin = SQLAlchemyPlugin(config=sqlalchemy_config)\n\nBase = declarative_base()\n\n\nclass Pet(Base):\n    __tablename__ = \"pet\"\n    id: Mapped[int] = Column(Integer, primary_key=True)\n    name: Mapped[str] = Column(String)\n    owner: Mapped[\"User\"] = relationship(\"User\", back_populates=\"pets\", uselist=True)\n    owner_id: Mapped[int] = Column(ForeignKey(\"user.id\"))\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n    id: Mapped[int] = Column(Integer, primary_key=True)\n    name: Mapped[str] = Column(String, default=\"moishe\")\n    pets: Mapped[list[Pet]] = relationship(\"Pet\", uselist=True, back_populates=\"owner\")\n\n\nclass PetModel(BaseModel):\n    class Config:\n        orm_mode = True\n\n    id: int\n    name: str\n\n\nclass UserModel(BaseModel):\n    class Config:\n        orm_mode = True\n\n    id: int\n    name: str\n    pets: list[PetModel]\n\n\ndef on_startup() -&gt; None:\n    \"\"\"Initialize the database.\"\"\"\n    Base.metadata.create_all(engine)\n    with Session(engine) as session:\n        peter = User(id=1, name=\"Peter\", pets=[Pet(id=1, name=\"Paul\")])\n        session.add(peter)\n        session.commit()\n\n\n@get(path=\"/user/{user_id:int}\")\ndef get_user(user_id: int, db_session: Session) -&gt; UserModel:\n    \"\"\"Get a user by its ID and return it.\n\n    If a user with that ID does not exist, return a 404 response\n    \"\"\"\n    user: User | None = db_session.scalars(select(User).where(User.id == user_id)).one_or_none()\n    if not user:\n        raise HTTPException(detail=f\"User with ID {user} not found\", status_code=HTTP_404_NOT_FOUND)\n    return UserModel.from_orm(user)\n\n\napp = Starlite(\n    route_handlers=[get_user],\n    on_startup=[on_startup],\n    plugins=[sqlalchemy_plugin],\n)\n</code></pre>     <p>In action</p> <p>Run the above with <code>uvicorn sqlalchemy_relationships_to_many:app</code>, navigate your browser to <code>http://127.0.0.0:8000/user/1</code> and you will see:</p> <pre><code>{\n  \"id\": 1,\n  \"name\": \"Peter\",\n  \"pets\": [\n    {\n      \"id\": 1,\n      \"name\": \"Paul\"\n    }\n  ]\n}\n</code></pre>"},{"location":"usage/10-plugins/1-sql-alchemy-plugin/#configuration","title":"Configuration","text":"<p>You can configure the Plugin using the <code>SQLAlchemyPluginConfig</code> object. See the API Reference for a full list all the options available on SQLAlchemyConfig.</p>"},{"location":"usage/10-plugins/2-tortoise-orm-plugin/","title":"Tortoise ORM Plugin","text":"<p>To use the <code>TortoiseORMPlugin</code> import it and pass it to the Starlite constructor:</p> <pre><code>from typing import cast\n\nfrom tortoise import Model, Tortoise, fields\nfrom tortoise.connection import connections\n\nfrom starlite import Starlite, get, post\nfrom starlite.plugins.tortoise_orm import TortoiseORMPlugin\n\n\nclass Tournament(Model):\n    id = fields.IntField(pk=True)\n    name = fields.TextField()\n    created_at = fields.DatetimeField(auto_now_add=True)\n    optional = fields.TextField(null=True)\n    events: fields.ReverseRelation[\"Event\"]\n\n    class Meta:\n        ordering = [\"name\"]\n\n\nclass Event(Model):\n    id = fields.IntField(pk=True)\n    name = fields.TextField()\n    created_at = fields.DatetimeField(auto_now_add=True)\n    tournament: fields.ForeignKeyNullableRelation[Tournament] = fields.ForeignKeyField(\n        \"models.Tournament\", related_name=\"events\", null=True\n    )\n    participants: fields.ManyToManyRelation[\"Team\"] = fields.ManyToManyField(\n        \"models.Team\", related_name=\"events\", through=\"event_team\"\n    )\n    address: fields.OneToOneNullableRelation[\"Address\"]\n\n    class Meta:\n        ordering = [\"name\"]\n\n\nclass Address(Model):\n    city = fields.CharField(max_length=64)\n    street = fields.CharField(max_length=128)\n    created_at = fields.DatetimeField(auto_now_add=True)\n\n    event: fields.OneToOneRelation[Event] = fields.OneToOneField(\n        \"models.Event\", related_name=\"address\", pk=True\n    )\n\n    class Meta:\n        ordering = [\"city\"]\n\n\nclass Team(Model):\n    id = fields.IntField(pk=True)\n    name = fields.TextField()\n    created_at = fields.DatetimeField(auto_now_add=True)\n\n    events: fields.ManyToManyRelation[Event]\n\n    class Meta:\n        ordering = [\"name\"]\n\n\nasync def init_tortoise() -&gt; None:\n    await Tortoise.init(db_url=\"sqlite://:memory:\", modules={\"models\": [__name__]})\n    await Tortoise.generate_schemas()\n\n\nasync def shutdown_tortoise() -&gt; None:\n    await connections.close_all()\n\n\n@get(\"/tournaments\")\nasync def get_tournaments() -&gt; list[Tournament]:\n    tournaments = await Tournament.all()\n    return cast(\"list[Tournament]\", tournaments)\n\n\n@get(\"/tournaments/{tournament_id:int}\")\nasync def get_tournament(tournament_id: int) -&gt; Tournament:\n    tournament = await Tournament.filter(id=tournament_id).first()\n    return cast(\"Tournament\", tournament)\n\n\n@post(\"/tournaments\")\nasync def create_tournament(data: Tournament) -&gt; Tournament:\n    assert isinstance(data, Tournament)\n    await data.save()\n    await data.refresh_from_db()\n    return data\n\n\napp = Starlite(\n    route_handlers=[get_tournament, get_tournaments, create_tournament],\n    on_startup=[init_tortoise],\n    on_shutdown=[shutdown_tortoise],\n    plugins=[TortoiseORMPlugin()],\n)\n</code></pre> <p>With the plugin in place, you can use any Tortoise model as a type in route handlers.</p>"},{"location":"usage/10-plugins/3-piccolo-orm-plugin/","title":"Piccolo ORM Plugin","text":"<p>To use the <code>PiccoloORMPlugin</code> import it and pass it to the Starlite constructor:</p> <pre><code>from starlite import Starlite, post, get\nfrom starlite.plugins.piccolo_orm import PiccoloORMPlugin\n\nfrom piccolo.columns.column_types import (\n    JSON,\n    JSONB,\n    ForeignKey,\n    Integer,\n    Varchar,\n)\nfrom piccolo.table import Table\n\n\nclass RecordingStudio(Table):\n    facilities = JSON()\n    facilities_b = JSONB()\n\n\nclass Manager(Table):\n    name = Varchar(length=50)\n\n\nclass Band(Table):\n    name = Varchar(length=50)\n    manager = ForeignKey(Manager)\n    popularity = Integer()\n\n\nclass Venue(Table):\n    name = Varchar(length=100)\n    capacity = Integer(secret=True)\n\n\nclass Concert(Table):\n    band_1 = ForeignKey(Band)\n    band_2 = ForeignKey(Band)\n    venue = ForeignKey(Venue)\n\n\n@post(\"/concert\")\nasync def create_concert(data: Concert) -&gt; Concert:\n    await data.save()\n    await data.refresh()\n    return data\n\n\n@get(\"/studio/{studio_id:int}\")\nasync def retrieve_studio(studio_id: int) -&gt; RecordingStudio:\n    return await RecordingStudio.select().where(RecordingStudio.id == studio_id)\n\n\n@get(\"/venues\")\nasync def retrieve_venues() -&gt; list[Venue]:\n    return await Venue.select()\n\n\napp = Starlite(\n    route_handlers=[create_concert, retrieve_studio, retrieve_venues],\n    plugins=[PiccoloORMPlugin()],\n)\n</code></pre> <p>With the plugin in place, you can use any Piccolo tables as a type in route handlers.</p>"},{"location":"usage/11-data-transfer-objects/0-dto/","title":"Data Transfer Objects (DTOs)","text":"<p>Starlite includes a <code>DTOFactory</code> class that allows you to create DTOs from pydantic models, dataclasses, <code>TypedDict</code>, and any other class supported via plugins.</p> <p>An instance of the factory must first be created, optionally passing plugins to it as a kwarg. It can then be used to create a <code>DTO</code> by calling the instance like a function. Additionally, it can exclude (drop) attributes, remap field names and field types, and add new fields.</p> <p>The created <code>DTO</code> can be used for data parsing, validation and OpenAPI schema generation like a regularly declared pydantic model.</p>  <p>Important</p> <p>Although the value generated is a pydantic factory, because it is being generated programmatically, it's currently impossible to extend editor auto-complete for the DTO properties - it will be typed as <code>DTO[T]</code>, with T being a generic argument representing the original model used to create the DTO.</p>   <p>Note</p> <p>MyPy doesn't support using types defined using <code>Type[]</code> as a type, and MyPy will regard these as invalid types. There is currently no way to circumvent this (not even with a plugin) except using a # type: ignore comment.</p>  <p>The <code>DTOFactory</code> class supports plugins, for example, this is how it could be used with an SQLAlchemy declarative class using the SQLAlchemyPlugin:</p> Declaring a DTO<pre><code>from sqlalchemy import Column, Float, Integer, String\nfrom sqlalchemy.orm import Mapped, declarative_base\n\nfrom starlite import DTOFactory\nfrom starlite.plugins.sql_alchemy import SQLAlchemyPlugin\n\ndto_factory = DTOFactory(plugins=[SQLAlchemyPlugin()])\n\nBase = declarative_base()\n\n\nclass Company(Base):  # pyright: ignore\n    __tablename__ = \"company\"\n    id: Mapped[int] = Column(Integer, primary_key=True)  # pyright: ignore\n    name: Mapped[str] = Column(String)  # pyright: ignore\n    worth: Mapped[float] = Column(Float)  # pyright: ignore\n\n\nCompanyDTO = dto_factory(\"CompanyDTO\", Company)\n</code></pre> <p>The created <code>CompanyDTO</code> is equal to this pydantic model declaration:</p> <pre><code>from pydantic import BaseModel\n\n\nclass CompanyDTO(BaseModel):\n    id: int\n    name: str\n    worth: float\n</code></pre> <p>You can now use it in route handler functions as you would any other pydantic model. The one caveat though is lack of editor completion and mypy support - this requires the implementation of a mypy plugin, which is planned for the future.</p>"},{"location":"usage/11-data-transfer-objects/0-dto/#excluding-fields","title":"Excluding Fields","text":"<p>You can exclude any field in the original model class from the <code>DTO</code>:</p> Excluding fields<pre><code>from pydantic import BaseModel\n\nfrom starlite import DTOFactory\n\n\nclass MyClass(BaseModel):\n    first: int\n    second: int\n\n\ndto_factory = DTOFactory()\n\nMyClassDTO = dto_factory(\"MyClassDTO\", MyClass, exclude=[\"first\"])\n</code></pre> <p>The generated <code>MyClassDTO</code> is equal to this model declaration:</p> <pre><code>from pydantic import BaseModel\n\n\nclass MyClassDTO(BaseModel):\n    second: int\n</code></pre>"},{"location":"usage/11-data-transfer-objects/0-dto/#remapping-fields","title":"Remapping Fields","text":"<p>You can remap fields in two ways:</p> <ol> <li>you can switch change their keys:</li> </ol> Remapping fields<pre><code>from pydantic import BaseModel\n\nfrom starlite import DTOFactory\n\n\nclass MyClass(BaseModel):\n    first: int\n    second: int\n\n\ndto_factory = DTOFactory()\n\nMyClassDTO = dto_factory(\"MyClassDTO\", MyClass, field_mapping={\"first\": \"third\"})\n</code></pre> <p>The generated <code>MyClassDTO</code> is equal to this model declaration:</p> <pre><code>from pydantic import BaseModel\n\n\nclass MyClassDTO(BaseModel):\n    second: int\n    third: int\n</code></pre> <p>You can remap name and type. To do this use a tuple instead of a string for the object value:</p> Remapping fields with types<pre><code>from pydantic import BaseModel\n\nfrom starlite import DTOFactory\n\n\nclass MyClass(BaseModel):\n    first: int\n    second: int\n\n\ndto_factory = DTOFactory()\n\nMyClassDTO = dto_factory(\"MyClassDTO\", MyClass, field_mapping={\"first\": \"third\", \"second\": (\"fourth\", float)})\n</code></pre> <p>The generated <code>MyClassDTO</code> is equal to this model declaration:</p> <pre><code>from pydantic import BaseModel\n\n\nclass MyClassDTO(BaseModel):\n    third: int\n    fourth: float\n</code></pre>"},{"location":"usage/11-data-transfer-objects/0-dto/#add-new-fields","title":"Add New Fields","text":"<p>You add fields that do not exist in the original model by passing in a <code>field_definitions</code> dictionary. This dictionary should have field names as keys, and a tuple following the format supported by the pydantic create_model helper:</p> <ol> <li>For required fields use a tuple of type + ellipsis, for example <code>(str, ...)</code>.</li> <li>For optional fields use a tuple of type + <code>None</code>, for example <code>(str, None)</code></li> <li>To set a default value use a tuple of type + default value, for example <code>(str, \"Hello World\")</code></li> </ol> Add new fields<pre><code>from pydantic import BaseModel\n\nfrom starlite import DTOFactory\n\n\nclass MyClass(BaseModel):\n    first: int\n    second: int\n\n\ndto_factory = DTOFactory()\n\nMyClassDTO = dto_factory(\"MyClassDTO\", MyClass, field_definitions={\"third\": (str, ...)})\n</code></pre> <p>The generated <code>MyClassDTO</code> is equal to this model declaration:</p> <pre><code>from pydantic import BaseModel\n\n\nclass MyClassDTO(BaseModel):\n    first: int\n    second: int\n    third: str\n</code></pre>"},{"location":"usage/11-data-transfer-objects/0-dto/#dto-methods","title":"DTO Methods","text":""},{"location":"usage/11-data-transfer-objects/0-dto/#dtofrom_model_instance","title":"DTO.from_model_instance()","text":"<p>Once you create a DTO class you can use its class method <code>from_model_instance()</code> to create an instance from an existing instance of the model from which the DTO was generated:</p> DTO.from_model_instance()<pre><code>from sqlalchemy import Column, Float, Integer, String\nfrom sqlalchemy.orm import Mapped, declarative_base\n\nfrom starlite import DTOFactory\nfrom starlite.plugins.sql_alchemy import SQLAlchemyPlugin\n\ndto_factory = DTOFactory(plugins=[SQLAlchemyPlugin()])\n\nBase = declarative_base()\n\n\nclass Company(Base):  # pyright: ignore\n    __tablename__ = \"company\"\n\n    id: Mapped[int] = Column(Integer, primary_key=True)  # pyright: ignore\n    name: Mapped[str] = Column(String)  # pyright: ignore\n    worth: Mapped[float] = Column(Float)  # pyright: ignore\n\n\nCompanyDTO = dto_factory(\"CompanyDTO\", Company)\n\ncompany_instance = Company(id=1, name=\"My Firm\", worth=1000000.0)\n\ndto_instance = CompanyDTO.from_model_instance(company_instance)\n</code></pre> <p>In the above, <code>dto_instance</code> is a validated pydantic model instance.</p>"},{"location":"usage/11-data-transfer-objects/0-dto/#dtoto_model_instance","title":"DTO.to_model_instance()","text":"<p>When you have an instance of a <code>DTO</code> model, you can convert it into a model instance using the <code>to_model_instance()</code> method:</p> DTO.to_model_instance()<pre><code>from sqlalchemy import Column, Float, Integer, String\nfrom sqlalchemy.orm import Mapped, declarative_base\n\nfrom starlite import DTOFactory, post\nfrom starlite.plugins.sql_alchemy import SQLAlchemyPlugin\n\ndto_factory = DTOFactory(plugins=[SQLAlchemyPlugin()])\n\nBase = declarative_base()\n\n\nclass Company(Base):  # pyright: ignore\n    __tablename__ = \"company\"\n\n    id: Mapped[int] = Column(Integer, primary_key=True)  # pyright: ignore\n    name: Mapped[str] = Column(String)  # pyright: ignore\n    worth: Mapped[float] = Column(Float)  # pyright: ignore\n\n\nCompanyDTO = dto_factory(\"CompanyDTO\", Company)\n\n\n@post()\ndef create_company(data: CompanyDTO) -&gt; Company:  # type: ignore\n    return data.to_model_instance()  # type: ignore\n</code></pre> <p>In the above <code>company_instance</code> is an instance of the SQLAlchemy declarative class <code>Company</code>. It is correctly typed as <code>Company</code> because the <code>DTO</code> class uses generic to store this data.</p>  <p>Important</p> <p>If you exclude keys or add additional fields, you should make sure this does not cause an error when trying to generate a model class from a dto instance. For example, if you exclude required fields from a pydantic model and try to create an instance from a dto that doesn't have these, a validation error will be raised.</p>"},{"location":"usage/11-data-transfer-objects/0-dto/#automatic-conversion-on-response","title":"Automatic Conversion on Response","text":"<p>When you use a DTO as a return type in a route handler, if the returned data is a model or a dict, it will be converted to the DTO automatically:</p> Python 3.8+Python 3.9+   DTO automatic conversion<pre><code>from typing import List\n\nfrom sqlalchemy import Column, Float, Integer, String\nfrom sqlalchemy.orm import Mapped, declarative_base\n\nfrom starlite import DTOFactory, HTTPException, Starlite, get\nfrom starlite.plugins.sql_alchemy import SQLAlchemyPlugin\nfrom starlite.status_codes import HTTP_404_NOT_FOUND\n\nsqlalchemy_plugin = SQLAlchemyPlugin()\ndto_factory = DTOFactory(plugins=[sqlalchemy_plugin])\n\nBase = declarative_base()\n\n\nclass Company(Base):  # pyright: ignore\n    __tablename__ = \"company\"\n\n    id: Mapped[int] = Column(Integer, primary_key=True)  # pyright: ignore\n    name: Mapped[str] = Column(String)  # pyright: ignore\n    worth: Mapped[float] = Column(Float)  # pyright: ignore\n    secret: Mapped[str] = Column(String)  # pyright: ignore\n\n\nReadCompanyDTO = dto_factory(\"CompanyDTO\", Company, exclude=[\"secret\"])\n\ncompanies: List[Company] = [\n    Company(id=1, name=\"My Firm\", worth=1000000.0, secret=\"secret\"),\n    Company(id=2, name=\"My New Firm\", worth=1000.0, secret=\"abc123\"),\n]\n\n\n@get(\"/{company_id: int}\")\ndef get_company(company_id: int) -&gt; ReadCompanyDTO:  # type: ignore\n    try:\n        return companies[company_id - 1]\n    except IndexError:\n        raise HTTPException(\n            detail=\"Company not found\",\n            status_code=HTTP_404_NOT_FOUND,\n        )\n\n\n@get()\ndef get_companies() -&gt; List[ReadCompanyDTO]:  # type: ignore\n    return companies\n\n\napp = Starlite(\n    route_handlers=[get_company, get_companies],\n    plugins=[sqlalchemy_plugin],\n)\n</code></pre>   DTO automatic conversion<pre><code>from sqlalchemy import Column, Float, Integer, String\nfrom sqlalchemy.orm import Mapped, declarative_base\n\nfrom starlite import DTOFactory, HTTPException, Starlite, get\nfrom starlite.plugins.sql_alchemy import SQLAlchemyPlugin\nfrom starlite.status_codes import HTTP_404_NOT_FOUND\n\nsqlalchemy_plugin = SQLAlchemyPlugin()\ndto_factory = DTOFactory(plugins=[sqlalchemy_plugin])\n\nBase = declarative_base()\n\n\nclass Company(Base):  # pyright: ignore\n    __tablename__ = \"company\"\n\n    id: Mapped[int] = Column(Integer, primary_key=True)  # pyright: ignore\n    name: Mapped[str] = Column(String)  # pyright: ignore\n    worth: Mapped[float] = Column(Float)  # pyright: ignore\n    secret: Mapped[str] = Column(String)  # pyright: ignore\n\n\nReadCompanyDTO = dto_factory(\"CompanyDTO\", Company, exclude=[\"secret\"])\n\ncompanies: list[Company] = [\n    Company(id=1, name=\"My Firm\", worth=1000000.0, secret=\"secret\"),\n    Company(id=2, name=\"My New Firm\", worth=1000.0, secret=\"abc123\"),\n]\n\n\n@get(\"/{company_id: int}\")\ndef get_company(company_id: int) -&gt; ReadCompanyDTO:  # type: ignore\n    try:\n        return companies[company_id - 1]\n    except IndexError:\n        raise HTTPException(\n            detail=\"Company not found\",\n            status_code=HTTP_404_NOT_FOUND,\n        )\n\n\n@get()\ndef get_companies() -&gt; list[ReadCompanyDTO]:  # type: ignore\n    return companies\n\n\napp = Starlite(\n    route_handlers=[get_company, get_companies],\n    plugins=[sqlalchemy_plugin],\n)\n</code></pre>    <p>In the above, when requesting route of a company, the <code>secret</code> attribute will not be included in the response. And it also works when returning a list of companies.</p>"},{"location":"usage/11-data-transfer-objects/1-partial/","title":"Partial DTOs","text":"<p>For PATCH HTTP methods, you may only need to partially modify a resource. In these cases, DTOs can be wrapped with <code>Partial</code>.</p> <pre><code>from pydantic import BaseModel\nfrom starlite.types.partial import Partial\n\n\nclass CompanyDTO(BaseModel):\n    id: int\n    name: str\n    worth: float\n\n\nPartialCompanyDTO = Partial[CompanyDTO]\n</code></pre> <p>The created <code>PartialCompanyDTO</code> is equivalent to the following declaration:</p> Python 3.8+Python 3.10+   <pre><code>from typing import Optional\nfrom pydantic import BaseModel\n\n\nclass PartialCompanyDTO(BaseModel):\n    id: Optional[int]\n    name: Optional[str]\n    worth: Optional[float]\n</code></pre>   <pre><code>from pydantic import BaseModel\n\n\nclass PartialCompanyDTO(BaseModel):\n    id: int | None\n    name: str | None\n    worth: float | None\n</code></pre>    <p><code>Partial</code> can also be used inline when creating routes.</p> <pre><code>from pydantic import UUID4, BaseModel\nfrom starlite.controller import Controller\nfrom starlite.handlers import patch\nfrom starlite.types.partial import Partial\n\n\nclass UserOrder(BaseModel):\n    order_id: UUID4\n    order_item_id: UUID4\n    notes: str\n\n\nclass UserOrderController(Controller):\n    path = \"/user\"\n\n    @patch(path=\"/{order_id:uuid}\")\n    async def update_user_order(\n        self, order_id: UUID4, data: Partial[UserOrder]\n    ) -&gt; UserOrder:\n        ...\n</code></pre>"},{"location":"usage/12-openapi/0-openapi-intro/","title":"OpenAPI Integration","text":"<p>Starlite has first class OpenAPI support offering the following features:</p> <ol> <li>Automatic OpenAPI 3.1.0 Schema generation, which is available as both YAML    and JSON.</li> <li>Builtin support for static documentation site generation using several different libraries.</li> <li>Simple configuration using pydantic based classes.</li> </ol>"},{"location":"usage/12-openapi/0-openapi-intro/#pydantic-openapi-schema","title":"Pydantic-OpenAPI-Schema","text":"<p>Starlite generates the latest version of the OpenAPI specification using the pydantic-openapi-schema library, which is bundled as part of Starlite and is also maintained by the starlite-api GitHub organization.</p> <p>This library offers a full implementation of the OpenAPI specification as pydantic models, and is as such a powerful and type correct foundation for schema generation using python.</p>  <p>Tip</p> <p>You can refer to the pydantic-openapi-schema doc for a full reference regarding the library's API.</p>"},{"location":"usage/12-openapi/1-schema-generation/","title":"OpenAPI Schema Generation Config","text":"<p>OpenAPI schema generation is enabled by default. To configure it you can pass an instance of <code>OpenAPIConfig</code> to the Starlite constructor using the <code>openapi_config</code> kwarg:</p> <pre><code>from starlite import Starlite, OpenAPIConfig\n\napp = Starlite(\n    route_handlers=[...], openapi_config=OpenAPIConfig(title=\"My API\", version=\"1.0.0\")\n)\n</code></pre> <p>Aside from <code>title</code> and <code>version</code>, both of which are required, you can pass the following optional kwargs:</p> <ul> <li><code>components</code>: An instance of <code>Components</code> or list of instances.   If a list is provided, its members will be merged recursively into a single instance.</li> <li><code>contact</code>: An instance of the <code>Contact</code>.</li> <li><code>create_examples</code>: Boolean flag dictating whether examples will be auto-generated using   the pydantic-factories library. Defaults to <code>False</code>.</li> <li><code>description</code>: Description text.</li> <li><code>external_docs</code>: An instance of   the <code>ExternalDocumentation</code>.</li> <li><code>license</code>: An instance of the <code>License</code>.</li> <li><code>openapi_controller</code>: The controller class to use for the openapi to generate the openapi related routes. Must be a   subclass of the openapi controller class.</li> <li><code>security</code>: An instance of the <code>SecurityRequirement</code></li> <li><code>servers</code>: A list of <code>Server</code> instances. Defaults to <code>[Server(\"/\")]</code></li> <li><code>summary</code>: Summary text.</li> <li><code>tags</code>: A list of <code>Tag</code> instances.</li> <li><code>terms_of_service</code>: A url to a page containing the terms of service.</li> <li><code>use_handler_docstrings</code>: Boolean flag dictating whether to use route handler docstring to generate descriptions.</li> <li><code>webhooks</code>: A string keyed dictionary of <code>PathItem</code> instances. #</li> <li><code>root_schema_site</code>: Dictates which schema site is served by default.   The value should be one of <code>redoc</code>, <code>swagger</code>, <code>elements</code>, with the default be <code>redoc</code>.</li> <li><code>enabled_endpoints</code>: Dictates which schema site endpoints are enabled.   It may have the following values <code>redoc</code>, <code>swagger</code>, <code>elements</code>, <code>openapi.json</code>, <code>openapi.yaml</code>. By default, it enables all endpoints.</li> </ul>"},{"location":"usage/12-openapi/1-schema-generation/#disabling-schema-generation","title":"Disabling Schema Generation","text":"<p>If you wish to disable schema generation and not include the schema endpoints in your API, simply pass <code>None</code> as the value for <code>openapi_config</code>:</p> <pre><code>from starlite import Starlite\n\napp = Starlite(route_handlers=[...], openapi_config=None)\n</code></pre>"},{"location":"usage/12-openapi/2-route-handler-configuration/","title":"Route Handler OpenAPI Configuration","text":"<p>By default, an operation schema is generated for all route handlers. You can omit a route handler from the schema by setting <code>include_in_schema=False</code>:</p> <pre><code>from starlite import get\n\n\n@get(path=\"/some-path\", include_in_schema=False)\ndef my_route_handler() -&gt; None:\n    ...\n</code></pre> <p>You can also modify the generated schema for the route handler using the following kwargs:</p> <ul> <li><code>tags</code>: A list of strings that correlate to   the tag specification.</li> <li><code>security</code>: A list of dictionaries that correlate to   the security requirements specification. The   values for this key are string keyed dictionaries with the values being a list of objects.</li> <li><code>summary</code>: Text used for the route's schema summary section.</li> <li><code>description</code>: Text used for the route's schema description section.</li> <li><code>response_description</code>: Text used for the route's response schema description section.</li> <li><code>operation_id</code>: An identifier used for the route's schema operationId. Defaults to the <code>__name__</code> attribute of the   wrapped function.</li> <li><code>deprecated</code>: A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. Defaults   to <code>False</code>.</li> <li><code>raises</code>: A list of exception classes extending from <code>starlite.HttpException</code>. This list should describe all   exceptions raised within the route handler's function/method. The Starlite <code>ValidationException</code> will be added   automatically for the schema if any validation is involved (e.g. there are parameters specified in the   method/function).</li> <li><code>responses</code>: A dictionary of additional status codes and a description of their expected content.     The expected content should be based on a Pydantic model describing its structure. It can also include     a description and the expected media type. For example:</li> </ul>  <p>Note</p> <p><code>operation_id</code> will be prefixed with the method name when function is decorated with <code>HTTPRouteHandler</code> and multiple <code>http_method</code>. Will also be prefixed with path strings used in <code>Routers</code> and <code>Controllers</code> to make sure id is unique.</p>  Python 3.8+Python 3.10+   <pre><code>from datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\nfrom starlite import ResponseSpec, get\n\n\nclass Item(BaseModel):\n    ...\n\n\nclass ItemNotFound(BaseModel):\n    was_removed: bool\n    removed_at: Optional[datetime]\n\n\n@get(\n    path=\"/items/{pk:int}\",\n    responses={\n        404: ResponseSpec(\n            model=ItemNotFound, description=\"Item was removed or not found\"\n        )\n    },\n)\ndef retrieve_item(pk: int) -&gt; Item:\n    ...\n</code></pre>   <pre><code>from datetime import datetime\n\nfrom pydantic import BaseModel\n\nfrom starlite import ResponseSpec, get\n\n\nclass Item(BaseModel):\n    ...\n\n\nclass ItemNotFound(BaseModel):\n    was_removed: bool\n    removed_at: datetime | None\n\n\n@get(\n    path=\"/items/{pk:int}\",\n    responses={\n        404: ResponseSpec(\n            model=ItemNotFound, description=\"Item was removed or not found\"\n        )\n    },\n)\ndef retrieve_item(pk: int) -&gt; Item:\n    ...\n</code></pre>    <p>You can also specify <code>security</code> and <code>tags</code> on higher level of the application, e.g. on a controller, router or the app instance itself. For example:</p> <pre><code>from starlite import Starlite, OpenAPIConfig, get\nfrom pydantic_openapi_schema.v3_1_0 import Components, SecurityScheme, Tag\n\n\n@get(\n    \"/public\",\n    tags=[\"public\"],\n    security=[{}],  # this endpoint is marked as having optional security\n)\ndef public_path_handler() -&gt; dict[str, str]:\n    return {\"hello\": \"world\"}\n\n\n@get(\"/other\", tags=[\"internal\"], security=[{\"apiKey\": []}])\ndef internal_path_handler() -&gt; None:\n    ...\n\n\napp = Starlite(\n    route_handlers=[public_path_handler, internal_path_handler],\n    openapi_config=OpenAPIConfig(\n        title=\"my api\",\n        version=\"1.0.0\",\n        tags=[\n            Tag(name=\"public\", description=\"This endpoint is for external users\"),\n            Tag(name=\"internal\", description=\"This endpoint is for internal users\"),\n        ],\n        security=[{\"BearerToken\": []}],\n        components=Components(\n            securitySchemes={\n                \"BearerToken\": SecurityScheme(\n                    type=\"http\",\n                    scheme=\"bearer\",\n                )\n            },\n        ),\n    ),\n)\n</code></pre>"},{"location":"usage/12-openapi/3-openapi-controller/","title":"The OpenAPIController","text":"<p>Starlite includes an <code>OpenAPIController</code> class that is used as the default controller in the OpenAPIConfig.</p> <p>This controller exposes the following endpoints:</p> <ul> <li><code>/schema/openapi.yaml</code>: allowing for download of the OpenAPI schema as YAML.</li> <li><code>/schema/openapi.json</code>: allowing for download of the OpenAPI schema as JSON.</li> <li><code>/schema/redoc</code>: which serve the docs using Redoc.</li> <li><code>/schema/swagger</code>: which serves the docs using Swagger-UI.</li> <li><code>/schema/elements</code>: which serves the docs using Stoplight Elements.</li> </ul> <p>Additionally, the root <code>/schema/</code> path is accessible, serving the site that is configured as the default in the <code>OpenAPIConfig</code>.</p>"},{"location":"usage/12-openapi/3-openapi-controller/#subclassing-openapicontroller","title":"Subclassing OpenAPIController","text":"<p>You can use your own subclass of <code>OpenAPIController</code> by setting it as then controller to use in the <code>OpenAPIConfig</code> <code>openapi_controller</code> kwarg.</p> <p>For example, lets say we wanted to change the base path of the OpenAPI related endpoints from <code>/schema</code> to <code>/api-docs</code>, in this case we'd the following:</p> <pre><code>from starlite import Starlite, OpenAPIController, OpenAPIConfig\n\n\nclass MyOpenAPIController(OpenAPIController):\n    path = \"/api-docs\"\n\n\napp = Starlite(\n    route_handlers=[...],\n    openapi_config=OpenAPIConfig(\n        title=\"My API\", version=\"1.0.0\", openapi_controller=MyOpenAPIController\n    ),\n)\n</code></pre> <p>See the API Reference for full details on the <code>OpenAPIController</code> class and the kwargs it accepts.</p>"},{"location":"usage/12-openapi/3-openapi-controller/#cdn-and-offline-file-support","title":"CDN and offline file support","text":"<p>You can change the default download paths for JS and CSS bundles as well as google fonts by subclassing <code>OpenAPIController</code>  and setting any of the following class variables:</p> <pre><code>from starlite import Starlite, OpenAPIController, OpenAPIConfig\n\n\nclass MyOpenAPIController(OpenAPIController):\n    path = \"/api-docs\"\n    redoc_google_fonts = False\n    redoc_js_url = \"https://offline_location/redoc.standalone.js\"\n    swagger_css_url = \"https://offline_location/swagger-ui-css\"\n    swagger_ui_bundle_js_url = \"https://offline_location/swagger-ui-bundle.js\"\n    swagger_ui_standalone_preset_js_url = (\n        \"https://offline_location/swagger-ui-standalone-preset.js\"\n    )\n    stoplight_elements_css_url = \"https://offline_location/spotlight-styles.mins.css\"\n    stoplight_elements_js_url = (\n        \"https://offline_location/spotlight-web-components.min.js\"\n    )\n\n\napp = Starlite(\n    route_handlers=[...],\n    openapi_config=OpenAPIConfig(\n        title=\"My API\", version=\"1.0.0\", openapi_controller=MyOpenAPIController\n    ),\n)\n</code></pre>"},{"location":"usage/12-openapi/4-viewing-and-accessing-schema/","title":"Viewing and Accessing Schema","text":"<p>Starlite comes with multiple integrations for documentation site generators. You can view and download your schema using the endpoints exposed by the OpenAPIController. For example, if you are running your app locally on <code>0.0.0.0:8000</code>, you would be able to:</p> <ul> <li>view your documentation in a Redoc site under <code>http://0.0.0.0:8000/schema/redoc</code>.</li> <li>view your documentation in a SwaggerUI site under <code>http://0.0.0.0:8000/schema/swagger</code>.</li> <li>view your documentation in a StopLight Elements site under <code>http://0.0.0.0:8000/schema/elements</code>.</li> <li>download your documentation as YAML using <code>http://0.0.0.0:8000/schema/openapi.yaml</code>.</li> <li>download your documentation as JSON using <code>http://0.0.0.0:8000/schema/openapi.json</code>.</li> </ul>"},{"location":"usage/12-openapi/4-viewing-and-accessing-schema/#accessing-the-openapi-schema-in-code","title":"Accessing the OpenAPI Schema in Code","text":"<p>The OpenAPI schema is generated during the Starlite app's init method. Once init is finished, its accessible as <code>app.openapi_schema</code>. As such you can always access it inside route handlers, dependencies etc. by access the request instance:</p> <pre><code>from starlite import Request, get\n\n\n@get(path=\"/\")\ndef my_route_handler(request: Request) -&gt; dict:\n    schema = request.app.openapi_schema\n    return schema.dict()\n</code></pre>"},{"location":"usage/12-openapi/5-customizing-pydantic-model-schemas/","title":"Customizing Pydantic Model Schemas","text":"<p>You can customize the OpenAPI schemas generated for pydantic models by following the guidelines in the pydantic docs.</p> <p>Additionally, you can affect how pydantic models are translated into OpenAPI <code>components</code> by settings a special dunder attribute on the model called <code>__schema_name__</code>:</p> Customize Components Example<pre><code>from uuid import UUID, uuid4\n\nfrom pydantic import BaseModel\n\nfrom starlite import Starlite, get\n\n\nclass IdModel(BaseModel):\n    __schema_name__ = \"IdContainer\"\n\n    id: UUID\n\n\n@get(\"/id\")\ndef retrieve_id_handler() -&gt; IdModel:\n    \"\"\"\n\n    Returns: An IdModel\n\n    \"\"\"\n    return IdModel(id=uuid4())\n\n\napp = Starlite(route_handlers=[retrieve_id_handler])\n</code></pre> <p>The above will result in an OpenAPI schema object that looks like this:</p> <pre><code>{\n    \"openapi\": \"3.1.0\",\n    \"info\": {\"title\": \"Starlite API\", \"version\": \"1.0.0\"},\n    \"servers\": [{\"url\": \"/\"}],\n    \"paths\": {\n        \"/id\": {\n            \"get\": {\n                \"operationId\": \"Retrieve Id Handler\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"Request fulfilled, document follows\",\n                        \"headers\": {},\n                        \"content\": {\n                            \"application/json\": {\n                                \"media_type_schema\": {\n                                    \"ref\": \"#/components/schemas/IdContainer\"\n                                }\n                            }\n                        },\n                    }\n                },\n                \"deprecated\": False,\n            }\n        }\n    },\n    \"components\": {\n        \"schemas\": {\n            \"IdContainer\": {\n                \"properties\": {\n                    \"id\": {\"type\": \"string\", \"schema_format\": \"uuid\", \"title\": \"Id\"}\n                },\n                \"type\": \"object\",\n                \"required\": [\"id\"],\n                \"title\": \"IdContainer\",\n            }\n        }\n    },\n}\n</code></pre>  <p>Important</p> <p>If you use multiple pydantic models that use the same name in the schema, you will need to use the <code>__schema_name__</code> dunder to ensure each has a unique name in the schema, otherwise the schema components will be ambivalent.</p>"},{"location":"usage/15-caching/0-cache-backends/","title":"Cache Backends","text":"<p>Starlite includes a builtin Cache that offers a uniform interface to interact with different \"Cache Backends\". A Cache Backend is a class that either implements or fulfills the interface specified by <code>CacheBackendProtocol</code> to provide cache services.</p>"},{"location":"usage/15-caching/0-cache-backends/#builtin-cache-backends","title":"Builtin Cache Backends","text":"<p>Starlite comes with the following builtin cache backends:</p> <p>By default, Starlite uses the <code>SimpleCacheBackend</code>, which stores values in local memory with the added security of async locks. This is fine for local development, but it's not a good solution for production environments.</p> <p>Starlite also ships with two other ready to use cache backends:</p> <p><code>RedisCacheBackend</code>, which uses Redis as the caching database. Under the hood it uses   redis-py asyncio to make sure requests are   not blocked and hiredis to boost performance.</p>  <p>Note</p> <p><code>redis</code> is a required dependency when using this backend. You can install it as an extra with <code>pip install starlite[redis]</code> or independently.</p>  <p><code>MemcachedCacheBackend</code>, which uses   memcached as the caching database. Under the hood it uses   aiomcache to make sure requests are not blocked.</p>  <p>Note</p> <p><code>memcached</code> is a required dependency when using this backend. You can install it as an extra with <code>pip install starlite[memcached]</code> or independently.</p>"},{"location":"usage/15-caching/0-cache-backends/#configuring-caching","title":"Configuring Caching","text":"<p>You can configure caching behaviour on the application level by passing an instance of <code>CacheConfig</code> to the Starlite constructor. See the API Reference for full details on the <code>CacheConfig</code> class and the kwargs it accepts.</p> <p>Here is an example of how to configure Redis as the cache backend:</p> <pre><code>from starlite import CacheConfig\nfrom starlite.cache.redis_cache_backend import (\n    RedisCacheBackendConfig,\n    RedisCacheBackend,\n)\n\nconfig = RedisCacheBackendConfig(url=\"redis://localhost/\", port=6379, db=0)\nredis_backend = RedisCacheBackend(config=config)\n\ncache_config = CacheConfig(backend=redis_backend)\n</code></pre> <p>Or using Memcached:</p> <pre><code>from starlite import CacheConfig\nfrom starlite.cache.memcached_cache_backend import (\n    MemcachedCacheBackendConfig,\n    MemcachedCacheBackend,\n)\n\nconfig = MemcachedCacheBackendConfig(url=\"127.0.0.1\", port=11211)\nmemcached_backend = MemcachedCacheBackend(config=config)\n\ncache_config = CacheConfig(backend=memcached_backend)\n</code></pre>"},{"location":"usage/15-caching/0-cache-backends/#creating-a-custom-cache-backend","title":"Creating a Custom Cache Backend","text":"<p>Since Starlite relies on the <code>CacheBackendProtocol</code> to define cache, creating a custom cache backend is very simple - all that is required is to create a class that inherits from the protocol and implements all its methods, or even a class that simply implements these methods without inheriting from the protocol. Once this is done, you can use the backend in the cache config.</p>"},{"location":"usage/15-caching/1-response-caching/","title":"Response Caching","text":"<p>Sometimes it's desirable to cache some responses, especially if these involve expensive calculations, or when polling is expected. Starlite comes with a simple mechanism for caching:</p> <pre><code>from starlite import get\n\n\n@get(\"/cached-path\", cache=True)\ndef my_cached_handler() -&gt; str:\n    ...\n</code></pre> <p>By setting <code>cache=True</code> in the route handler, caching for the route handler will be enabled for the default duration, which is 60 seconds unless modified.</p> <p>Alternatively you can specify the number of seconds to cache the responses from the given handler like so:</p> <pre><code>from starlite import get\n\n\n@get(\"/cached-path\", cache=120)  # seconds\ndef my_cached_handler() -&gt; str:\n    ...\n</code></pre>"},{"location":"usage/15-caching/1-response-caching/#specifying-a-cache-key-builder","title":"Specifying a Cache Key Builder","text":"<p>Starlite uses the request's path + sorted query parameters as the cache key. You can provide a \"Key Builder\" function to the route handler if you want to generate different cache keys:</p> <pre><code>from starlite import Request, get\n\n\ndef my_custom_key_builder(request: Request) -&gt; str:\n    return request.url.path + request.headers.get(\"my-header\", \"\")\n\n\n@get(\"/cached-path\", cache=True, cache_key_builder=my_custom_key_builder)\ndef my_cached_handler() -&gt; str:\n    ...\n</code></pre> <p>You can also specify the default cache key builder to use for the entire application (see below).</p>"},{"location":"usage/15-caching/2-interacting-with-cache/","title":"Interacting with the Cache","text":"<p>The Starlite app's cache is exposed as <code>app.cache</code>, which makes it accessible via the <code>scope</code> object. For example, you can access the cache in a custom middleware thus:</p> <pre><code>from starlite import MiddlewareProtocol\nfrom starlite.types import Scope, Receive, Send, ASGIApp\n\n\nclass MyMiddleware(MiddlewareProtocol):\n    def __init__(self, app: ASGIApp):\n        self.app = app\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n        cached_value = await scope[\"app\"].cache.get(\"my-key\")\n        if cached_value:\n            ...\n</code></pre> <p>The cache is also exposed as a property on the <code>ASGIConnection</code> and the <code>Request</code> and <code>WebSocket</code> classes that inherit from it. You can thus interact with the cache inside a route handler easily, for example by doing this:</p> <pre><code>from starlite import Request, get\n\n\n@get(\"/\")\nasync def my_handler(request: Request) -&gt; None:\n    cached_value = await request.cache.get(\"my-key\")\n    if cached_value:\n        ...\n</code></pre>  <p>Important</p> <p>Cache based operations are async because async locking is used to protect against race conditions. If you need to use caching - use an async route handler.</p>"},{"location":"usage/18-contrib/0-open-telemetry/","title":"Open Telemetry Instrumentation","text":"<p>Starlite includes optional OpenTelemetry instrumentation that is exported from <code>starlite.contrib.opentelemtry</code>. To use this package, you should first install the required dependencies:</p> as separate packages<pre><code>pip install opentelemetry-instrumentation-asgi\n</code></pre> <p>Or by installing Starlite with the <code>opentelemetry</code> extra:</p> as 'extra' dependencies<pre><code>pip install starlite[opentelemetry]\n</code></pre> <p>Once these requirements are satisfied, you can instrument your Starlite application by creating an instance of OpenTelemetryConfig and passing the middleware it creates to the Starlite constructor:</p> <pre><code>from starlite import Starlite\nfrom starlite.contrib.opentelemetry import OpenTelemetryConfig\n\nopen_telemetry_config = OpenTelemetryConfig()\n\napp = Starlite(route_handlers=[], middleware=[open_telemetry_config.middleware])\n</code></pre> <p>The above example will work out of the box if you configure a global <code>tracer_provider</code> and/or <code>metric_provider</code> and an exporter to use these (see the OpenTelemetry Exporter docs for further details).</p> <p>You can also pass con figuration to the <code>OpenTelemetryConfig</code> telling it which providers to use. Consult reference docs regarding the configuration options you can use.</p>"},{"location":"usage/18-contrib/1-jwt/","title":"JWT Security Backends","text":"<p>Starlite offers optional JWT based security backends. To use these make sure to install the <code>python-jose</code> and <code>cryptography</code> packages, or simply install Starlite with the jwt extra: <code>pip install starlite[jwt]</code>.</p>"},{"location":"usage/18-contrib/1-jwt/#jwt-auth-backend","title":"JWT Auth Backend","text":"<p>This is the base JWT Auth backend. You can read about its particular API in the API Reference. It sends the JWT token using a header - and it expects requests to send the JWT token using the same header key.</p> Python 3.8+Python 3.10+   Using JWT Auth<pre><code>from os import environ\nfrom typing import Any, Optional\nfrom uuid import UUID\n\nfrom pydantic import BaseModel, EmailStr\n\nfrom starlite import (\n    ASGIConnection,\n    OpenAPIConfig,\n    Request,\n    Response,\n    Starlite,\n    get,\n    post,\n)\nfrom starlite.contrib.jwt import JWTAuth, Token\n\n\n# Let's assume we have a User model that is a pydantic model.\n# This though is not required - we need some sort of user class -\n# but it can be any arbitrary value, e.g. an SQLAlchemy model, a representation of a MongoDB  etc.\nclass User(BaseModel):\n    id: UUID\n    name: str\n    email: EmailStr\n\n\n# JWTAuth requires a retrieve handler callable that receives the JWT token model and the ASGI connection\n# and returns the 'User' instance correlating to it.\n#\n# Notes:\n# - 'User' can be any arbitrary value you decide upon.\n# - The callable can be either sync or async - both will work.\nasync def retrieve_user_handler(token: Token, connection: ASGIConnection[Any, Any, Any]) -&gt; Optional[User]:\n    # logic here to retrieve the user instance\n    cached_value = await connection.cache.get(token.sub)\n    if cached_value:\n        return User(**cached_value)\n    return None\n\n\njwt_auth = JWTAuth[User](\n    retrieve_user_handler=retrieve_user_handler,\n    token_secret=environ.get(\"JWT_SECRET\", \"abcd123\"),\n    # we are specifying which endpoints should be excluded from authentication. In this case the login endpoint\n    # and our openAPI docs.\n    exclude=[\"/login\", \"/schema\"],\n)\n\n\n# Given an instance of 'JWTAuth' we can create a login handler function:\n@post(\"/login\")\nasync def login_handler(request: \"Request[Any, Any]\", data: User) -&gt; Response[User]:\n    await request.cache.set(str(data.id), data.dict())\n    response = jwt_auth.login(identifier=str(data.id), response_body=data)\n\n    # you can do whatever you want to update the response instance here\n    # e.g. response.set_cookie(...)\n\n    return response\n\n\n# We also have some other routes, for example:\n@get(\"/some-path\")\ndef some_route_handler(request: Request[User, Token]) -&gt; Any:\n    # request.user is set to the instance of user returned by the middleware\n    assert isinstance(request.user, User)\n    # request.auth is the instance of 'starlite_jwt.Token' created from the data encoded in the auth header\n    assert isinstance(request.auth, Token)\n    # do stuff ...\n\n\n# We create our OpenAPIConfig as usual - the JWT security scheme will be injected into it.\nopenapi_config = OpenAPIConfig(\n    title=\"My API\",\n    version=\"1.0.0\",\n)\n\n# We initialize the app instance and pass the jwt_auth 'on_app_init' handler to the constructor.\n# The hook handler will inject the JWT middleware and openapi configuration into the app.\napp = Starlite(\n    route_handlers=[login_handler, some_route_handler],\n    on_app_init=[jwt_auth.on_app_init],\n    openapi_config=openapi_config,\n)\n</code></pre>   Using JWT Auth<pre><code>from os import environ\nfrom typing import Any\nfrom uuid import UUID\n\nfrom pydantic import BaseModel, EmailStr\n\nfrom starlite import (\n    ASGIConnection,\n    OpenAPIConfig,\n    Request,\n    Response,\n    Starlite,\n    get,\n    post,\n)\nfrom starlite.contrib.jwt import JWTAuth, Token\n\n\n# Let's assume we have a User model that is a pydantic model.\n# This though is not required - we need some sort of user class -\n# but it can be any arbitrary value, e.g. an SQLAlchemy model, a representation of a MongoDB  etc.\nclass User(BaseModel):\n    id: UUID\n    name: str\n    email: EmailStr\n\n\n# JWTAuth requires a retrieve handler callable that receives the JWT token model and the ASGI connection\n# and returns the 'User' instance correlating to it.\n#\n# Notes:\n# - 'User' can be any arbitrary value you decide upon.\n# - The callable can be either sync or async - both will work.\nasync def retrieve_user_handler(token: Token, connection: ASGIConnection[Any, Any, Any]) -&gt; User | None:\n    # logic here to retrieve the user instance\n    cached_value = await connection.cache.get(token.sub)\n    if cached_value:\n        return User(**cached_value)\n    return None\n\n\njwt_auth = JWTAuth[User](\n    retrieve_user_handler=retrieve_user_handler,\n    token_secret=environ.get(\"JWT_SECRET\", \"abcd123\"),\n    # we are specifying which endpoints should be excluded from authentication. In this case the login endpoint\n    # and our openAPI docs.\n    exclude=[\"/login\", \"/schema\"],\n)\n\n\n# Given an instance of 'JWTAuth' we can create a login handler function:\n@post(\"/login\")\nasync def login_handler(request: \"Request[Any, Any]\", data: User) -&gt; Response[User]:\n    await request.cache.set(str(data.id), data.dict())\n    response = jwt_auth.login(identifier=str(data.id), response_body=data)\n\n    # you can do whatever you want to update the response instance here\n    # e.g. response.set_cookie(...)\n\n    return response\n\n\n# We also have some other routes, for example:\n@get(\"/some-path\")\ndef some_route_handler(request: Request[User, Token]) -&gt; Any:\n    # request.user is set to the instance of user returned by the middleware\n    assert isinstance(request.user, User)\n    # request.auth is the instance of 'starlite_jwt.Token' created from the data encoded in the auth header\n    assert isinstance(request.auth, Token)\n    # do stuff ...\n\n\n# We create our OpenAPIConfig as usual - the JWT security scheme will be injected into it.\nopenapi_config = OpenAPIConfig(\n    title=\"My API\",\n    version=\"1.0.0\",\n)\n\n# We initialize the app instance and pass the jwt_auth 'on_app_init' handler to the constructor.\n# The hook handler will inject the JWT middleware and openapi configuration into the app.\napp = Starlite(\n    route_handlers=[login_handler, some_route_handler],\n    on_app_init=[jwt_auth.on_app_init],\n    openapi_config=openapi_config,\n)\n</code></pre>"},{"location":"usage/18-contrib/1-jwt/#jwt-cookie-auth-backend","title":"JWT Cookie Auth Backend","text":"<p>This backend inherits from the <code>JWTAuth</code> backend, with the difference being that instead of using a header for the JWT Token, it uses a cookie. You can read more about this backend in the API Reference.</p> Python 3.8+Python 3.10+   Using JWT Cookie Auth<pre><code>from os import environ\nfrom typing import Any, Optional\nfrom uuid import UUID\n\nfrom pydantic import BaseModel, EmailStr\n\nfrom starlite import (\n    ASGIConnection,\n    OpenAPIConfig,\n    Request,\n    Response,\n    Starlite,\n    get,\n    post,\n)\nfrom starlite.contrib.jwt import JWTCookieAuth, Token\n\n\n# Let's assume we have a User model that is a pydantic model.\n# This though is not required - we need some sort of user class -\n# but it can be any arbitrary value, e.g. an SQLAlchemy model, a representation of a MongoDB  etc.\nclass User(BaseModel):\n    id: UUID\n    name: str\n    email: EmailStr\n\n\n# JWTCookieAuth requires a retrieve handler callable that receives the JWT token model and the ASGI connection\n# and returns the 'User' instance correlating to it.\n#\n# Notes:\n# - 'User' can be any arbitrary value you decide upon.\n# - The callable can be either sync or async - both will work.\nasync def retrieve_user_handler(token: Token, connection: ASGIConnection[Any, Any, Any]) -&gt; Optional[User]:\n    # logic here to retrieve the user instance\n    cached_value = await connection.cache.get(token.sub)\n    if cached_value:\n        return User(**cached_value)\n    return None\n\n\njwt_cookie_auth = JWTCookieAuth[User](\n    retrieve_user_handler=retrieve_user_handler,\n    token_secret=environ.get(\"JWT_SECRET\", \"abcd123\"),\n    # we are specifying which endpoints should be excluded from authentication. In this case the login endpoint\n    # and our openAPI docs.\n    exclude=[\"/login\", \"/schema\"],\n    # Tip: We can optionally supply cookie options to the configuration.  Here is an example of enabling the secure cookie option\n    # auth_cookie_options=CookieOptions(secure=True),\n)\n\n\n# Given an instance of 'JWTCookieAuth' we can create a login handler function:\n@post(\"/login\")\nasync def login_handler(request: \"Request[Any, Any]\", data: User) -&gt; Response[User]:\n    await request.cache.set(str(data.id), data.dict())\n    response = jwt_cookie_auth.login(identifier=str(data.id), response_body=data)\n\n    # you can do whatever you want to update the response instance here\n    # e.g. response.set_cookie(...)\n\n    return response\n\n\n# We also have some other routes, for example:\n@get(\"/some-path\")\ndef some_route_handler(request: Request[User, Token]) -&gt; Any:\n    # request.user is set to the instance of user returned by the middleware\n    assert isinstance(request.user, User)\n    # request.auth is the instance of 'starlite_jwt.Token' created from the data encoded in the auth header\n    assert isinstance(request.auth, Token)\n    # do stuff ...\n\n\n# We create our OpenAPIConfig as usual - the JWT security scheme will be injected into it.\nopenapi_config = OpenAPIConfig(\n    title=\"My API\",\n    version=\"1.0.0\",\n)\n\n# We initialize the app instance and pass the jwt_cookie_auth 'on_app_init' handler to the constructor.\n# The hook handler will inject the JWT middleware and openapi configuration into the app.\napp = Starlite(\n    route_handlers=[login_handler, some_route_handler],\n    on_app_init=[jwt_cookie_auth.on_app_init],\n    openapi_config=openapi_config,\n)\n</code></pre>   Using JWT Cookie Auth<pre><code>from os import environ\nfrom typing import Any\nfrom uuid import UUID\n\nfrom pydantic import BaseModel, EmailStr\n\nfrom starlite import (\n    ASGIConnection,\n    OpenAPIConfig,\n    Request,\n    Response,\n    Starlite,\n    get,\n    post,\n)\nfrom starlite.contrib.jwt import JWTCookieAuth, Token\n\n\n# Let's assume we have a User model that is a pydantic model.\n# This though is not required - we need some sort of user class -\n# but it can be any arbitrary value, e.g. an SQLAlchemy model, a representation of a MongoDB  etc.\nclass User(BaseModel):\n    id: UUID\n    name: str\n    email: EmailStr\n\n\n# JWTCookieAuth requires a retrieve handler callable that receives the JWT token model and the ASGI connection\n# and returns the 'User' instance correlating to it.\n#\n# Notes:\n# - 'User' can be any arbitrary value you decide upon.\n# - The callable can be either sync or async - both will work.\nasync def retrieve_user_handler(token: Token, connection: ASGIConnection[Any, Any, Any]) -&gt; User | None:\n    # logic here to retrieve the user instance\n    cached_value = await connection.cache.get(token.sub)\n    if cached_value:\n        return User(**cached_value)\n    return None\n\n\njwt_cookie_auth = JWTCookieAuth[User](\n    retrieve_user_handler=retrieve_user_handler,\n    token_secret=environ.get(\"JWT_SECRET\", \"abcd123\"),\n    # we are specifying which endpoints should be excluded from authentication. In this case the login endpoint\n    # and our openAPI docs.\n    exclude=[\"/login\", \"/schema\"],\n    # Tip: We can optionally supply cookie options to the configuration.  Here is an example of enabling the secure cookie option\n    # auth_cookie_options=CookieOptions(secure=True),\n)\n\n\n# Given an instance of 'JWTCookieAuth' we can create a login handler function:\n@post(\"/login\")\nasync def login_handler(request: \"Request[Any, Any]\", data: User) -&gt; Response[User]:\n    await request.cache.set(str(data.id), data.dict())\n    response = jwt_cookie_auth.login(identifier=str(data.id), response_body=data)\n\n    # you can do whatever you want to update the response instance here\n    # e.g. response.set_cookie(...)\n\n    return response\n\n\n# We also have some other routes, for example:\n@get(\"/some-path\")\ndef some_route_handler(request: Request[User, Token]) -&gt; Any:\n    # request.user is set to the instance of user returned by the middleware\n    assert isinstance(request.user, User)\n    # request.auth is the instance of 'starlite_jwt.Token' created from the data encoded in the auth header\n    assert isinstance(request.auth, Token)\n    # do stuff ...\n\n\n# We create our OpenAPIConfig as usual - the JWT security scheme will be injected into it.\nopenapi_config = OpenAPIConfig(\n    title=\"My API\",\n    version=\"1.0.0\",\n)\n\n# We initialize the app instance and pass the jwt_cookie_auth 'on_app_init' handler to the constructor.\n# The hook handler will inject the JWT middleware and openapi configuration into the app.\napp = Starlite(\n    route_handlers=[login_handler, some_route_handler],\n    on_app_init=[jwt_cookie_auth.on_app_init],\n    openapi_config=openapi_config,\n)\n</code></pre>"},{"location":"usage/18-contrib/1-jwt/#oauth2-bearer-password-flow","title":"OAuth2 Bearer Password Flow","text":"<p>This backend inherits from the <code>JWTCookieAuth</code> backend. It works similarly to the <code>JWTCookieAuth</code> backend, but is meant to be used for OAUTH2 Bearer password flows.</p> Python 3.8+Python 3.10+   Using OAUTH2 Bearer Password<pre><code>from os import environ\nfrom typing import Any, Optional\nfrom uuid import UUID\n\nfrom pydantic import BaseModel, EmailStr\n\nfrom starlite import (\n    ASGIConnection,\n    OpenAPIConfig,\n    Request,\n    Response,\n    Starlite,\n    get,\n    post,\n)\nfrom starlite.contrib.jwt import OAuth2PasswordBearerAuth, Token\n\n\n# Let's assume we have a User model that is a pydantic model.\n# This though is not required - we need some sort of user class -\n# but it can be any arbitrary value, e.g. an SQLAlchemy model, a representation of a MongoDB  etc.\nclass User(BaseModel):\n    id: UUID\n    name: str\n    email: EmailStr\n\n\n# OAuth2PasswordBearerAuth requires a retrieve handler callable that receives the JWT token model and the ASGI connection\n# and returns the 'User' instance correlating to it.\n#\n# Notes:\n# - 'User' can be any arbitrary value you decide upon.\n# - The callable can be either sync or async - both will work.\nasync def retrieve_user_handler(token: Token, connection: ASGIConnection[Any, Any, Any]) -&gt; Optional[User]:\n    # logic here to retrieve the user instance\n    cached_value = await connection.cache.get(token.sub)\n    if cached_value:\n        return User(**cached_value)\n    return None\n\n\noauth2_auth = OAuth2PasswordBearerAuth[User](\n    retrieve_user_handler=retrieve_user_handler,\n    token_secret=environ.get(\"JWT_SECRET\", \"abcd123\"),\n    # we are specifying the URL for retrieving a JWT access token\n    token_url=\"/login\",\n    # we are specifying which endpoints should be excluded from authentication. In this case the login endpoint\n    # and our openAPI docs.\n    exclude=[\"/login\", \"/schema\"],\n)\n\n\n# Given an instance of 'OAuth2PasswordBearerAuth' we can create a login handler function:\n@post(\"/login\")\nasync def login_handler(request: \"Request[Any, Any]\", data: User) -&gt; Response[User]:\n    await request.cache.set(str(data.id), data.dict())\n    response = oauth2_auth.login(identifier=str(data.id), response_body=data)\n\n    # you can do whatever you want to update the response instance here\n    # e.g. response.set_cookie(...)\n\n    return response\n\n\n# We also have some other routes, for example:\n@get(\"/some-path\")\ndef some_route_handler(request: Request[User, Token]) -&gt; Any:\n    # request.user is set to the instance of user returned by the middleware\n    assert isinstance(request.user, User)\n    # request.auth is the instance of 'starlite_jwt.Token' created from the data encoded in the auth header\n    assert isinstance(request.auth, Token)\n    # do stuff ...\n\n\n# We create our OpenAPIConfig as usual - the JWT security scheme will be injected into it.\nopenapi_config = OpenAPIConfig(\n    title=\"My API\",\n    version=\"1.0.0\",\n)\n\n# We initialize the app instance and pass the oauth2_auth 'on_app_init' handler to the constructor.\n# The hook handler will inject the JWT middleware and openapi configuration into the app.\napp = Starlite(\n    route_handlers=[login_handler, some_route_handler],\n    on_app_init=[oauth2_auth.on_app_init],\n    openapi_config=openapi_config,\n)\n</code></pre>   Using OAUTH2 Bearer Password<pre><code>from os import environ\nfrom typing import Any\nfrom uuid import UUID\n\nfrom pydantic import BaseModel, EmailStr\n\nfrom starlite import (\n    ASGIConnection,\n    OpenAPIConfig,\n    Request,\n    Response,\n    Starlite,\n    get,\n    post,\n)\nfrom starlite.contrib.jwt import OAuth2PasswordBearerAuth, Token\n\n\n# Let's assume we have a User model that is a pydantic model.\n# This though is not required - we need some sort of user class -\n# but it can be any arbitrary value, e.g. an SQLAlchemy model, a representation of a MongoDB  etc.\nclass User(BaseModel):\n    id: UUID\n    name: str\n    email: EmailStr\n\n\n# OAuth2PasswordBearerAuth requires a retrieve handler callable that receives the JWT token model and the ASGI connection\n# and returns the 'User' instance correlating to it.\n#\n# Notes:\n# - 'User' can be any arbitrary value you decide upon.\n# - The callable can be either sync or async - both will work.\nasync def retrieve_user_handler(token: Token, connection: ASGIConnection[Any, Any, Any]) -&gt; User | None:\n    # logic here to retrieve the user instance\n    cached_value = await connection.cache.get(token.sub)\n    if cached_value:\n        return User(**cached_value)\n    return None\n\n\noauth2_auth = OAuth2PasswordBearerAuth[User](\n    retrieve_user_handler=retrieve_user_handler,\n    token_secret=environ.get(\"JWT_SECRET\", \"abcd123\"),\n    # we are specifying the URL for retrieving a JWT access token\n    token_url=\"/login\",\n    # we are specifying which endpoints should be excluded from authentication. In this case the login endpoint\n    # and our openAPI docs.\n    exclude=[\"/login\", \"/schema\"],\n)\n\n\n# Given an instance of 'OAuth2PasswordBearerAuth' we can create a login handler function:\n@post(\"/login\")\nasync def login_handler(request: \"Request[Any, Any]\", data: User) -&gt; Response[User]:\n    await request.cache.set(str(data.id), data.dict())\n    response = oauth2_auth.login(identifier=str(data.id), response_body=data)\n\n    # you can do whatever you want to update the response instance here\n    # e.g. response.set_cookie(...)\n\n    return response\n\n\n# We also have some other routes, for example:\n@get(\"/some-path\")\ndef some_route_handler(request: Request[User, Token]) -&gt; Any:\n    # request.user is set to the instance of user returned by the middleware\n    assert isinstance(request.user, User)\n    # request.auth is the instance of 'starlite_jwt.Token' created from the data encoded in the auth header\n    assert isinstance(request.auth, Token)\n    # do stuff ...\n\n\n# We create our OpenAPIConfig as usual - the JWT security scheme will be injected into it.\nopenapi_config = OpenAPIConfig(\n    title=\"My API\",\n    version=\"1.0.0\",\n)\n\n# We initialize the app instance and pass the oauth2_auth 'on_app_init' handler to the constructor.\n# The hook handler will inject the JWT middleware and openapi configuration into the app.\napp = Starlite(\n    route_handlers=[login_handler, some_route_handler],\n    on_app_init=[oauth2_auth.on_app_init],\n    openapi_config=openapi_config,\n)\n</code></pre>"},{"location":"usage/2-route-handlers/0-route-handlers-concept/","title":"Route Handlers","text":"<p>Route handlers are the core of Starlite. They are constructed by decorating a function or class method with one of the handler decorators exported from Starlite.</p> <p>For example:</p> <pre><code>from starlite import MediaType, get\n\n\n@get(\"/\", media_type=MediaType.TEXT)\ndef greet() -&gt; str:\n    return \"hello world\"\n</code></pre> <p>In the above example, the decorator includes all the information required to define the endpoint operation for the combination of the path <code>\"/\"</code> and the http verb <code>GET</code>. In this case it will be a http response with a \"Content-Type\" header of <code>text/plain</code>.</p> <p>What the decorator does, is wrap the function or method within a class instance that inherits from <code>BaseRouteHandler</code>. These classes are optimized descriptor classes that record all the data necessary for the given function or method - this includes a modelling of the function signature, which allows for injection of kwargs and dependencies, as well as data pertinent to OpenAPI spec generation.</p>"},{"location":"usage/2-route-handlers/0-route-handlers-concept/#declaring-paths","title":"Declaring Path(s)","text":"<p>All route handler decorator accept an optional path argument. This argument can be declared as a kwarg using the <code>path</code> key word:</p> <pre><code>from starlite import get\n\n\n@get(path=\"/some-path\")\ndef my_route_handler() -&gt; None:\n    ...\n</code></pre> <p>It can also be passed as an argument without the key-word:</p> <pre><code>from starlite import get\n\n\n@get(\"/some-path\")\ndef my_route_handler() -&gt; None:\n    ...\n</code></pre> <p>And the value for this argument can be either a string path, as in the above examples, or a list of string paths:</p> <pre><code>from starlite import get\n\n\n@get([\"/some-path\", \"/some-other-path\"])\ndef my_route_handler() -&gt; None:\n    ...\n</code></pre> <p>This is particularly useful when you want to have optional path parameters:</p> <pre><code>from starlite import get\n\n\n@get(\n    [\"/some-path\", \"/some-path/{some_id:int}\"],\n)\ndef my_route_handler(some_id: int = 1) -&gt; None:\n    ...\n</code></pre>"},{"location":"usage/2-route-handlers/0-route-handlers-concept/#handler-function-kwargs","title":"Handler Function Kwargs","text":"<p>Route handler functions or methods access various data by declaring these as annotated function kwargs. The annotated kwargs are inspected by Starlite and then injected into the request handler.</p> <p>The following sources can be accessed using annotated function kwargs:</p> <ol> <li>path, query, header and cookie parameters</li> <li>request data</li> <li>dependencies</li> </ol> <p>Additionally, you can specify the following special kwargs, what's called \"reserved keywords\" internally:</p> <ul> <li><code>cookies</code>: injects the request <code>cookies</code> as a parsed dictionary.</li> <li><code>headers</code>: injects the request <code>headers</code> as an instance of <code>Headers</code>,   which is a case-insensitive mapping.</li> <li><code>query</code>: injects the request <code>query_params</code> as a parsed dictionary.</li> <li><code>request</code>: injects the <code>Request</code> instance. Available only for http route handlers</li> <li><code>scope</code>: injects the ASGI scope dictionary.</li> <li><code>socket</code>: injects the <code>WebSocket</code> instance. Available only for websocket handlers</li> <li><code>state</code>: injects a copy of the application <code>state</code>.</li> </ul> <p>For example:</p> Python 3.8+Python 3.9+   <pre><code>from typing import Any, Dict\nfrom starlite import State, Request, get\nfrom starlite.datastructures import Headers\n\n\n@get(path=\"/\")\ndef my_request_handler(\n    state: State,\n    request: Request,\n    headers: Headers,\n    query: Dict[str, Any],\n    cookies: Dict[str, Any],\n) -&gt; None:\n    ...\n</code></pre>   <pre><code>from typing import Any\nfrom starlite import State, Request, get\nfrom starlite.datastructures import Headers\n\n\n@get(path=\"/\")\ndef my_request_handler(\n    state: State,\n    request: Request,\n    headers: Headers,\n    query: dict[str, Any],\n    cookies: dict[str, Any],\n) -&gt; None:\n    ...\n</code></pre>     <p>Tip</p> <p>You can define a custom typing for your application state and then use it as a type instead of just using the State class from Starlite</p>"},{"location":"usage/2-route-handlers/0-route-handlers-concept/#handler-function-type-annotations","title":"Handler Function Type Annotations","text":"<p>Starlite enforces strict type annotations. Functions decorated by a route handler must have all their kwargs and return value type annotated. If a type annotation is missing, an <code>ImproperlyConfiguredException</code> will be raised during the application boot-up process.</p> <p>There are several reasons for why this limitation is enforced:</p> <ol> <li>to ensure best practices</li> <li>to ensure consistent OpenAPI schema generation</li> <li>to allow Starlite to compute during the application bootstrap all the kwargs required by a function</li> </ol>"},{"location":"usage/2-route-handlers/1-http-route-handlers/","title":"HTTP Route Handlers","text":"<p>The most commonly used route handlers are those that handle http requests and responses. These route handlers all inherit from the class <code>starlite.handlers.http.HTTPRouteHandler</code>, which is aliased as the decorator called <code>route</code>:</p> <pre><code>from starlite import HttpMethod, route\n\n\n@route(path=\"/some-path\", http_method=[HttpMethod.GET, HttpMethod.POST])\ndef my_endpoint() -&gt; None:\n    ...\n</code></pre> <p>As mentioned above, <code>route</code> does is merely an alias for <code>HTTPRouteHandler</code>, thus the below code is equivalent to the one above:</p> <pre><code>from starlite import HttpMethod, HTTPRouteHandler\n\n\n@HTTPRouteHandler(path=\"/some-path\", http_method=[HttpMethod.GET, HttpMethod.POST])\ndef my_endpoint() -&gt; None:\n    ...\n</code></pre>"},{"location":"usage/2-route-handlers/1-http-route-handlers/#http-route-handlers-kwargs","title":"HTTP Route Handlers Kwargs","text":"<p>The <code>route</code> decorator requires an <code>http_method</code> kwarg, which is a member of the <code>HttpMethod</code> enum or a list of members, e.g. <code>HttpMethod.GET</code> or <code>[HttpMethod.PATCH, HttpMethod.PUT]</code>.</p> <p>See the API Reference for full details on the <code>route</code> decorator and the kwargs it accepts.</p>"},{"location":"usage/2-route-handlers/1-http-route-handlers/#semantic-handler-decorators","title":"Semantic Handler Decorators","text":"<p>Starlite also includes \"semantic\" decorators, that is, decorators the pre-set the <code>http_method</code> kwarg to a specific HTTP verb, which correlates with their name:</p> <ul> <li><code>delete</code></li> <li><code>get</code></li> <li><code>head</code></li> <li><code>patch</code></li> <li><code>post</code></li> <li><code>put</code></li> </ul> <p>These are used exactly like <code>route</code> with the sole exception that you cannot configure the <code>http_method</code> kwarg:</p> <pre><code>from starlite import Partial, delete, get, patch, post, put, head\nfrom pydantic import BaseModel\n\n\nclass Resource(BaseModel):\n    ...\n\n\n@get(path=\"/resources\")\ndef list_resources() -&gt; list[Resource]:\n    ...\n\n\n@post(path=\"/resources\")\ndef create_resource(data: Resource) -&gt; Resource:\n    ...\n\n\n@get(path=\"/resources/{pk:int}\")\ndef retrieve_resource(pk: int) -&gt; Resource:\n    ...\n\n\n@head(path=\"/resources/{pk:int}\")\ndef retrieve_resource_head(pk: int) -&gt; None:\n    ...\n\n\n@put(path=\"/resources/{pk:int}\")\ndef update_resource(data: Resource, pk: int) -&gt; Resource:\n    ...\n\n\n@patch(path=\"/resources/{pk:int}\")\ndef partially_update_resource(data: Partial[Resource], pk: int) -&gt; Resource:\n    ...\n\n\n@delete(path=\"/resources/{pk:int}\")\ndef delete_resource(pk: int) -&gt; None:\n    ...\n</code></pre> <p>Although these decorators are merely subclasses of <code>starlite.handlers.http.HTTPRouteHandler</code> that pre-set the <code>http_method</code>, using get, patch, put, delete or post instead of route makes the code clearer and simpler.</p> <p>Furthermore, in the OpenAPI specification each unique combination of http verb (e.g. \"GET\", \"POST\" etc.) and path is regarded as a distinct operation, and each operation should be distinguished by a unique <code>operationId</code> and optimally also have a <code>summary</code> and <code>description</code> sections.</p> <p>As such, using the <code>route</code> decorator is discouraged. Instead, the preferred pattern is to share code using secondary class methods or by abstracting code to reusable functions.</p>"},{"location":"usage/2-route-handlers/1-http-route-handlers/#using-sync-handler-functions","title":"Using Sync Handler Functions","text":"<p>You can use both sync and async functions as the base for route handler functions, but which should you use? and when?</p> <p>If your route handler needs to perform an I/O operation (read or write data from or to a service / db etc.), the most performant solution within the scope of an ASGI application, including Starlite, is going to be by using an async solution for this purpose.</p> <p>The reason for this is that async code, if written correctly, is non-blocking. That is, async code can be paused and resumed, and it therefore does not interrupt the main event loop from executing (if written correctly). On the other hand, sync I/O handling is often blocking, and if you use such code in your function it can create performance issues.</p> <p>In this case you should use the <code>sync_to_thread</code> option. What this does, is tell Starlite to run the sync function in a separate async thread, where it can block but will not interrupt the main event loop's execution.</p> <p>The problem with this though is that this will slow down the execution of your sync code quite dramatically - by between %40-60%. So this is really quite far from performant. Thus, you should use this option only when your sync code performs blocking I/O operations. If your sync code simply performs simple tasks, non-expensive calculations, etc. you should not use the <code>sync_to_thread</code> option.</p>"},{"location":"usage/2-route-handlers/2-websocket-route-handlers/","title":"Websocket Route Handlers","text":"<p>Starlite supports Websockets via the <code>websocket</code> decorator:</p> <pre><code>from starlite import WebSocket, websocket\n\n\n@websocket(path=\"/socket\")\nasync def my_websocket_handler(socket: WebSocket) -&gt; None:\n    await socket.accept()\n    await socket.send_json({...})\n    await socket.close()\n</code></pre> <p>The<code>websocket</code> decorator is an alias of the class <code>WebsocketRouteHandler</code>. Thus, the below code is equivalent to the one above:</p> <pre><code>from starlite import WebSocket, WebsocketRouteHandler\n\n\n@WebsocketRouteHandler(path=\"/socket\")\nasync def my_websocket_handler(socket: WebSocket) -&gt; None:\n    await socket.accept()\n    await socket.send_json({...})\n    await socket.close()\n</code></pre> <p>In difference to HTTP routes handlers, websocket handlers have the following requirements:</p> <ol> <li>they must declare a <code>socket</code> kwarg.</li> <li>they must have a return annotation of <code>None</code>.</li> <li>they must be async functions.</li> </ol> <p>These requirements are enforced using inspection, and if any of them is unfulfilled an informative exception will be raised.</p>  <p>Note</p> <p>OpenAPI currently does not support websockets. As such no schema will be generated for these route handlers.</p>  <p>See the API Reference for full details on the <code>websocket</code> decorator and the kwargs it accepts.</p>"},{"location":"usage/2-route-handlers/3-asgi-route-handlers/","title":"ASGI Route Handlers","text":"<p>If you need to write your own ASGI application, you can do so using the <code>asgi</code> decorator:</p> <pre><code>from starlite.types import Scope, Receive, Send\nfrom starlite.status_codes import HTTP_400_BAD_REQUEST\nfrom starlite import Response, asgi\n\n\n@asgi(path=\"/my-asgi-app\")\nasync def my_asgi_app(scope: Scope, receive: Receive, send: Send) -&gt; None:\n    if scope[\"type\"] == \"http\":\n        if scope[\"method\"] == \"GET\":\n            response = Response({\"hello\": \"world\"})\n            await response(scope=scope, receive=receive, send=send)\n        return\n    response = Response(\n        {\"detail\": \"unsupported request\"}, status_code=HTTP_400_BAD_REQUEST\n    )\n    await response(scope=scope, receive=receive, send=send)\n</code></pre> <p>Like other route handlers, the <code>asgi</code> decorator is an alias of the class <code>ASGIRouteHandler</code>. Thus, the code below is equivalent to the one above:</p> <pre><code>from starlite.types import Scope, Receive, Send\nfrom starlite.status_codes import HTTP_400_BAD_REQUEST\nfrom starlite import ASGIRouteHandler, Response\n\n\n@ASGIRouteHandler(path=\"/my-asgi-app\")\nasync def my_asgi_app(scope: Scope, receive: Receive, send: Send) -&gt; None:\n    if scope[\"type\"] == \"http\":\n        if scope[\"method\"] == \"GET\":\n            response = Response({\"hello\": \"world\"})\n            await response(scope=scope, receive=receive, send=send)\n        return\n    response = Response(\n        {\"detail\": \"unsupported request\"}, status_code=HTTP_400_BAD_REQUEST\n    )\n    await response(scope=scope, receive=receive, send=send)\n</code></pre>"},{"location":"usage/2-route-handlers/3-asgi-route-handlers/#limitations-of-asgi-route-handlers","title":"Limitations of ASGI route handlers","text":"<p>In difference to the other route handlers, the <code>asgi</code> route handler accepts only 3 kwargs that must be defined:</p> <ul> <li><code>scope</code>, a mapping of values describing the ASGI connection. It always includes a <code>type</code> key, with the values being   either <code>http</code> or <code>websocket</code>, and a <code>path</code> key. If the type is <code>http</code>, the scope dictionary will also include   a <code>method</code> key with the value being one of <code>DELETE, GET, POST, PATCH, PUT, HEAD</code>.</li> <li><code>receive</code>, an injected function by which the ASGI application receives messages.</li> <li><code>send</code>, an injected function by which the ASGI application sends messages.</li> </ul> <p>You can read more about these in the ASGI specification.</p> <p>Additionally, ASGI route handler functions must be async functions. This is enforced using inspection, and if the function is not an async function, an informative exception will be raised.</p> <p>See the API Reference for full details on the <code>asgi</code> decorator and the kwargs it accepts.</p>"},{"location":"usage/2-route-handlers/4-route-handler-indexing/","title":"Route Handler Indexing","text":"<p>You can provide in all route handler decorators a <code>name</code> kwarg. The value for this kwarg must be unique, otherwise <code>ImproperlyConfiguredException</code> exception will be raised. Default value for <code>name</code> is value returned by <code>handler.__str__</code> which should be the full dotted path to the handler (e.g. <code>app.controllers.projects.list</code> for <code>list</code> function residing in <code>app/controllers/projects.py</code> file). <code>name</code> can be used to dynamically retrieve (i.e. during runtime) a mapping containing the route handler instance and paths, also it can be used to build a URL path for that handler:</p> <pre><code>from starlite import Starlite, Request, Redirect, NotFoundException, get\n\n\n@get(\"/abc\", name=\"one\")\ndef handler_one() -&gt; None:\n    pass\n\n\n@get(\"/xyz\", name=\"two\")\ndef handler_two() -&gt; None:\n    pass\n\n\n@get(\"/def/{param:int}\", name=\"three\")\ndef handler_three(param: int) -&gt; None:\n    pass\n\n\n@get(\"/{handler_name:str}\", name=\"four\")\ndef handler_four(request: Request, name: str) -&gt; Redirect:\n    handler_index = request.app.get_handler_index_by_name(name)\n    if not handler_index:\n        raise NotFoundException(f\"no handler matching the name {name} was found\")\n\n    # handler_index == { \"paths\": [\"/\"], \"handler\": ..., \"qualname\": ... }\n    # do something with the handler index below, e.g. send a redirect response to the handler, or access\n    # handler.opt and some values stored there etc.\n\n    return Redirect(path=handler_index[\"paths\"][0])\n\n\n@get(\"/redirect/{param_value:int}\", name=\"five\")\ndef handler_five(request: Request, param_value: int) -&gt; Redirect:\n    path = request.app.route_reverse(\"three\", param=param_value)\n    return Redirect(path=path)\n\n\napp = Starlite(route_handlers=[handler_one, handler_two, handler_three])\n</code></pre> <p><code>route_reverse</code> will raise <code>NoMatchRouteFoundException</code> if route with given name was not found or if any of path parameters is missing or if any of passed path parameters types do not match types in the respective route declaration. However, <code>str</code> is accepted in place of <code>datetime</code>, <code>date</code>, <code>time</code>, <code>timedelta</code>, <code>float</code>, and <code>Path</code> parameters, so you can apply custom formatting and pass the result to <code>route_reverse</code>.</p> <p>If handler has multiple paths attached to it <code>route_reverse</code> will return the path that consumes the most number of keywords arguments passed to the function.</p> <pre><code>from starlite import get, Request\n\n\n@get(\n    [\"/some-path\", \"/some-path/{id:int}\", \"/some-path/{id:int}/{val:str}\"],\n    name=\"handler_name\",\n)\ndef handler(id: int = 1, val: str = \"default\") -&gt; None:\n    ...\n\n\n@get(\"/path-info\")\ndef path_info(request: Request) -&gt; str:\n    path_optional = request.app.route_reverse(\"handler_name\")\n    # /some-path`\n\n    path_partial = request.app.route_reverse(\"handler_name\", id=100)\n    # /some-path/100\n\n    path_full = request.app.route_reverse(\"handler_name\", id=100, val=\"value\")\n    # /some-path/100/value`\n\n    return f\"{path_optional} {path_partial} {path_full}\"\n</code></pre> <p>If there are multiple paths attached to a handler that have the same path parameters (for example indexed handler has been registered on multiple routers) the result of <code>route_reverse</code> is not defined. The function will return a formatted path, but it might be picked randomly so reversing urls in such cases is highly discouraged.</p> <p>If you have access to <code>request</code> instance you can make reverse lookups using <code>url_for</code> function which is similar to <code>route_reverse</code> but returns absolute URL.</p>"},{"location":"usage/2-route-handlers/5-handler-opts/","title":"Handler 'opts'","text":"<p>All route handler decorators accept a key called <code>opt</code> which accepts a dictionary of arbitrary values, e.g.</p> <pre><code>from starlite import get\n\n\n@get(\"/\", opt={\"my_key\": \"some-value\"})\ndef handler() -&gt; None:\n    ...\n</code></pre> <p>This dictionary can be accessed by route guard, or by accessing the <code>route_handler</code> property on a request (<code>request.route_handler.opt</code>), or using the ASGI scope object directly (<code>scope[\"route_handler\"].opt</code>).</p>"},{"location":"usage/2-route-handlers/5-handler-opts/#passing-kwargs-to-handlers","title":"Passing **kwargs to handlers","text":"<p>Building on <code>opts</code>, you can pass any arbitrary kwarg to the route handler decorator, and it will be automatically set as a key in the opt dictionary:</p> <pre><code>from starlite import get\n\n\n@get(\"/\", my_key=\"some-value\")\ndef handler() -&gt; None:\n    ...\n\n\nassert handler.opt[\"my_key\"] == \"some-value\"\n</code></pre> <p>You can specify the <code>opt</code> dictionary at all levels of your application. On specific route handlers, on a controller, a router, and even on the app instance itself.</p> <p>The resulting dictionary is constructed by merging opt dictionaries of all levels. If multiple layers define the same key, the value from the closest layer to the response handler will take precedence</p>"},{"location":"usage/3-parameters/0-path-parameters/","title":"Path Parameters","text":"<p>Path parameters are parameters declared as part of the <code>path</code> component of the URL. They are declared using a simple syntax <code>{param_name:param_type}</code>:</p> <pre><code>from pydantic import BaseModel\n\nfrom starlite import Starlite, get\n\nUSER_DB = {1: {\"id\": 1, \"name\": \"John Doe\"}}\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n\n\n@get(\"/user/{user_id:int}\")\ndef get_user(user_id: int) -&gt; User:\n    return User.parse_obj(USER_DB[user_id])\n\n\napp = Starlite(route_handlers=[get_user])\n</code></pre> <p>In the above there are two components:</p> <ol> <li>The path parameter is defined in the <code>@get</code> decorator, which declares both the parameter's name (<code>user_id</code>) and type (<code>int</code>).</li> <li>The decorated function <code>get_user</code> defines a parameter with the same name as the parameter defined in the <code>path</code>    kwarg.</li> </ol> <p>The correlation of parameter name ensures that the value of the path parameter will be injected into the function when it's called.</p>"},{"location":"usage/3-parameters/0-path-parameters/#supported-path-parameter-types","title":"Supported Path Parameter Types","text":"<p>Currently, the following types are supported:</p> <ul> <li><code>date</code>: Accepts date strings and time stamps.</li> <li><code>datetime</code>: Accepts date-time strings and time stamps.</li> <li><code>decimal</code>: Accepts decimal values and floats.</li> <li><code>float</code>: Accepts ints and floats.</li> <li><code>int</code>: Accepts ints and floats.</li> <li><code>path</code>: Accepts valid POSIX paths.</li> <li><code>str</code>: Accepts all string values.</li> <li><code>time</code>: Accepts time strings with optional timezone compatible with pydantic formats.</li> <li><code>timedelta</code>: Accepts duration strings compatible with the pydantic formats.</li> <li><code>uuid</code>: Accepts all uuid values.</li> </ul> <p>The types declared in the path parameter and the function do not need to match 1:1 - as long as parameter inside the function declaration is typed with a \"higher\" type to which the lower type can be coerced, this is fine. For example, consider this:</p> Python 3.8+Python 3.9+   <pre><code>from datetime import datetime, timezone\nfrom typing import List\n\nfrom pydantic import BaseModel\n\nfrom starlite import Starlite, get\n\n\nclass Order(BaseModel):\n    id: int\n    customer_id: int\n\n\nORDERS_BY_DATETIME = {\n    datetime.fromtimestamp(1667924386, tz=timezone.utc): [\n        Order(id=1, customer_id=2),\n        Order(id=2, customer_id=2),\n    ]\n}\n\n\n@get(path=\"/orders/{from_date:int}\")\ndef get_orders(from_date: datetime) -&gt; List[Order]:\n    return ORDERS_BY_DATETIME[from_date]\n\n\napp = Starlite(route_handlers=[get_orders])\n</code></pre>   <pre><code>from datetime import datetime, timezone\n\nfrom pydantic import BaseModel\n\nfrom starlite import Starlite, get\n\n\nclass Order(BaseModel):\n    id: int\n    customer_id: int\n\n\nORDERS_BY_DATETIME = {\n    datetime.fromtimestamp(1667924386, tz=timezone.utc): [\n        Order(id=1, customer_id=2),\n        Order(id=2, customer_id=2),\n    ]\n}\n\n\n@get(path=\"/orders/{from_date:int}\")\ndef get_orders(from_date: datetime) -&gt; list[Order]:\n    return ORDERS_BY_DATETIME[from_date]\n\n\napp = Starlite(route_handlers=[get_orders])\n</code></pre>    <p>The parameter defined inside the <code>path</code> kwarg is typed as <code>int</code>, because the value passed as part of the request will be a timestamp in milliseconds without any decimals. The parameter in the function declaration though is typed as <code>datetime.datetime</code>. This works because the int value will be passed to a pydantic model representing the function signature, which will coerce the int into a datetime. Thus, when the function is called it will be called with a datetime typed parameter.</p>  <p>Note</p> <p>You only need to define the parameter in the function declaration if it's actually used inside the function. If the path parameter is part of the path, but the function doesn't use it, it's fine to omit it. It will still be validated and added to the openapi schema correctly.</p>"},{"location":"usage/3-parameters/0-path-parameters/#extra-validation-and-documentation-for-path-params","title":"Extra Validation and Documentation for Path Params","text":"<p>If you want to add validation or enhance the OpenAPI documentation generated for a given path parameter, you can do so using the Parameter function:</p> <pre><code>from pydantic import BaseModel, Json, conint\nfrom pydantic_openapi_schema.v3_1_0.example import Example\nfrom pydantic_openapi_schema.v3_1_0.external_documentation import ExternalDocumentation\n\nfrom starlite import Parameter, Starlite, get\n\n\nclass Version(BaseModel):\n    id: conint(ge=1, le=10)  # type: ignore[valid-type]\n    specs: Json\n\n\nVERSIONS = {1: Version(id=1, specs='{\"some\": \"value\"}')}\n\n\n@get(path=\"/versions/{version:int}\")\ndef get_product_version(\n    version: int = Parameter(\n        ge=1,\n        le=10,\n        title=\"Available Product Versions\",\n        description=\"Get a specific version spec from the available specs\",\n        examples=[Example(value=1)],\n        external_docs=ExternalDocumentation(\n            url=\"https://mywebsite.com/documentation/product#versions\",  # type: ignore[arg-type]\n        ),\n    )\n) -&gt; Version:\n    return VERSIONS[version]\n\n\napp = Starlite(route_handlers=[get_product_version])\n</code></pre> <p>In the above example, <code>Parameter</code> is used to restrict the value of <code>version</code> to a range between 1 and 10, and then set the <code>title</code>,<code>description</code>, <code>examples</code> and <code>externalDocs</code> sections of the OpenAPI schema.</p>"},{"location":"usage/3-parameters/1-query-parameters/","title":"Query Parameters","text":"<p>Query parameters are defined as keyword arguments to handler functions. Every keyword argument that is not otherwise specified (for example as a path parameter) will be interpreted as a query parameter.</p> Python 3.8+Python 3.9+   <pre><code>from typing import Dict\n\nfrom starlite import Starlite, get\n\n\n@get(\"/\")\ndef index(param: str) -&gt; Dict[str, str]:\n    return {\"param\": param}\n\n\napp = Starlite(route_handlers=[index])\n</code></pre>   <pre><code>from starlite import Starlite, get\n\n\n@get(\"/\")\ndef index(param: str) -&gt; dict[str, str]:\n    return {\"param\": param}\n\n\napp = Starlite(route_handlers=[index])\n</code></pre>     <p>Run it</p> <p><pre><code>&gt; curl http://127.0.0.1:8000/?param=foo\n{\"param\":\"foo\"}\n</code></pre> <pre><code>&gt; curl http://127.0.0.1:8000/?param=bar\n{\"param\":\"bar\"}\n</code></pre></p>   <p>Technical details</p> <p>These parameters will be parsed from the function signature and used to generate a pydantic model.   This model in turn will be used to validate the parameters and generate the OpenAPI schema.</p> <p>This means that you can also use any pydantic type in the signature, and it will   follow the same kind of validation and parsing as you would get from pydantic.</p>  <p>Query parameters come in three basic types:</p> <ol> <li>Required</li> <li>Required with a default value</li> <li>Optional with a default value</li> </ol> <p>Query parameters are required by default. If one such a parameter has no value, a <code>ValidationException</code> will be raised.</p>"},{"location":"usage/3-parameters/1-query-parameters/#settings-defaults","title":"Settings defaults","text":"<p>In this example, <code>param</code> will have the value <code>\"hello\"</code> if it's not specified in the request. If it's passed as a query parameter however, it will be overwritten:</p> Python 3.8+Python 3.9+   <pre><code>from typing import Dict\n\nfrom starlite import Starlite, get\n\n\n@get(\"/\")\ndef index(param: str = \"hello\") -&gt; Dict[str, str]:\n    return {\"param\": param}\n\n\napp = Starlite(route_handlers=[index])\n</code></pre>   <pre><code>from starlite import Starlite, get\n\n\n@get(\"/\")\ndef index(param: str = \"hello\") -&gt; dict[str, str]:\n    return {\"param\": param}\n\n\napp = Starlite(route_handlers=[index])\n</code></pre>     <p>Run it</p> <p><pre><code>&gt; curl http://127.0.0.1:8000/\n{\"param\":\"hello\"}\n</code></pre> <pre><code>&gt; curl http://127.0.0.1:8000/?param=john\n{\"param\":\"john\"}\n</code></pre></p>"},{"location":"usage/3-parameters/1-query-parameters/#optional-parameters","title":"Optional parameters","text":"<p>Instead of only setting a default value, it's also possible to make a query parameter entirely optional.</p> <p>Here, we give a default value of <code>None</code>, but still declare the type of the query parameter to be a string. This means that this parameter is not required. If it is given, it has to be a string. If it is not given, it will have a default value of <code>None</code></p> Python 3.8+Python 3.9+Python 3.10+   <pre><code>from typing import Dict, Optional\n\nfrom starlite import Starlite, get\n\n\n@get(\"/\")\ndef index(param: Optional[str] = None) -&gt; Dict[str, Optional[str]]:\n    return {\"param\": param}\n\n\napp = Starlite(route_handlers=[index])\n</code></pre>   <pre><code>from typing import Optional\n\nfrom starlite import Starlite, get\n\n\n@get(\"/\")\ndef index(param: Optional[str] = None) -&gt; dict[str, Optional[str]]:\n    return {\"param\": param}\n\n\napp = Starlite(route_handlers=[index])\n</code></pre>   <pre><code>from starlite import Starlite, get\n\n\n@get(\"/\")\ndef index(param: str | None = None) -&gt; dict[str, str | None]:\n    return {\"param\": param}\n\n\napp = Starlite(route_handlers=[index])\n</code></pre>     <p>Run it</p> <p><pre><code>&gt; curl http://127.0.0.1:8000/\n{\"param\":null}\n</code></pre> <pre><code>&gt; curl http://127.0.0.1:8000/?param=goodbye\n{\"param\":\"goodbye\"}\n</code></pre></p>"},{"location":"usage/3-parameters/1-query-parameters/#type-coercion","title":"Type coercion","text":"<p>It is possible to coerce query parameters into different types. A query starts out as a string, but its values can be parsed into all kinds of types. Since this is done by pydantic, everything that works there will work for query parameters as well.</p> Python 3.8+Python 3.9+   <pre><code>from datetime import datetime, timedelta\nfrom typing import Any, Dict\n\nfrom starlite import Starlite, get\n\n\n@get(\"/\")\ndef index(\n    date: datetime,\n    number: int,\n    floating_number: float,\n    strings: list[str],\n) -&gt; Dict[str, Any]:\n    return {\n        \"datetime\": date + timedelta(days=1),\n        \"int\": number,\n        \"float\": floating_number,\n        \"list\": strings,\n    }\n\n\napp = Starlite(route_handlers=[index])\n</code></pre>   <pre><code>from datetime import datetime, timedelta\nfrom typing import Any\n\nfrom starlite import Starlite, get\n\n\n@get(\"/\")\ndef index(\n    date: datetime,\n    number: int,\n    floating_number: float,\n    strings: list[str],\n) -&gt; dict[str, Any]:\n    return {\n        \"datetime\": date + timedelta(days=1),\n        \"int\": number,\n        \"float\": floating_number,\n        \"list\": strings,\n    }\n\n\napp = Starlite(route_handlers=[index])\n</code></pre>     <p>Run it</p> <pre><code>&gt; curl http://127.0.0.1:8000/?date=2022-11-28T13:22:06.916540&amp;floating_number=0.1&amp;number=42&amp;strings=1&amp;strings=2\n{\"datetime\":\"2022-11-29T13:22:06.916540\",\"int\":42,\"float\":0.1,\"list\":[\"1\",\"2\"]}\n</code></pre>"},{"location":"usage/3-parameters/1-query-parameters/#specifying-alternative-names-and-constraints","title":"Specifying alternative names and constraints","text":"<p>Sometimes you might want to \"remap\" query parameters to allow a different name in the URL than what's being used in the handler function. This can be done by making use of Parameter.</p> Python 3.8+Python 3.9+   <pre><code>from typing import Dict\n\nfrom starlite import Parameter, Starlite, get\n\n\n@get(\"/\")\ndef index(snake_case: str = Parameter(query=\"camelCase\")) -&gt; Dict[str, str]:\n    return {\"param\": snake_case}\n\n\napp = Starlite(route_handlers=[index])\n</code></pre>   <pre><code>from starlite import Parameter, Starlite, get\n\n\n@get(\"/\")\ndef index(snake_case: str = Parameter(query=\"camelCase\")) -&gt; dict[str, str]:\n    return {\"param\": snake_case}\n\n\napp = Starlite(route_handlers=[index])\n</code></pre>     <p>Run it</p> <pre><code>&gt; curl http://127.0.0.1:8000/?camelCase=foo\n{\"param\":\"foo\"}\n</code></pre>  <p>Here, we remap from <code>snake_case</code> in the handler function to <code>camelCase</code> in the URL. This means that for the URL <code>http://127.0.0.1:8000?camelCase=foo</code>, the value of <code>camelCase</code> will be used for the value of the <code>snake_case</code> parameter.</p> <p><code>Parameter</code> also allows us to define additional constraints:</p> Python 3.8+Python 3.9+   <pre><code>from typing import Dict\n\nfrom starlite import Parameter, Starlite, get\n\n\n@get(\"/\")\ndef index(param: int = Parameter(gt=5)) -&gt; Dict[str, int]:\n    return {\"param\": param}\n\n\napp = Starlite(route_handlers=[index])\n</code></pre>   <pre><code>from starlite import Parameter, Starlite, get\n\n\n@get(\"/\")\ndef index(param: int = Parameter(gt=5)) -&gt; dict[str, int]:\n    return {\"param\": param}\n\n\napp = Starlite(route_handlers=[index])\n</code></pre>    <p>In this case, <code>param</code> is validated to be an integer larger than 5.</p>"},{"location":"usage/3-parameters/2-header-and-cookie-parameters/","title":"Header and Cookie Parameters","text":"<p>Unlike Query parameters, Header and Cookie parameters have to be declared using the Parameter function, for example:</p> <pre><code>from pydantic import BaseModel\n\nfrom starlite import NotAuthorizedException, Parameter, Starlite, get\n\nUSER_DB = {\n    1: {\n        \"id\": 1,\n        \"name\": \"John Doe\",\n    },\n}\n\nVALID_TOKEN = \"super-secret-secret\"\nVALID_COOKIE_VALUE = \"cookie-secret\"\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n\n\n@get(path=\"/users/{user_id:int}/\")\nasync def get_user(\n    user_id: int,\n    token: str = Parameter(header=\"X-API-KEY\"),\n    cookie: str = Parameter(cookie=\"my-cookie-param\"),\n) -&gt; User:\n    if not (token == VALID_TOKEN and cookie == VALID_COOKIE_VALUE):\n        raise NotAuthorizedException\n    return User.parse_obj(USER_DB[user_id])\n\n\napp = Starlite(route_handlers=[get_user])\n</code></pre> <p>As you can see in the above, header parameters are declared using the <code>header</code> kwargs and cookie parameters using the <code>cookie</code> kwarg. Aside form this difference they work the same as query parameters.</p>"},{"location":"usage/3-parameters/3-the-parameter-function/","title":"The Parameter Function","text":"<p><code>Parameter</code> is a wrapper on top of the pydantic Field function that extends it with a set of Starlite specific kwargs. As such, you can use most of the kwargs of Field with Parameter and have the same parsing and validation. The additional kwargs accepted by <code>Parameter</code> are passed to the resulting pydantic <code>FieldInfo</code> as an <code>extra</code>dictionary and have no effect on the working of pydantic itself.</p> <p>See the API Reference for full details on the <code>Parameter</code> function and the kwargs it accepts.</p>"},{"location":"usage/3-parameters/4-layered-parameters/","title":"Layered Parameters","text":"<p>As part of Starlite's \"layered\" architecture, you can declare parameters not only as part of individual route handler functions, but also on other layers of the application:</p> Python 3.8+Python 3.9+Python 3.10+   <pre><code>from typing import Dict, Union\n\nfrom starlite import Controller, Parameter, Router, Starlite, get\n\n\nclass MyController(Controller):\n    path = \"/controller\"\n    parameters = {\n        \"controller_param\": Parameter(int, lt=100),\n    }\n\n    @get(\"/{path_param:int}\")\n    def my_handler(\n        self,\n        path_param: int,\n        local_param: str,\n        router_param: str,\n        controller_param: int = Parameter(int, lt=50),\n    ) -&gt; Dict[str, Union[str, int]]:\n        return {\n            \"path_param\": path_param,\n            \"local_param\": local_param,\n            \"router_param\": router_param,\n            \"controller_param\": controller_param,\n        }\n\n\nrouter = Router(\n    path=\"/router\",\n    route_handlers=[MyController],\n    parameters={\n        \"router_param\": Parameter(str, regex=\"^[a-zA-Z]$\", header=\"MyHeader\", required=False),\n    },\n)\n\napp = Starlite(\n    route_handlers=[router],\n    parameters={\n        \"app_param\": Parameter(str, cookie=\"special-cookie\"),\n    },\n)\n</code></pre>   <pre><code>from typing import Union\n\nfrom starlite import Controller, Parameter, Router, Starlite, get\n\n\nclass MyController(Controller):\n    path = \"/controller\"\n    parameters = {\n        \"controller_param\": Parameter(int, lt=100),\n    }\n\n    @get(\"/{path_param:int}\")\n    def my_handler(\n        self,\n        path_param: int,\n        local_param: str,\n        router_param: str,\n        controller_param: int = Parameter(int, lt=50),\n    ) -&gt; dict[str, Union[str, int]]:\n        return {\n            \"path_param\": path_param,\n            \"local_param\": local_param,\n            \"router_param\": router_param,\n            \"controller_param\": controller_param,\n        }\n\n\nrouter = Router(\n    path=\"/router\",\n    route_handlers=[MyController],\n    parameters={\n        \"router_param\": Parameter(str, regex=\"^[a-zA-Z]$\", header=\"MyHeader\", required=False),\n    },\n)\n\napp = Starlite(\n    route_handlers=[router],\n    parameters={\n        \"app_param\": Parameter(str, cookie=\"special-cookie\"),\n    },\n)\n</code></pre>   <pre><code>from starlite import Controller, Parameter, Router, Starlite, get\n\n\nclass MyController(Controller):\n    path = \"/controller\"\n    parameters = {\n        \"controller_param\": Parameter(int, lt=100),\n    }\n\n    @get(\"/{path_param:int}\")\n    def my_handler(\n        self,\n        path_param: int,\n        local_param: str,\n        router_param: str,\n        controller_param: int = Parameter(int, lt=50),\n    ) -&gt; dict[str, str | int]:\n        return {\n            \"path_param\": path_param,\n            \"local_param\": local_param,\n            \"router_param\": router_param,\n            \"controller_param\": controller_param,\n        }\n\n\nrouter = Router(\n    path=\"/router\",\n    route_handlers=[MyController],\n    parameters={\n        \"router_param\": Parameter(str, regex=\"^[a-zA-Z]$\", header=\"MyHeader\", required=False),\n    },\n)\n\napp = Starlite(\n    route_handlers=[router],\n    parameters={\n        \"app_param\": Parameter(str, cookie=\"special-cookie\"),\n    },\n)\n</code></pre>    <p>In the above we declare parameters on the app, router and controller levels in addition to those declared in the route handler. Let's look at these closer.</p> <ul> <li> <p><code>app_param</code> is a cookie param with the key <code>special-cookie</code>. We type it as <code>str</code> by passing this as an arg to   the <code>Parameter</code> function. This is required for us to get typing in the OpenAPI docs. Additionally, this parameter is   assumed to be required because it is not explicitly declared as <code>required=False</code>. This is important because the route   handler function does not declare a parameter called <code>app_param</code> at all, but it will still require this param to be   sent   as part of the request of validation will fail.</p> </li> <li> <p><code>router_param</code> is a header param with the key <code>MyHeader</code>. Because its declared as <code>required=False</code>, it will not fail   validation if not present unless explicitly declared by a route handler - and in this case it is. Thus, it is actually   required for the router handler function that declares it as an <code>str</code> and not an <code>Optional[str]</code>. If a string value is   provided, it will be tested against the provided regex.</p> </li> <li> <p><code>controller_param</code> is a query param with the key <code>controller_param</code>. It has an <code>lt=100</code> defined on the controller,   which   means the provided value must be less than 100. Yet the route handler re-declares it with an <code>lt=50</code>, which means for   the route handler this value must be less than 50.</p> </li> <li> <p>Finally <code>local_param</code> is a route handler local query parameter, and <code>path_param</code> is a path parameter.</p> </li> </ul>  <p>Note</p> <p>You cannot declare path parameters in different application layers. The reason for this is to ensure simplicity - otherwise parameter resolution becomes very difficult to do correctly.</p>"},{"location":"usage/5-responses/0-responses-intro/","title":"HTTP Responses","text":"<p>Starlite allows for several ways in which HTTP responses can be specified and handled, each fitting a different use case. The base pattern though is straightforward - simply return a value from a route handler function and let Starlite take care of the rest:</p> <pre><code>from pydantic import BaseModel\nfrom starlite import get\n\n\nclass Resource(BaseModel):\n    id: int\n    name: str\n\n\n@get(\"/resources\")\ndef retrieve_resource() -&gt; Resource:\n    return Resource(id=1, name=\"my resource\")\n</code></pre> <p>In the example above, the route handler function returns an instance of the <code>Resource</code> pydantic class. This value will then be used by Starlite to construct an instance of the <code>Response</code> class using defaults values: the response status code will be set to <code>200</code> and it's <code>Content-Type</code> header will be set to <code>application/json</code>. The <code>Resource</code> instance will be serialized into JSON and set as the response body.</p>"},{"location":"usage/5-responses/1-media-type/","title":"Media Type","text":"<p>You do not have to specify the <code>media_type</code> kwarg in the route handler function if the response should be JSON. But if you wish to return a response other than JSON, you should specify this value. You can use the <code>MediaType</code> enum for this purpose:</p> <pre><code>from starlite import MediaType, get\n\n\n@get(\"/resources\", media_type=MediaType.TEXT)\ndef retrieve_resource() -&gt; str:\n    return \"The rumbling rabbit ran around the rock\"\n</code></pre> <p>The value of the <code>media_type</code> kwarg affects both the serialization of response data and the generation of OpenAPI docs. The above example will cause Starlite to serialize the response as a simple bytes string with a <code>Content-Type</code> header value of <code>text/plain</code>. It will also set the corresponding values in the OpenAPI documentation.</p> <p>MediaType has the following members:</p> <ul> <li>MediaType.JSON: <code>application/json</code></li> <li>MediaType.MessagePack: <code>application/x-msgpack</code></li> <li>MediaType.TEXT: <code>text/plain</code></li> <li>MediaType.HTML: <code>text/html</code></li> </ul> <p>You can also set any IANA referenced media type string as the <code>media_type</code>. While this will still affect the OpenAPI generation as expected, you might need to handle serialization using either a custom response with serializer or by serializing the value in the route handler function.</p>"},{"location":"usage/5-responses/1-media-type/#json-responses","title":"JSON Responses","text":"<p>As previously mentioned, the default <code>media_type</code> is <code>MediaType.JSON</code>. which supports the following values:</p> <ul> <li>dictionaries</li> <li>dataclasses from the standard library</li> <li>pydantic dataclasses</li> <li>pydantic models</li> <li>models from libraries that extend pydantic models</li> <li>lists containing any of the above elements</li> <li>UUIDs</li> <li>datetime objects</li> <li><code>msgspec.Struct</code></li> </ul> <p>If you need to return other values and would like to extend serialization you can do this using Custom Responses.</p>"},{"location":"usage/5-responses/1-media-type/#messagepack-responses","title":"MessagePack Responses","text":"<p>In addition to JSON, Starlite offers support for the MessagePack format which can be a time and space efficient alternative to JSON.</p> <p>It supports all the same types as JSON serialization. To send a <code>MessagePack</code> response, simply specify the media type as <code>MediaType.MESSAGEPACK</code>:</p> Python 3.8+Python 3.9+   <pre><code>from typing import Dict\nfrom starlite import get, MediaType\n\n\n@get(path=\"/health-check\", media_type=MediaType.MESSAGEPACK)\ndef health_check() -&gt; Dict[str, str]:\n    return {\"hello\": \"world\"}\n</code></pre>   <pre><code>from starlite import get, MediaType\n\n\n@get(path=\"/health-check\", media_type=MediaType.MESSAGEPACK)\ndef health_check() -&gt; dict[str, str]:\n    return {\"hello\": \"world\"}\n</code></pre>"},{"location":"usage/5-responses/1-media-type/#text-responses","title":"Text Responses","text":"<p>For <code>MediaType.TEXT</code>, route handlers should return a string or bytes value:</p> <pre><code>from starlite import get, MediaType\n\n\n@get(path=\"/health-check\", media_type=MediaType.TEXT)\ndef health_check() -&gt; str:\n    return \"healthy\"\n</code></pre>"},{"location":"usage/5-responses/1-media-type/#html-responses","title":"HTML Responses","text":"<p>For <code>MediaType.HTML</code>, route handlers should return a string or bytes value that contains HTML:</p> <pre><code>from starlite import get, MediaType\n\n\n@get(path=\"/page\", media_type=MediaType.HTML)\ndef health_check() -&gt; str:\n    return \"\"\"\n    &lt;html&gt;\n        &lt;body&gt;\n            &lt;div&gt;\n                &lt;span&gt;Hello World!&lt;/span&gt;\n            &lt;/div&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n</code></pre>  <p>Tip</p> <p>It's a good idea to use a templating engine for more complex HTML responses and to write the template itself in a separate file rather than a string.</p>"},{"location":"usage/5-responses/10-custom-responses/","title":"Custom Responses","text":"<p>While Starlite supports the serialization of many types by default, sometimes you want to return something that's not supported. In those cases it's convenient to make use of a custom response class.</p> <p>The example below illustrates how to deal with MultiDict instances.</p> <pre><code>from starlite import Response, Starlite, get\nfrom starlite.datastructures import MultiDict\n\n\nclass MultiDictResponse(Response):\n    type_encoders = {MultiDict: lambda d: d.dict()}\n\n\n@get(\"/\")\nasync def index() -&gt; MultiDict:\n    return MultiDict([(\"foo\", \"bar\"), (\"foo\", \"baz\")])\n\n\napp = Starlite([index], response_class=MultiDictResponse)\n</code></pre>  <p>Run it</p> <pre><code>&gt; curl http://127.0.0.1:8000/\n{\"foo\":[\"bar\",\"baz\"]}\n</code></pre>   <p>Layered architecture</p> <p>Response classes are part of Starlite's layered architecture, which means you can set a response class on every layer of the application. If you have set a response class on multiple layers, the layer closes to the route handler will take precedence.</p> <p>You can read more about this here: Layered architecture</p>"},{"location":"usage/5-responses/11-background-tasks/","title":"Background Tasks","text":"<p>All Starlite responses and response containers (e.g. <code>File</code>, <code>Template</code> etc.) allow passing in a <code>background_task</code> kwarg. This kwarg accepts either an instance of <code>BackgroundTask</code> or an instance of <code>BackgroundTasks</code>, which wraps an iterable of <code>BackgroundTask</code> instances.</p> <p>A background task is a sync or async callable (function, method or class that implements the <code>__call__</code> dunder method) that will be called after the response finishes sending the data.</p> <p>Thus, in the following example the passed in background task will be executed after the response sends:</p> <pre><code>import logging\n\nfrom starlite import BackgroundTask, get\n\nlogger = logging.getLogger(__name__)\n\n\nasync def logging_task(identifier: str, message: str) -&gt; None:\n    logger.info(f\"{identifier}: {message}\")\n\n\n@get(\"/\", background=BackgroundTask(logging_task, \"greeter\", message=\"was called\"))\ndef greeter() -&gt; dict[str, str]:\n    return {\"hello\": \"world\"}\n</code></pre> <p>When the <code>greeter</code> handler is called, the logging task will be called with any <code>*args</code> and <code>**kwargs</code> passed into the <code>BackgroundTask</code>.</p>  <p>Note</p> <p>In the above example <code>\"greeter\"</code> is an arg and <code>message=\"was called\"</code> is a kwarg. The function signature of <code>logging_task</code> allows for this, so this should pose no problem. Starlite uses <code>ParamSpec</code> to ensure that a <code>BackgroundTask</code> is properly typed, so will get type checking for any passed in args and kwargs.</p>"},{"location":"usage/5-responses/11-background-tasks/#executing-multiple-backgroundtasks","title":"Executing Multiple BackgroundTasks","text":"<p>You can also use the <code>BackgroundTasks</code> class instead, and pass to it an iterable (list, tuple etc.) of <code>BackgroundTask</code> instances. This class accepts one optional kwargs aside from the tasks - <code>run_in_task_group</code>, which is a boolean flag that defaults to <code>False</code>. If you set this value to <code>True</code> than the tasks will run concurrently, using an <code>anyio.task_group</code>.</p>  <p>Note</p> <p>Setting <code>run_in_task_group</code> to <code>True</code> will not preserve execution order.</p>"},{"location":"usage/5-responses/12-pagination/","title":"Pagination","text":"<p>When you need to return a large number of items from an endpoint it is common practice to use pagination to ensure clients can request a specific subset or \"page\" from the total dataset. Starlite supports three types of pagination out of the box:</p> <ul> <li>classic pagination</li> <li>limit / offset pagination</li> <li>cursor pagination</li> </ul>"},{"location":"usage/5-responses/12-pagination/#classic-pagination","title":"Classic Pagination","text":"<p>In classic pagination the dataset is divided into pages of a specific size and the consumer then requests a specific page.</p> Python 3.8+Python 3.9+   Classic Pagination<pre><code>from typing import List\n\nfrom pydantic import BaseModel\nfrom pydantic_factories import ModelFactory\n\nfrom starlite import AbstractSyncClassicPaginator, ClassicPagination, Starlite, get\n\n\nclass Person(BaseModel):\n    id: str\n    name: str\n\n\nclass PersonFactory(ModelFactory[Person]):\n    __model__ = Person\n\n\n# we will implement a paginator - the paginator must implement two methods 'get_total' and 'get_items'\n# we would usually use a database for this, but for our case we will \"fake\" the dataset using a factory.\n\n\nclass PersonClassicPaginator(AbstractSyncClassicPaginator[Person]):\n    def __init__(self) -&gt; None:\n        self.data = PersonFactory.batch(50)\n\n    def get_total(self, page_size: int) -&gt; int:\n        return round(len(self.data) / page_size)\n\n    def get_items(self, page_size: int, current_page: int) -&gt; List[Person]:\n        return [self.data[i : i + page_size] for i in range(0, len(self.data), page_size)][current_page - 1]\n\n\npaginator = PersonClassicPaginator()\n\n\n# we now create a regular handler. The handler will receive two query parameters - 'page_size' and 'current_page', which\n# we will pass to the paginator.\n@get(\"/people\")\ndef people_handler(page_size: int, current_page: int) -&gt; ClassicPagination[Person]:\n    return paginator(page_size=page_size, current_page=current_page)\n\n\napp = Starlite(route_handlers=[people_handler])\n</code></pre>   Classic Pagination<pre><code>from pydantic import BaseModel\nfrom pydantic_factories import ModelFactory\n\nfrom starlite import AbstractSyncClassicPaginator, ClassicPagination, Starlite, get\n\n\nclass Person(BaseModel):\n    id: str\n    name: str\n\n\nclass PersonFactory(ModelFactory[Person]):\n    __model__ = Person\n\n\n# we will implement a paginator - the paginator must implement two methods 'get_total' and 'get_items'\n# we would usually use a database for this, but for our case we will \"fake\" the dataset using a factory.\n\n\nclass PersonClassicPaginator(AbstractSyncClassicPaginator[Person]):\n    def __init__(self) -&gt; None:\n        self.data = PersonFactory.batch(50)\n\n    def get_total(self, page_size: int) -&gt; int:\n        return round(len(self.data) / page_size)\n\n    def get_items(self, page_size: int, current_page: int) -&gt; list[Person]:\n        return [self.data[i : i + page_size] for i in range(0, len(self.data), page_size)][current_page - 1]\n\n\npaginator = PersonClassicPaginator()\n\n\n# we now create a regular handler. The handler will receive two query parameters - 'page_size' and 'current_page', which\n# we will pass to the paginator.\n@get(\"/people\")\ndef people_handler(page_size: int, current_page: int) -&gt; ClassicPagination[Person]:\n    return paginator(page_size=page_size, current_page=current_page)\n\n\napp = Starlite(route_handlers=[people_handler])\n</code></pre>    <p>The data container for this pagination is called <code>ClassicPagination</code>, which is what will be returned by the paginator in the above example This will also generate the corresponding OpenAPI documentation.</p> <p>If you require async logic, you can implement the <code>AbstractAsyncClassicPaginator</code> instead of the <code>AbstractSyncClassicPaginator</code>.</p>"},{"location":"usage/5-responses/12-pagination/#offset-pagination","title":"Offset Pagination","text":"<p>In offset pagination the consumer requests a number of items specified by <code>limit</code> and the <code>offset</code> from the beginning of the dataset. For example, given a list of 50 items, you could request <code>limit=10</code>, <code>offset=39</code> to request items 40-50.</p> Python 3.8+Python 3.9+   Offset Pagination<pre><code>from itertools import islice\nfrom typing import List\n\nfrom pydantic import BaseModel\nfrom pydantic_factories import ModelFactory\n\nfrom starlite import AbstractSyncOffsetPaginator, OffsetPagination, Starlite, get\n\n\nclass Person(BaseModel):\n    id: str\n    name: str\n\n\nclass PersonFactory(ModelFactory[Person]):\n    __model__ = Person\n\n\n# we will implement a paginator - the paginator must implement two methods 'get_total' and 'get_items'\n# we would usually use a database for this, but for our case we will \"fake\" the dataset using a factory.\n\n\nclass PersonOffsetPaginator(AbstractSyncOffsetPaginator[Person]):\n    def __init__(self) -&gt; None:\n        self.data = PersonFactory.batch(50)\n\n    def get_total(self) -&gt; int:\n        return len(self.data)\n\n    def get_items(self, limit: int, offset: int) -&gt; List[Person]:\n        return list(islice(islice(self.data, offset, None), limit))\n\n\npaginator = PersonOffsetPaginator()\n\n\n# we now create a regular handler. The handler will receive two query parameters - 'limit' and 'offset', which\n# we will pass to the paginator.\n@get(\"/people\")\ndef people_handler(limit: int, offset: int) -&gt; OffsetPagination[Person]:\n    return paginator(limit=limit, offset=offset)\n\n\napp = Starlite(route_handlers=[people_handler])\n</code></pre>   Offset Pagination<pre><code>from itertools import islice\n\nfrom pydantic import BaseModel\nfrom pydantic_factories import ModelFactory\n\nfrom starlite import AbstractSyncOffsetPaginator, OffsetPagination, Starlite, get\n\n\nclass Person(BaseModel):\n    id: str\n    name: str\n\n\nclass PersonFactory(ModelFactory[Person]):\n    __model__ = Person\n\n\n# we will implement a paginator - the paginator must implement two methods 'get_total' and 'get_items'\n# we would usually use a database for this, but for our case we will \"fake\" the dataset using a factory.\n\n\nclass PersonOffsetPaginator(AbstractSyncOffsetPaginator[Person]):\n    def __init__(self) -&gt; None:\n        self.data = PersonFactory.batch(50)\n\n    def get_total(self) -&gt; int:\n        return len(self.data)\n\n    def get_items(self, limit: int, offset: int) -&gt; list[Person]:\n        return list(islice(islice(self.data, offset, None), limit))\n\n\npaginator = PersonOffsetPaginator()\n\n\n# we now create a regular handler. The handler will receive two query parameters - 'limit' and 'offset', which\n# we will pass to the paginator.\n@get(\"/people\")\ndef people_handler(limit: int, offset: int) -&gt; OffsetPagination[Person]:\n    return paginator(limit=limit, offset=offset)\n\n\napp = Starlite(route_handlers=[people_handler])\n</code></pre>    <p>The data container for this pagination is called <code>OffsetPagination</code>, which is what will be returned by the paginator in the above example This will also generate the corresponding OpenAPI documentation.</p> <p>If you require async logic, you can implement the <code>AbstractAsyncOffsetPaginator</code> instead of the <code>AbstractSyncOffsetPaginator</code>.</p>"},{"location":"usage/5-responses/12-pagination/#cursor-pagination","title":"Cursor Pagination","text":"<p>In cursor pagination the consumer requests a number of items specified by <code>results_per_page</code> and a <code>cursor</code> after which results are given. Cursor is unique identifier within the dataset that serves as a way to point the starting position.</p> Python 3.8+Python 3.9+Python 3.10+   Cursor Pagination<pre><code>from typing import List, Optional, Tuple\n\nfrom pydantic import BaseModel\nfrom pydantic_factories import ModelFactory\n\nfrom starlite import AbstractSyncCursorPaginator, CursorPagination, Starlite, get\n\n\nclass Person(BaseModel):\n    id: str\n    name: str\n\n\nclass PersonFactory(ModelFactory[Person]):\n    __model__ = Person\n\n\n# we will implement a paginator - the paginator must implement the method 'get_items'.\n\n\nclass PersonCursorPaginator(AbstractSyncCursorPaginator[str, Person]):\n    def __init__(self) -&gt; None:\n        self.data = PersonFactory.batch(50)\n\n    def get_items(self, cursor: Optional[str], results_per_page: int) -&gt; Tuple[List[Person], Optional[str]]:\n        results = self.data[:results_per_page]\n        return results, results[-1].id\n\n\npaginator = PersonCursorPaginator()\n\n\n# we now create a regular handler. The handler will receive a single query parameter - 'cursor', which\n# we will pass to the paginator.\n@get(\"/people\")\ndef people_handler(cursor: Optional[str], results_per_page: int) -&gt; CursorPagination[str, Person]:\n    return paginator(cursor=cursor, results_per_page=results_per_page)\n\n\napp = Starlite(route_handlers=[people_handler])\n</code></pre>   Cursor Pagination<pre><code>from typing import Optional\n\nfrom pydantic import BaseModel\nfrom pydantic_factories import ModelFactory\n\nfrom starlite import AbstractSyncCursorPaginator, CursorPagination, Starlite, get\n\n\nclass Person(BaseModel):\n    id: str\n    name: str\n\n\nclass PersonFactory(ModelFactory[Person]):\n    __model__ = Person\n\n\n# we will implement a paginator - the paginator must implement the method 'get_items'.\n\n\nclass PersonCursorPaginator(AbstractSyncCursorPaginator[str, Person]):\n    def __init__(self) -&gt; None:\n        self.data = PersonFactory.batch(50)\n\n    def get_items(self, cursor: Optional[str], results_per_page: int) -&gt; tuple[list[Person], Optional[str]]:\n        results = self.data[:results_per_page]\n        return results, results[-1].id\n\n\npaginator = PersonCursorPaginator()\n\n\n# we now create a regular handler. The handler will receive a single query parameter - 'cursor', which\n# we will pass to the paginator.\n@get(\"/people\")\ndef people_handler(cursor: Optional[str], results_per_page: int) -&gt; CursorPagination[str, Person]:\n    return paginator(cursor=cursor, results_per_page=results_per_page)\n\n\napp = Starlite(route_handlers=[people_handler])\n</code></pre>   Cursor Pagination<pre><code>from pydantic import BaseModel\nfrom pydantic_factories import ModelFactory\n\nfrom starlite import AbstractSyncCursorPaginator, CursorPagination, Starlite, get\n\n\nclass Person(BaseModel):\n    id: str\n    name: str\n\n\nclass PersonFactory(ModelFactory[Person]):\n    __model__ = Person\n\n\n# we will implement a paginator - the paginator must implement the method 'get_items'.\n\n\nclass PersonCursorPaginator(AbstractSyncCursorPaginator[str, Person]):\n    def __init__(self) -&gt; None:\n        self.data = PersonFactory.batch(50)\n\n    def get_items(self, cursor: str | None, results_per_page: int) -&gt; tuple[list[Person], str | None]:\n        results = self.data[:results_per_page]\n        return results, results[-1].id\n\n\npaginator = PersonCursorPaginator()\n\n\n# we now create a regular handler. The handler will receive a single query parameter - 'cursor', which\n# we will pass to the paginator.\n@get(\"/people\")\ndef people_handler(cursor: str | None, results_per_page: int) -&gt; CursorPagination[str, Person]:\n    return paginator(cursor=cursor, results_per_page=results_per_page)\n\n\napp = Starlite(route_handlers=[people_handler])\n</code></pre>    <p>The data container for this pagination is called <code>CursorPagination</code>, which is what will be returned by the paginator in the above example This will also generate the corresponding OpenAPI documentation.</p> <p>If you require async logic, you can implement the <code>AbstractAsyncCursorPaginator</code> instead of the <code>AbstractSyncCursorPaginator</code>.</p>"},{"location":"usage/5-responses/2-status-codes/","title":"Status Codes","text":"<p>You can control the response <code>status_code</code> by setting the corresponding kwarg to the desired value:</p> <pre><code>from pydantic import BaseModel\nfrom starlite import get\nfrom starlite.status_codes import HTTP_202_ACCEPTED\n\n\nclass Resource(BaseModel):\n    id: int\n    name: str\n\n\n@get(\"/resources\", status_code=HTTP_202_ACCEPTED)\ndef retrieve_resource() -&gt; Resource:\n    return Resource(id=1, name=\"my resource\")\n</code></pre> <p>If <code>status_code</code> is not set by the user, the following defaults are used:</p> <ul> <li>POST: 201 (Created)</li> <li>DELETE: 204 (No Content)</li> <li>GET, PATCH, PUT: 200 (Ok)</li> </ul>  <p>Important</p> <p>For status codes &lt; 100 or 204, 304 statuses, no response body is allowed. If you specify a return annotation other than <code>None</code>, an <code>ImproperlyConfiguredException</code> will be raised.</p>   <p>Note</p> <p>When using the <code>route</code> decorator with multiple http methods, the default status code is <code>200</code>.</p>   <p>Note</p> <p>The default for <code>delete</code> is <code>204</code> because by default it is assumed that delete operations return no data. This though might not be the case in your implementation - so take care of setting it as you see fit.</p>   <p>Tip</p> <p>While you can write integers as the value for <code>status_code</code>, e.g. <code>200</code>, it's best practice to use constants (also in tests). Starlite includes easy to use statuses that are exported from <code>starlite.status_codes</code>, e.g. <code>HTTP_200_OK</code> and <code>HTTP_201_CREATED</code>. Another option is the <code>http.HTTPStatus</code>enum from the standard library, which also offers extra functionality. For this see the standard library documentation.</p>"},{"location":"usage/5-responses/3-returning-responses/","title":"Returning Responses","text":"<p>While the default response handling fits most use cases, in some cases you need to be able to return a response instance directly.</p> <p>Starlite allows you to return any class inheriting from the <code>Response</code> class. Thus, the below example will work perfectly fine:</p> <pre><code>from pydantic import BaseModel\n\nfrom starlite import Response, Starlite, get\nfrom starlite.datastructures import Cookie\n\n\nclass Resource(BaseModel):\n    id: int\n    name: str\n\n\n@get(\"/resources\")\ndef retrieve_resource() -&gt; Response[Resource]:\n    return Response(\n        Resource(\n            id=1,\n            name=\"my resource\",\n        ),\n        headers={\"MY-HEADER\": \"xyz\"},\n        cookies=[Cookie(key=\"my-cookie\", value=\"abc\")],\n    )\n\n\napp = Starlite(route_handlers=[retrieve_resource])\n</code></pre>  <p>Important</p> <p>In the case of the builtin <code>TemplateResponse</code>, <code>FileResponse</code>, <code>StreamingResponse</code> and <code>RedirectResponse</code> you should use the response \"response containers\", otherwise OpenAPI documentation will not be generated correctly. For more details see the respective documentation sections for the Template, File, Stream and Redirect.</p>"},{"location":"usage/5-responses/3-returning-responses/#annotating-responses","title":"Annotating Responses","text":"<p>As you can see above, the <code>Response</code> class accepts a generic argument. This allows Starlite to infer the response body when generating the OpenAPI docs.</p>  <p>Note</p> <p>If the generic argument is not provided, and thus defaults to <code>Any</code>, the OpenAPI docs will be imprecise. So make sure to type this argument even when returning an empty or <code>null</code> body, i.e. use <code>None</code>.</p>"},{"location":"usage/5-responses/3-returning-responses/#returning-asgi-applications","title":"Returning ASGI Applications","text":"<p>Starlite also supports returning ASGI applications directly, as you would responses. For example:</p> <pre><code>from starlite import get\nfrom starlite.types import ASGIApp, Receive, Scope, Send\n\n\n@get(\"/\")\ndef handler() -&gt; ASGIApp:\n    async def my_asgi_app(scope: Scope, receive: Receive, send: Send) -&gt; None:\n        ...\n\n    return my_asgi_app\n</code></pre>"},{"location":"usage/5-responses/3-returning-responses/#what-is-an-asgi-application","title":"What is an ASGI Application?","text":"<p>An ASGI application in this context is any async callable (function, class method or simply a class that implements that special <code>__call__</code> dunder method) that accepts the three ASGI arguments: <code>scope</code>, <code>receive</code> and <code>send</code>.</p> <p>For example, all the following examples are ASGI applications:</p>"},{"location":"usage/5-responses/3-returning-responses/#function-asgi-application","title":"Function ASGI Application","text":"<pre><code>from starlite.types import Receive, Scope, Send\n\n\nasync def my_asgi_app_function(scope: Scope, receive: Receive, send: Send) -&gt; None:\n    # do something here\n    ...\n</code></pre>"},{"location":"usage/5-responses/3-returning-responses/#method-asgi-application","title":"Method ASGI Application","text":"<pre><code>from starlite.types import Receive, Scope, Send\n\n\nclass MyClass:\n    async def my_asgi_app_method(\n        self, scope: Scope, receive: Receive, send: Send\n    ) -&gt; None:\n        # do something here\n        ...\n</code></pre>"},{"location":"usage/5-responses/3-returning-responses/#class-asgi-application","title":"Class ASGI Application","text":"<pre><code>from starlite.types import Receive, Scope, Send\n\n\nclass ASGIApp:\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n        # do something here\n        ...\n</code></pre>"},{"location":"usage/5-responses/3-returning-responses/#returning-other-library-responses","title":"Returning Other Library Responses","text":"<p>Because you can return any ASGI Application from a route handler, you can also use any ASGI application from other libraries. For example, you can return the response classes from Starlette or FastAPI directly from route handlers:</p> <pre><code>from starlette.responses import JSONResponse\n\nfrom starlite import get\nfrom starlite.types import ASGIApp\n\n\n@get(\"/\")\ndef handler() -&gt; ASGIApp:\n    return JSONResponse(content={\"hello\": \"world\"})  # type: ignore\n</code></pre>  <p>Important</p> <p>Starlite offers strong typing for the ASGI arguments. Other libraries often offer less strict typing, which might cause type checkers to complain when using ASGI apps from them inside Starlite. For the time being, the only solution is to add <code># type: ignore</code> comments in the pertinent places. Nonetheless, the above example will work perfectly fine.</p>"},{"location":"usage/5-responses/4-response-headers/","title":"Response Headers","text":"<p>Starlite allows you to define response headers by using the <code>response_headers</code> kwarg. This kwarg is available on all layers of the app - individual route handlers, controllers, routers and the app itself:</p> <pre><code>from starlite import Controller, MediaType, Router, Starlite, get\nfrom starlite.datastructures import ResponseHeader\n\n\nclass MyController(Controller):\n    path = \"/controller-path\"\n    response_headers = {\n        \"controller-level-header\": ResponseHeader(value=\"controller header\", description=\"controller level header\")\n    }\n\n    @get(\n        path=\"/handler-path\",\n        response_headers={\"my-local-header\": ResponseHeader(value=\"local header\", description=\"local level header\")},\n        media_type=MediaType.TEXT,\n    )\n    def my_route_handler(self) -&gt; str:\n        return \"hello world\"\n\n\nrouter = Router(\n    path=\"/router-path\",\n    route_handlers=[MyController],\n    response_headers={\"router-level-header\": ResponseHeader(value=\"router header\", description=\"router level header\")},\n)\n\napp = Starlite(\n    route_handlers=[router],\n    response_headers={\"app-level-header\": ResponseHeader(value=\"app header\", description=\"app level header\")},\n)\n</code></pre> <p>In the above example the response returned from <code>my_route_handler</code> will have headers set from each layer of the application using the given key+value combinations. I.e. it will be a dictionary equal to this:</p> <pre><code>{\n  \"my-local-header\": \"local header\",\n  \"controller-level-header\": \"controller header\",\n  \"router-level-header\": \"router header\",\n  \"app-level-header\": \"app header\"\n}\n</code></pre> <p>The respective descriptions will be used for the OpenAPI documentation.</p>"},{"location":"usage/5-responses/4-response-headers/#dynamic-headers","title":"Dynamic Headers","text":"<p>The above detailed scheme works great for statically configured headers, but how would you go about handling dynamically setting headers? Starlite allows you to set headers dynamically in several ways and below we will detail the two primary patterns.</p>"},{"location":"usage/5-responses/4-response-headers/#setting-response-headers-using-annotated-responses","title":"Setting Response Headers Using Annotated Responses","text":"<p>We can simply return a response instance directly from the route handler and set the headers dictionary manually as you see fit, e.g.:</p> <pre><code>from random import randint\n\nfrom pydantic import BaseModel\n\nfrom starlite import Response, Starlite, get\nfrom starlite.datastructures import ResponseHeader\n\n\nclass Resource(BaseModel):\n    id: int\n    name: str\n\n\n@get(\n    \"/resources\",\n    response_headers={\n        \"Random-Header\": ResponseHeader(description=\"a random number in the range 1 - 100\", documentation_only=True)\n    },\n)\ndef retrieve_resource() -&gt; Response[Resource]:\n    return Response(\n        Resource(\n            id=1,\n            name=\"my resource\",\n        ),\n        headers={\"Random-Header\": str(randint(1, 100))},\n    )\n\n\napp = Starlite(route_handlers=[retrieve_resource])\n</code></pre> <p>In the above we use the <code>response_headers</code> kwarg to pass the <code>name</code> and <code>description</code> parameters for the <code>Random-Header</code> to the OpenAPI documentation, but we set the value dynamically in as part of the annotated response we return. To this end we do not set a <code>value</code> for it and we designate it as <code>documentation_only=True</code>.</p>"},{"location":"usage/5-responses/4-response-headers/#setting-response-headers-using-the-after-request-hook","title":"Setting Response Headers Using the After Request Hook","text":"<p>An alternative pattern would be to use an after request handler. We can define the handler on different layers of the application as explained in the pertinent docs. We should take care to document the headers on the corresponding layer:</p> <pre><code>from random import randint\n\nfrom pydantic import BaseModel\n\nfrom starlite import Response, Router, Starlite, get\nfrom starlite.datastructures import ResponseHeader\n\n\nclass Resource(BaseModel):\n    id: int\n    name: str\n\n\n@get(\n    \"/resources\",\n    response_headers={\n        \"Random-Header\": ResponseHeader(\n            description=\"a random number in the range 100 - 1000\",\n            documentation_only=True,\n        )\n    },\n)\ndef retrieve_resource() -&gt; Response[Resource]:\n    return Response(\n        Resource(\n            id=1,\n            name=\"my resource\",\n        ),\n        headers={\"Random-Header\": str(randint(100, 1000))},\n    )\n\n\ndef after_request_handler(response: Response) -&gt; Response:\n    response.headers.update({\"Random-Header\": str(randint(1, 100))})\n    return response\n\n\nrouter = Router(\n    path=\"/router-path\",\n    route_handlers=[retrieve_resource],\n    after_request=after_request_handler,\n    response_headers={\n        \"Random-Header\": ResponseHeader(\n            description=\"a random number in the range 1 - 100\",\n            documentation_only=True,\n        )\n    },\n)\n\n\napp = Starlite(route_handlers=[router])\n</code></pre> <p>In the above we set the response header using an <code>after_request_handler</code> function on the router level. Because the handler function is applied on the router, we also set the documentation for it on the router.</p> <p>We can use this pattern to fine-tune the OpenAPI documentation more granularly by overriding header specification as required. For example, lets say we have a router level header being set and a local header with the same key but a different value range:</p> <pre><code>from random import randint\n\nfrom pydantic import BaseModel\n\nfrom starlite import Response, Router, Starlite, get\nfrom starlite.datastructures import ResponseHeader\n\n\nclass Resource(BaseModel):\n    id: int\n    name: str\n\n\n@get(\n    \"/resources\",\n    response_headers={\n        \"Random-Header\": ResponseHeader(\n            description=\"a random number in the range 100 - 1000\",\n            documentation_only=True,\n        )\n    },\n)\ndef retrieve_resource() -&gt; Response[Resource]:\n    return Response(\n        Resource(\n            id=1,\n            name=\"my resource\",\n        ),\n        headers={\"Random-Header\": str(randint(100, 1000))},\n    )\n\n\ndef after_request_handler(response: Response) -&gt; Response:\n    response.headers.update({\"Random-Header\": str(randint(1, 100))})\n    return response\n\n\nrouter = Router(\n    path=\"/router-path\",\n    route_handlers=[retrieve_resource],\n    after_request=after_request_handler,\n    response_headers={\n        \"Random-Header\": ResponseHeader(description=\"a random number in the range 1 - 100\", documentation_only=True)\n    },\n)\n\napp = Starlite(route_handlers=[router])\n</code></pre>"},{"location":"usage/5-responses/4-response-headers/#specific-headers-implementation","title":"Specific Headers Implementation","text":"<p>Starlite has a dedicated implementation for a few headers that are commonly used. These headers can be set separately with dedicated keyword arguments or as class attributes on all layers of the app (individual route handlers, controllers, routers and the app itself). Each layer overrides the layer above it - thus, the headers defined for a specific route handler will override those defined on its router, which will in turn override those defined on the app level.</p> <p>These header implementations allow easy creating, serialization and parsing according to the associated header specifications.</p>"},{"location":"usage/5-responses/4-response-headers/#cache-control","title":"Cache Control","text":"<p><code>CacheControlHeader</code> represents a <code>Cache-Control</code> Header.</p> <p>Here is a simple example that shows how to use it:</p> Cache Control Header<pre><code>import time\n\nfrom starlite import Controller, Starlite, get\nfrom starlite.datastructures import CacheControlHeader\n\n\nclass MyController(Controller):\n    cache_control = CacheControlHeader(max_age=86_400, public=True)\n\n    @get(\"/chance_of_rain\")\n    def get_chance_of_rain(self) -&gt; float:\n        \"\"\"This endpoint uses the cache control value defined in the controller which overrides the app value.\"\"\"\n        return 0.5\n\n    @get(\"/timestamp\", cache_control=CacheControlHeader(no_store=True))\n    def get_server_time(self) -&gt; float:\n        \"\"\"This endpoint overrides the cache control value defined in the controller.\"\"\"\n        return time.time()\n\n\n@get(\"/population\")\ndef get_population_count() -&gt; int:\n    \"\"\"This endpoint will use the cache control defined in the app.\"\"\"\n    return 100000\n\n\napp = Starlite(\n    route_handlers=[MyController, get_population_count],\n    cache_control=CacheControlHeader(max_age=2_628_288, public=True),\n)\n</code></pre> <p>In this example we have a <code>cache-control</code> with <code>max-age</code> of 1 month for the whole app, a <code>max-age</code> of 1 day for all routes within <code>MyController</code> and <code>no-store</code> for one specific route <code>get_server_time</code>. Here are the cache control values that will be returned from each endpoint:</p> <ul> <li>When calling <code>/population</code> the response will have <code>cache-control</code> with <code>max-age=2628288</code> (1 month).</li> <li>When calling <code>/chance_of_rain</code> the response will have <code>cache-control</code> with <code>max-age=86400</code> (1 day).</li> <li>When calling <code>/timestamp</code> the response will have <code>cache-control</code> with <code>no-store</code> which means don't store the result in any cache.</li> </ul>"},{"location":"usage/5-responses/4-response-headers/#etag","title":"ETag","text":"<p><code>ETag</code> represents an <code>ETag</code> header.</p> <p>Here are some usage examples:</p> Returning ETag headers<pre><code>import random\nimport time\n\nfrom starlite import Controller, Starlite, get\nfrom starlite.datastructures import ETag\nfrom starlite.enums import MediaType\nfrom starlite.response import Response\n\n\nclass MyController(Controller):\n    etag = ETag(value=\"foo\")\n\n    @get(\"/chance_of_rain\")\n    def get_chance_of_rain(self) -&gt; float:\n        \"\"\"This endpoint uses the etag value in the controller which overrides the app value.\n\n        The returned header will be `etag: \"foo\"`\n        \"\"\"\n        return 0.5\n\n    @get(\"/timestamp\", etag=ETag(value=\"bar\"))\n    def get_server_time(self) -&gt; float:\n        \"\"\"This endpoint overrides the etag defined in the controller.\n\n        The returned header will be `etag: W/\"bar\"`\n        \"\"\"\n        return time.time()\n\n\n@get(\"/population\")\ndef get_population_count() -&gt; int:\n    \"\"\"This endpoint will use the etag defined in the app.\n\n    The returned header will be `etag: \"bar\"`\n    \"\"\"\n    return 100000\n\n\n@get(\"/population-dynamic\", etag=ETag(documentation_only=True))\ndef get_population_count_dynamic() -&gt; Response[str]:\n    \"\"\"The etag defined in this route handler will not be returned, and does not need a value.\n\n    It will only be used for OpenAPI generation.\n    \"\"\"\n    population_count = random.randint(0, 1000)\n    return Response(\n        content=str(population_count),\n        headers={\"etag\": ETag(value=str(population_count))},\n        media_type=MediaType.TEXT,\n        status_code=200,\n    )\n\n\napp = Starlite(route_handlers=[MyController, get_population_count], etag=ETag(value=\"bar\"))\n</code></pre> Parsing ETag heaers<pre><code>from starlite.datastructures import ETag\n\nassert ETag.from_header('\"foo\"') == ETag(value=\"foo\")\nassert ETag.from_header('W/\"foo\"') == ETag(value=\"foo\", weak=True)\n</code></pre>"},{"location":"usage/5-responses/5-response-cookies/","title":"Response Cookies","text":"<p>Starlite allows you to define response cookies by using the <code>response_cookies</code> kwarg. This kwarg is available on all layers of the app - individual route handlers, controllers, routers and the app itself:</p> <pre><code>from starlite import Controller, MediaType, Router, Starlite, get\nfrom starlite.datastructures import Cookie\n\n\nclass MyController(Controller):\n    path = \"/controller-path\"\n    response_cookies = [\n        Cookie(\n            key=\"controller-cookie\",\n            value=\"controller value\",\n            description=\"controller level cookie\",\n        )\n    ]\n\n    @get(\n        path=\"/\",\n        response_cookies=[\n            Cookie(\n                key=\"local-cookie\",\n                value=\"local value\",\n                description=\"route handler level cookie\",\n            )\n        ],\n        media_type=MediaType.TEXT,\n    )\n    def my_route_handler(self) -&gt; str:\n        return \"hello world\"\n\n\nrouter = Router(\n    path=\"/router-path\",\n    route_handlers=[MyController],\n    response_cookies=[Cookie(key=\"router-cookie\", value=\"router value\", description=\"router level cookie\")],\n)\n\napp = Starlite(\n    route_handlers=[router],\n    response_cookies=[Cookie(key=\"app-cookie\", value=\"app value\", description=\"app level cookie\")],\n)\n</code></pre> <p>In the above example, the response returned by <code>my_route_handler</code> will have cookies set by each layer of the application. Cookies are set using the Set-Cookie header and with above resulting in:</p> <pre><code>Set-Cookie: local-cookie=local value; Path=/; SameSite=lax\nSet-Cookie: controller-cookie=controller value; Path=/; SameSite=lax\nSet-Cookie: router-cookie=router value; Path=/; SameSite=lax\nSet-Cookie: app-cookie=app value; Path=/; SameSite=lax\n</code></pre> <p>You can easily override cookies declared in higher levels by re-declaring a cookie with the same key in a lower level, e.g.:</p> <pre><code>from starlite import Controller, MediaType, Starlite, get\nfrom starlite.datastructures import Cookie\n\n\nclass MyController(Controller):\n    path = \"/controller-path\"\n    response_cookies = [Cookie(key=\"my-cookie\", value=\"123\")]\n\n    @get(\n        path=\"/\",\n        response_cookies=[Cookie(key=\"my-cookie\", value=\"456\")],\n        media_type=MediaType.TEXT,\n    )\n    def my_route_handler(self) -&gt; str:\n        return \"hello world\"\n\n\napp = Starlite(route_handlers=[MyController])\n</code></pre> <p>Of the two declarations of <code>my-cookie</code> only the route handler one will be used, because its lower level:</p> <pre><code>Set-Cookie: my-cookie=456; Path=/; SameSite=lax\n</code></pre>"},{"location":"usage/5-responses/5-response-cookies/#the-cookie-class","title":"The Cookie Class","text":"<p>Starlite exports the class <code>starlite.datastructures.Cookie</code>. This is a pydantic model that allows you to define a cookie. See the API Reference for full details on the <code>Cookie</code> class and the kwargs it accepts.</p>"},{"location":"usage/5-responses/5-response-cookies/#dynamic-cookies","title":"Dynamic Cookies","text":"<p>While the above scheme works great for static cookie values, it doesn't allow for dynamic cookies. Because cookies are fundamentally a type of response header, we can utilize the same patterns we use for setting dynamic headers also here.</p>"},{"location":"usage/5-responses/5-response-cookies/#setting-response-cookies-using-annotated-responses","title":"Setting Response Cookies Using Annotated Responses","text":"<p>We can simply return a response instance directly from the route handler and set the cookies list manually as you see fit, e.g.:</p> <pre><code>from random import randint\n\nfrom pydantic import BaseModel\n\nfrom starlite import Response, Starlite, get\nfrom starlite.datastructures import Cookie\n\n\nclass Resource(BaseModel):\n    id: int\n    name: str\n\n\n@get(\n    \"/resources\",\n    response_cookies=[\n        Cookie(\n            key=\"Random-Cookie\",\n            description=\"a random number in the range 1 - 100\",\n            documentation_only=True,\n        )\n    ],\n)\ndef retrieve_resource() -&gt; Response[Resource]:\n    return Response(\n        Resource(\n            id=1,\n            name=\"my resource\",\n        ),\n        cookies=[Cookie(key=\"Random-Cookie\", value=str(randint(1, 100)))],\n    )\n\n\napp = Starlite(route_handlers=[retrieve_resource])\n</code></pre> <p>In the above we use the <code>response_cookies</code> kwarg to pass the <code>key</code> and <code>description</code> parameters for the <code>Random-Header</code> to the OpenAPI documentation, but we set the value dynamically in as part of the annotated response we return. To this end we do not set a <code>value</code> for it and we designate it as <code>documentation_only=True</code>.</p>"},{"location":"usage/5-responses/5-response-cookies/#setting-response-cookies-using-the-after-request-hook","title":"Setting Response Cookies Using the After Request Hook","text":"<p>An alternative pattern would be to use an after request handler. We can define the handler on different layers of the application as explained in the pertinent docs. We should take care to document the cookies on the corresponding layer:</p> <pre><code>from random import randint\n\nfrom pydantic import BaseModel\n\nfrom starlite import Response, Router, Starlite, get\nfrom starlite.datastructures import Cookie\n\n\nclass Resource(BaseModel):\n    id: int\n    name: str\n\n\n@get(\"/resources\")\ndef retrieve_resource() -&gt; Resource:\n    return Resource(\n        id=1,\n        name=\"my resource\",\n    )\n\n\ndef after_request_handler(response: Response) -&gt; Response:\n    response.set_cookie(key=\"Random-Cookie\", value=str(randint(1, 100)))\n    return response\n\n\nrouter = Router(\n    path=\"/router-path\",\n    route_handlers=[retrieve_resource],\n    after_request=after_request_handler,\n    response_cookies=[\n        Cookie(\n            key=\"Random-Cookie\",\n            description=\"a random number in the range 1 - 100\",\n            documentation_only=True,\n        )\n    ],\n)\n\napp = Starlite(route_handlers=[router])\n</code></pre> <p>In the above we set the cookie using an <code>after_request_handler</code> function on the router level. Because the handler function is applied on the router, we also set the documentation for it on the router.</p> <p>We can use this pattern to fine-tune the OpenAPI documentation more granularly by overriding cookie specification as required. For example, lets say we have a router level cookie being set and a local cookie with the same key but a different value range:</p> <pre><code>from random import randint\n\nfrom pydantic import BaseModel\n\nfrom starlite import Response, Router, Starlite, get\nfrom starlite.datastructures import Cookie\n\n\nclass Resource(BaseModel):\n    id: int\n    name: str\n\n\n@get(\n    \"/resources\",\n    response_cookies=[\n        Cookie(\n            key=\"Random-Cookie\",\n            description=\"a random number in the range 100 - 1000\",\n            documentation_only=True,\n        )\n    ],\n)\ndef retrieve_resource() -&gt; Response[Resource]:\n    return Response(\n        Resource(\n            id=1,\n            name=\"my resource\",\n        ),\n        cookies=[Cookie(key=\"Random-Cookie\", value=str(randint(100, 1000)))],\n    )\n\n\ndef after_request_handler(response: Response) -&gt; Response:\n    response.set_cookie(key=\"Random-Cookie\", value=str(randint(1, 100)))\n    return response\n\n\nrouter = Router(\n    path=\"/router-path\",\n    route_handlers=[retrieve_resource],\n    after_request=after_request_handler,\n    response_cookies=[\n        Cookie(\n            key=\"Random-Cookie\",\n            description=\"a random number in the range 1 - 100\",\n            documentation_only=True,\n        )\n    ],\n)\n\napp = Starlite(route_handlers=[router])\n</code></pre>"},{"location":"usage/5-responses/6-redirect-responses/","title":"Redirect Responses","text":"<p>Redirect responses are special HTTP responses with a status code in the 30x range.</p> <p>In Starlite, a redirect response looks like this:</p> <pre><code>from starlite.status_codes import HTTP_307_TEMPORARY_REDIRECT\nfrom starlite import Redirect, get\n\n\n@get(path=\"/some-path\", status_code=HTTP_307_TEMPORARY_REDIRECT)\ndef redirect() -&gt; Redirect:\n    # do some stuff here\n    # ...\n    # finally return redirect\n    return Redirect(path=\"/other-path\")\n</code></pre> <p>To return a redirect response you should do the following:</p> <ol> <li>set an appropriate status code for the route handler (301, 302, 303, 307, 308)</li> <li>annotate the return value of the route handler as returning <code>Redirect</code></li> <li>return an instance of the <code>Redirect</code> class with the desired redirect path</li> </ol>"},{"location":"usage/5-responses/6-redirect-responses/#the-redirect-class","title":"The Redirect Class","text":"<p><code>Redirect</code> is a container class used to generate redirect responses and their respective OpenAPI documentation. See the API Reference for full details on the <code>Redirect</code> class and the kwargs it accepts.</p>"},{"location":"usage/5-responses/7-file-responses/","title":"File Responses","text":"<p>File responses send a file:</p> <pre><code>from pathlib import Path\nfrom starlite import File, get\n\n\n@get(path=\"/file-download\")\ndef handle_file_download() -&gt; File:\n    return File(\n        path=Path(Path(__file__).resolve().parent, \"report\").with_suffix(\".pdf\"),\n        filename=\"repost.pdf\",\n    )\n</code></pre> <p>The <code>File</code> class expects two kwargs:</p> <ul> <li><code>path</code>: path of the file to download.</li> <li><code>filename</code>: the filename to set in the   response Content-Disposition   attachment.</li> </ul>  <p>Important</p> <p>When a route handler's return value is annotated with <code>File</code>, the default <code>media_type</code> for the route_handler is switched from <code>MediaType.JSON</code> to <code>MediaType.TEXT</code> (i.e. \"text/plain\"). If the file being sent has an IANA media type, you should set it as the value for <code>media_type</code> instead.</p>  <p>For example:</p> <pre><code>from pathlib import Path\nfrom starlite import File, get\n\n\n@get(path=\"/file-download\", media_type=\"application/pdf\")\ndef handle_file_download() -&gt; File:\n    return File(\n        path=Path(Path(__file__).resolve().parent, \"report\").with_suffix(\".pdf\"),\n        filename=\"repost.pdf\",\n    )\n</code></pre>"},{"location":"usage/5-responses/7-file-responses/#the-file-class","title":"The File Class","text":"<p><code>File</code> is a container class used to generate file responses and their respective OpenAPI documentation. See the API Reference for full details on the <code>File</code> class and the kwargs it accepts.</p>"},{"location":"usage/5-responses/8-streaming-responses/","title":"Streaming Responses","text":"<p>To return a streaming response use the <code>Stream</code> class. The Stream class receives a single required kwarg - <code>iterator</code>:</p> Python 3.8+Python 3.9+   <pre><code>from asyncio import sleep\nfrom datetime import datetime\nfrom typing import AsyncGenerator\n\nfrom starlite import Starlite, Stream, get\nfrom starlite.utils.serialization import encode_json\n\n\nasync def my_generator() -&gt; AsyncGenerator[bytes, None]:\n    while True:\n        await sleep(0.01)\n        yield encode_json({\"current_time\": datetime.now()})\n\n\n@get(path=\"/time\")\ndef stream_time() -&gt; Stream:\n    return Stream(iterator=my_generator())\n\n\napp = Starlite(route_handlers=[stream_time])\n</code></pre>   <pre><code>from asyncio import sleep\nfrom datetime import datetime\nfrom collections.abc import AsyncGenerator\n\nfrom starlite import Starlite, Stream, get\nfrom starlite.utils.serialization import encode_json\n\n\nasync def my_generator() -&gt; AsyncGenerator[bytes, None]:\n    while True:\n        await sleep(0.01)\n        yield encode_json({\"current_time\": datetime.now()})\n\n\n@get(path=\"/time\")\ndef stream_time() -&gt; Stream:\n    return Stream(iterator=my_generator())\n\n\napp = Starlite(route_handlers=[stream_time])\n</code></pre>     <p>Note</p> <p>You can use different kinds of values of the <code>iterator</code> keyword - it can be a callable returning a sync or async generator. The generator itself. A sync or async iterator class, or and instance of this class.</p>"},{"location":"usage/5-responses/8-streaming-responses/#the-stream-class","title":"The Stream Class","text":"<p><code>Stream</code> is a container class used to generate streaming responses and their respective OpenAPI documentation. See the API Reference for full details on the <code>Stream</code> class and the kwargs it accepts.</p>"},{"location":"usage/5-responses/9-template-responses/","title":"Template Responses","text":"<p>Template responses are used to render templates into HTML. To use a template response you must first register a template engine on the application level. Once an engine is in place, you can use a template response like so:</p> <pre><code>from starlite import Template, Request, get\n\n\n@get(path=\"/info\")\ndef info(request: Request) -&gt; Template:\n    return Template(name=\"info.html\", context={\"user\": request.user})\n</code></pre> <p>In the above <code>Template</code> is passed the template name, which is a path like value, and a context dictionary that maps string keys into values that will be rendered in the template.</p>"},{"location":"usage/5-responses/9-template-responses/#the-template-class","title":"The Template Class","text":"<p><code>Template</code> is a container class used to generate template responses and their respective OpenAPI documentation. See the API Reference for full details on the <code>Template</code> class and the kwargs it accepts.</p>"},{"location":"usage/6-dependency-injection/0-dependency-injection-intro/","title":"Dependency Injection","text":"<p>Starlite has a simple but powerful dependency injection system that allows for declaring dependencies on all layers of the application:</p> <pre><code>from starlite import Controller, Router, Starlite, Provide, get\n\n\ndef bool_fn() -&gt; bool:\n    ...\n\n\ndef dict_fn() -&gt; dict:\n    ...\n\n\ndef list_fn() -&gt; list:\n    ...\n\n\ndef int_fn() -&gt; int:\n    ...\n\n\nclass MyController(Controller):\n    path = \"/controller\"\n    # on the controller\n    dependencies = {\"controller_dependency\": Provide(list_fn)}\n\n    # on the route handler\n    @get(path=\"/handler\", dependencies={\"local_dependency\": Provide(int_fn)})\n    def my_route_handler(\n        self,\n        app_dependency: bool,\n        router_dependency: dict,\n        controller_dependency: list,\n        local_dependency: int,\n    ) -&gt; None:\n        ...\n\n    # on the router\n\n\nmy_router = Router(\n    path=\"/router\",\n    dependencies={\"router_dependency\": Provide(dict_fn)},\n    route_handlers=[MyController],\n)\n\n# on the app\napp = Starlite(\n    route_handlers=[my_router], dependencies={\"app_dependency\": Provide(bool_fn)}\n)\n</code></pre> <p>The above example illustrates how dependencies are declared on the different layers of the application.</p> <p>Dependencies are callables - sync or async functions, methods or class instances that implement the <code>__call__</code> method - that are wrapped inside an instance of the <code>Provide</code> class.</p>"},{"location":"usage/6-dependency-injection/0-dependency-injection-intro/#pre-requisites-and-scope","title":"Pre-requisites and Scope","text":"<p>The pre-requisites for dependency injection are these:</p> <ol> <li>dependencies must be callables.</li> <li>dependencies can receive kwargs and a <code>self</code> arg but not positional args.</li> <li>the kwarg name and the dependency key must be identical.</li> <li>the dependency must be declared using the <code>Provide</code> class.</li> <li>the dependency must be in the scope of the handler function.</li> </ol> <p>What is scope in this context? Dependencies are isolated to the context in which they are declared. Thus, in the above example, the <code>local_dependency</code> can only be accessed within the specific route handler on which it was declared; The <code>controller_dependency</code> is available only for route handlers on that specific controller; And the router dependencies are available only to the route handlers registered on that particular router. Only the <code>app_dependencies</code> are available to all route handlers.</p>"},{"location":"usage/6-dependency-injection/0-dependency-injection-intro/#dependencies-with-yield-cleanup-step","title":"Dependencies with yield (cleanup step)","text":"<p>In addition to simple callables, dependencies can also be (async) generator functions, which allows to execute an additional cleanup step, such as closing a connection, after the handler function has returned.</p>  <p>Technical details</p> <p>The cleanup stage is executed after the handler function returns, but before the response is sent (in case of HTTP requests)</p>"},{"location":"usage/6-dependency-injection/0-dependency-injection-intro/#a-basic-example","title":"A basic example","text":"Python 3.8+Python 3.9+   dependencies.py<pre><code>from typing import Dict, Generator\n\nfrom starlite import Provide, Starlite, get\n\nCONNECTION = {\"open\": False}\n\n\ndef generator_function() -&gt; Generator[Dict[str, bool], None, None]:\n    \"\"\"Set connection to open and close it after the handler returns.\"\"\"\n    CONNECTION[\"open\"] = True\n    yield CONNECTION\n    CONNECTION[\"open\"] = False\n\n\n@get(\"/\", dependencies={\"conn\": Provide(generator_function)})\ndef index(conn: Dict[str, bool]) -&gt; Dict[str, bool]:\n    \"\"\"Return the current connection state.\"\"\"\n    return conn\n\n\napp = Starlite(route_handlers=[index])\n</code></pre>   dependencies.py<pre><code>from collections.abc import Generator\n\nfrom starlite import Provide, Starlite, get\n\nCONNECTION = {\"open\": False}\n\n\ndef generator_function() -&gt; Generator[dict[str, bool], None, None]:\n    \"\"\"Set connection to open and close it after the handler returns.\"\"\"\n    CONNECTION[\"open\"] = True\n    yield CONNECTION\n    CONNECTION[\"open\"] = False\n\n\n@get(\"/\", dependencies={\"conn\": Provide(generator_function)})\ndef index(conn: dict[str, bool]) -&gt; dict[str, bool]:\n    \"\"\"Return the current connection state.\"\"\"\n    return conn\n\n\napp = Starlite(route_handlers=[index])\n</code></pre>    <p>If you run the code you'll see that <code>CONNECTION</code> has been reset after the handler function returned:</p> <pre><code>from starlite import TestClient\nfrom dependencies import app, CONNECTION\n\nwith TestClient(app=app) as client:\n    print(client.get(\"/\").json())  # {\"open\": True}\n    print(CONNECTION)  # {\"open\": False}\n</code></pre>"},{"location":"usage/6-dependency-injection/0-dependency-injection-intro/#handling-exceptions","title":"Handling exceptions","text":"<p>If an exception occurs within the handler function, it will be raised within the generator, at the point where it first <code>yield</code>ed. This makes it possible to adapt behaviour of the dependency based on exceptions, for example rolling back a database session on error and committing otherwise.</p> Python 3.8+Python 3.9+   dependencies.py<pre><code>from typing import Dict, Generator\n\nfrom starlite import Provide, Starlite, get\n\nSTATE = {\"result\": None, \"connection\": \"closed\"}\n\n\ndef generator_function() -&gt; Generator[str, None, None]:\n    \"\"\"Set the connection state to open and close it after the handler returns.\n\n    If an error occurs, set `result` to `\"error\"`, else set it to `\"OK\"`.\n    \"\"\"\n    try:\n        STATE[\"connection\"] = \"open\"\n        yield \"hello\"\n        STATE[\"result\"] = \"OK\"\n    except ValueError:\n        STATE[\"result\"] = \"error\"\n    finally:\n        STATE[\"connection\"] = \"closed\"\n\n\n@get(\"/{name:str}\", dependencies={\"message\": Provide(generator_function)})\ndef index(name: str, message: str) -&gt; Dict[str, str]:\n    \"\"\"If `name` is \"John\", return a message, otherwise raise an error.\"\"\"\n    if name == \"John\":\n        return {name: message}\n    raise ValueError()\n\n\napp = Starlite(route_handlers=[index])\n</code></pre>   dependencies.py<pre><code>from collections.abc import Generator\n\nfrom starlite import Provide, Starlite, get\n\nSTATE = {\"result\": None, \"connection\": \"closed\"}\n\n\ndef generator_function() -&gt; Generator[str, None, None]:\n    \"\"\"Set the connection state to open and close it after the handler returns.\n\n    If an error occurs, set `result` to `\"error\"`, else set it to `\"OK\"`.\n    \"\"\"\n    try:\n        STATE[\"connection\"] = \"open\"\n        yield \"hello\"\n        STATE[\"result\"] = \"OK\"\n    except ValueError:\n        STATE[\"result\"] = \"error\"\n    finally:\n        STATE[\"connection\"] = \"closed\"\n\n\n@get(\"/{name:str}\", dependencies={\"message\": Provide(generator_function)})\ndef index(name: str, message: str) -&gt; dict[str, str]:\n    \"\"\"If `name` is \"John\", return a message, otherwise raise an error.\"\"\"\n    if name == \"John\":\n        return {name: message}\n    raise ValueError()\n\n\napp = Starlite(route_handlers=[index])\n</code></pre>    <pre><code>from starlite import TestClient\nfrom dependencies import STATE, app\n\nwith TestClient(app=app) as client:\n    response = client.get(\"/John\")\n    print(response.json())  # {\"John\": \"hello\"}\n    print(STATE)  # {\"result\": \"OK\", \"connection\": \"closed\"}\n\n    response = client.get(\"/Peter\")\n    print(response.status_code)  # 500\n    print(STATE)  # {\"result\": \"error\", \"connection\": \"closed\"}\n</code></pre>  <p>Best Practice</p> <p>You should always wrap <code>yield</code> in a <code>try</code>/<code>finally</code> block, regardless of whether you want to handle exceptions, to ensure that the cleanup code is run even when exceptions occurred:</p> <pre><code>def generator_dependency():\n    try:\n        yield\n    finally:\n        ...  # cleanup code\n</code></pre>   <p>Important</p> <p>Do not re-raise exceptions within the dependency. Exceptions caught within these dependencies will still be handled by the regular mechanisms without an explicit re-raise</p>"},{"location":"usage/6-dependency-injection/1-dependency-kwargs/","title":"Dependency Kwargs","text":"<p>As stated above dependencies can receive kwargs but no args. The reason for this is that dependencies are parsed using the same mechanism that parses route handler functions, and they too - like route handler functions, can have data injected into them.</p> <p>In fact, you can inject the same data that you can inject into route handlers.</p> <pre><code>from starlite import Controller, Provide, patch\nfrom starlite.types.partial import Partial\nfrom pydantic import BaseModel, UUID4\n\n\nclass User(BaseModel):\n    id: UUID4\n    name: str\n\n\nasync def retrieve_db_user(user_id: UUID4) -&gt; User:\n    ...\n\n\nclass UserController(Controller):\n    path = \"/user\"\n    dependencies = {\"user\": Provide(retrieve_db_user)}\n\n    @patch(path=\"/{user_id:uuid}\")\n    async def update_user(self, data: Partial[User], user: User) -&gt; User:\n        ...\n</code></pre> <p>In the above example we have a <code>User</code> model that we are persisting into a db. The model is fetched using the helper method <code>retrieve_db_user</code> which receives a <code>user_id</code> kwarg and retrieves the corresponding <code>User</code> instance. The <code>UserController</code> class maps the <code>retrieve_db_user</code> provider to the key <code>user</code> in its <code>dependencies</code> dictionary. This in turn makes it available as a kwarg in the <code>update_user</code> method.</p>"},{"location":"usage/6-dependency-injection/2-overriding-dependencies/","title":"Overriding Dependencies","text":"<p>Because dependencies are declared at each level of the app using a string keyed dictionary, overriding dependencies is very simple:</p> <pre><code>from starlite import Controller, Provide, get\n\n\ndef bool_fn() -&gt; bool:\n    ...\n\n\ndef dict_fn() -&gt; dict:\n    ...\n\n\nclass MyController(Controller):\n    path = \"/controller\"\n    # on the controller\n    dependencies = {\"some_dependency\": Provide(dict_fn)}\n\n    # on the route handler\n    @get(path=\"/handler\", dependencies={\"some_dependency\": Provide(bool_fn)})\n    def my_route_handler(\n        self,\n        some_dependency: bool,\n    ) -&gt; None:\n        ...\n</code></pre> <p>The lower scoped route handler function declares a dependency with the same key as the one declared on the higher scoped controller. The lower scoped dependency therefore overrides the higher scoped one.</p>"},{"location":"usage/6-dependency-injection/3-the-provide-class/","title":"The Provide Class","text":"<p>The <code>Provide</code> class is a wrapper used for dependency injection. To inject a callable you must wrap it in <code>Provide</code>:</p> <pre><code>from starlite import Provide, get\nfrom random import randint\n\n\ndef my_dependency() -&gt; int:\n    return randint(1, 10)\n\n\n@get(\n    \"/some-path\",\n    dependencies={\n        \"my_dep\": Provide(\n            my_dependency,\n        )\n    },\n)\ndef my_handler(my_dep: int) -&gt; None:\n    ...\n</code></pre> <p>See the API Reference for full details on the <code>Provide</code> class and the kwargs it accepts.</p>  <p>Important</p> <p>If <code>Provide.use_cache</code> is true, the return value of the function will be memoized the first time it is called and then will be used. There is no sophisticated comparison of kwargs, LRU implementation etc. so you should be careful when you choose to use this option. Note that dependencies will only be called once per request, even with <code>Provide.use_cache</code> set to false.</p>"},{"location":"usage/6-dependency-injection/4-dependencies-in-dependencies/","title":"Using Dependencies in Dependencies","text":"<p>You can inject dependencies into other dependencies - exactly like you would into regular functions.</p> <pre><code>from starlite import Starlite, Provide, get\nfrom random import randint\n\n\ndef first_dependency() -&gt; int:\n    return randint(1, 10)\n\n\ndef second_dependency(injected_integer: int) -&gt; bool:\n    return injected_integer % 2 == 0\n\n\n@get(\"/true-or-false\")\ndef true_or_false_handler(injected_bool: bool) -&gt; str:\n    return \"its true!\" if injected_bool else \"nope, its false...\"\n\n\napp = Starlite(\n    route_handlers=[true_or_false_handler],\n    dependencies={\n        \"injected_integer\": Provide(first_dependency),\n        \"injected_bool\": Provide(second_dependency),\n    },\n)\n</code></pre>  <p>Note</p> <p>The same rules for overriding dependencies apply here as well.</p>"},{"location":"usage/6-dependency-injection/5-the-dependency-function/","title":"The Dependency Function","text":""},{"location":"usage/6-dependency-injection/5-the-dependency-function/#dependency-validation","title":"Dependency validation","text":"<p>By default, injected dependency values are validated by Starlite, for example, this application will raise an internal server error:</p> Dependency validation error<pre><code>from typing import Any\n\nfrom starlite import Provide, Starlite, get\n\n\ndef provide_str() -&gt; str:\n    \"\"\"Returns a string.\"\"\"\n    return \"whoops\"\n\n\n@get(\"/\", dependencies={\"injected\": Provide(provide_str)})\ndef hello_world(injected: int) -&gt; dict[str, Any]:\n    \"\"\"Handler expects and `int`, but we've provided a `str`.\"\"\"\n    return {\"hello\": injected}\n\n\napp = Starlite(route_handlers=[hello_world])\n</code></pre> <p>Dependency validation can be toggled using the <code>Dependency</code> function.</p> Dependency validation error<pre><code>from typing import Any\n\nfrom starlite import Dependency, Provide, Starlite, get\n\n\ndef provide_str() -&gt; str:\n    \"\"\"Returns a string.\"\"\"\n    return \"whoops\"\n\n\n@get(\"/\", dependencies={\"injected\": Provide(provide_str)})\ndef hello_world(injected: int = Dependency(skip_validation=True)) -&gt; dict[str, Any]:\n    \"\"\"Handler expects an `int`, but we've provided a `str`.\"\"\"\n    return {\"hello\": injected}\n\n\napp = Starlite(route_handlers=[hello_world])\n</code></pre> <p>This may be useful for reasons of efficiency, or if pydantic cannot validate a certain type, but use with caution!</p>"},{"location":"usage/6-dependency-injection/5-the-dependency-function/#dependency-function-as-a-marker","title":"Dependency function as a marker","text":"<p>The <code>Dependency</code> function can also be used as a marker that gives us a bit more detail about your application.</p>"},{"location":"usage/6-dependency-injection/5-the-dependency-function/#exclude-dependencies-with-default-values-from-openapi-docs","title":"Exclude dependencies with default values from OpenAPI docs","text":"<p>Depending on your application design, it is possible to have a dependency declared in a handler or <code>Provide</code> function that has a default value. If the dependency isn't provided for the route, the default should be used by the function.</p> Dependency with default value<pre><code>from typing import Any\n\nfrom starlite import Starlite, get\n\n\n@get(\"/\")\ndef hello_world(optional_dependency: int = 3) -&gt; dict[str, Any]:\n    \"\"\"Notice we haven't provided the dependency to the route.\n\n    This is OK, because of the default value, but the parameter shows in the docs.\n    \"\"\"\n    return {\"hello\": optional_dependency}\n\n\napp = Starlite(route_handlers=[hello_world])\n</code></pre> <p>This doesn't fail, but due to the way the application determines parameter types, this is inferred to be a query parameter:</p>  <p>By declaring the parameter to be a dependency, Starlite knows to exclude it from the docs:</p> Dependency with default value<pre><code>from typing import Any\n\nfrom starlite import Dependency, Starlite, get\n\n\n@get(\"/\")\ndef hello_world(optional_dependency: int = Dependency(default=3)) -&gt; dict[str, Any]:\n    \"\"\"Notice we haven't provided the dependency to the route.\n\n    This is OK, because of the default value, and now the parameter is excluded from the docs.\n    \"\"\"\n    return {\"hello\": optional_dependency}\n\n\napp = Starlite(route_handlers=[hello_world])\n</code></pre>"},{"location":"usage/6-dependency-injection/5-the-dependency-function/#early-detection-if-a-dependency-isnt-provided","title":"Early detection if a dependency isn't provided","text":"<p>The other side of the same coin is when a dependency isn't provided, and no default is specified. Without the dependency marker, the parameter is assumed to be a query parameter and the route will most likely fail when accessed.</p> <p>If the parameter is marked as a dependency, this allows us to fail early instead:</p> Dependency not provided error<pre><code>from typing import Any\n\nfrom starlite import Dependency, get\n\n\n@get(\"/\")\ndef hello_world(non_optional_dependency: int = Dependency()) -&gt; dict[str, Any]:\n    \"\"\"Notice we haven't provided the dependency to the route.\n\n    This is not great, however by explicitly marking dependencies, Starlite won't let the app start.\n    \"\"\"\n    return {\"hello\": non_optional_dependency}\n\n\n# app = Starlite(route_handlers=[hello_world])\n\n# ImproperlyConfiguredException: 500: Explicit dependency 'non_optional_dependency' for 'hello_world' has no default\n# value, or provided dependency.\n</code></pre>"},{"location":"usage/7-middleware/builtin-middlewares/","title":"Built-in middlewares","text":""},{"location":"usage/7-middleware/builtin-middlewares/#cors","title":"CORS","text":"<p>CORS (Cross-Origin Resource Sharing) is a common security mechanism that is often implemented using middleware. To enable CORS in a starlite application simply pass an instance of <code>CORSConfig</code> to the Starlite constructor:</p> <pre><code>from starlite import CORSConfig, Starlite\n\ncors_config = CORSConfig(allow_origins=[\"https://www.example.com\"])\n\napp = Starlite(route_handlers=[...], cors_config=cors_config)\n</code></pre> <p>See the API Reference for full details on the <code>CORSConfig</code> class and the kwargs it accepts.</p>"},{"location":"usage/7-middleware/builtin-middlewares/#allowed-hosts","title":"Allowed Hosts","text":"<p>Another common security mechanism is to require that each incoming request has a \"Host\" or \"X-Forwarded-Host\" header, and then to restrict hosts to a specific set of domains - what's called \"allowed hosts\".</p> <p>Starlite includes an <code>AllowedHostsMiddleware</code> class that can be easily enabled by either passing an instance of AllowedHostsConfig or a list of domains to the Starlite constructor:</p> <pre><code>from starlite import Starlite, AllowedHostsConfig\n\napp = Starlite(\n    route_handlers=[...],\n    allowed_hosts=AllowedHostsConfig(\n        allowed_hosts=[\"*.example.com\", \"www.wikipedia.org\"]\n    ),\n)\n</code></pre>  <p>Note</p> <p>You can use wildcard prefixes (<code>*.</code>) in the beginning of a domain to match any combination of subdomains. Thus, <code>*.example.com</code> will match <code>www.example.com</code> but also <code>x.y.z.example.com</code> etc. You can also simply put <code>*</code> in trusted hosts, which means allow all. This is akin to turning the middleware off, so in this case it may be better to not enable it in the first place. You should note that a wildcard can only be used only in the prefix of a domain name, not in the middle or end. Doing so will result in a validation exception being raised.</p>  <p>For further configuration options, consult the config reference documentation.</p>"},{"location":"usage/7-middleware/builtin-middlewares/#compression","title":"Compression","text":"<p>HTML responses can optionally be compressed. Starlite has built in support for gzip and brotli. Gzip support is provided through the built-in Starlette classes, and brotli support can be added by installing the <code>brotli</code> extras.</p> <p>You can enable either backend by passing an instance of <code>CompressionConfig</code> into the <code>compression_config</code> the Starlite constructor.</p>"},{"location":"usage/7-middleware/builtin-middlewares/#gzip","title":"GZIP","text":"<p>You can enable gzip compression of responses by passing an instance of <code>starlite.config.CompressionConfig</code> with the <code>backend</code> parameter set to <code>\"gzip\"</code>.</p> <p>You can configure the following additional gzip-specific values:</p> <ul> <li><code>minimum_size</code>: the minimum threshold for response size to enable compression. Smaller responses will not be compressed. Defaults is <code>500</code>, i.e. half a kilobyte.</li> <li><code>gzip_compress_level</code>: a range between 0-9, see the official python docs. Defaults to <code>9</code>, which is the maximum value.</li> </ul> <pre><code>from starlite import Starlite, CompressionConfig\n\napp = Starlite(\n    route_handlers=[...],\n    compression_config=CompressionConfig(backend=\"gzip\", gzip_compress_level=9),\n)\n</code></pre>"},{"location":"usage/7-middleware/builtin-middlewares/#brotli","title":"Brotli","text":"<p>The Brotli package is required to run this middleware. It is available as an extras to starlite with the <code>brotli</code> extra (<code>pip install starlite[brotli]</code>).</p> <p>You can enable brotli compression of responses by passing an instance of <code>starlite.config.CompressionConfig</code> with the <code>backend</code> parameter set to <code>\"brotli\"</code>.</p> <p>You can configure the following additional brotli-specific values:</p> <ul> <li><code>minimum_size</code>: the minimum threshold for response size to enable compression. Smaller responses will not be compressed. Defaults is <code>500</code>, i.e. half a kilobyte.</li> <li><code>brotli_quality</code>: Range [0-11], Controls the compression-speed vs compression-density tradeoff. The higher the quality, the slower the compression.</li> <li><code>brotli_mode</code>: The compression mode can be MODE_GENERIC (default), MODE_TEXT (for UTF-8 format text input) or MODE_FONT (for WOFF 2.0).</li> <li><code>brotli_lgwin</code>: Base 2 logarithm of size. Range is 10 to 24. Defaults to 22.</li> <li><code>brotli_lgblock</code>: Base 2 logarithm of the maximum input block size. Range is 16 to 24. If set to 0, the value will be set based on the quality. Defaults to 0.</li> <li><code>brotli_gzip_fallback</code>: a boolean to indicate if gzip should be used if brotli is not supported.</li> </ul> <pre><code>from starlite import Starlite\nfrom starlite.config import CompressionConfig\n\napp = Starlite(\n    route_handlers=[...],\n    compression_config=CompressionConfig(backend=\"brotli\", brotli_gzip_fallback=True),\n)\n</code></pre>"},{"location":"usage/7-middleware/builtin-middlewares/#rate-limit-middleware","title":"Rate-Limit Middleware","text":"<p>Starlite includes an optional <code>RateLimitMiddleware</code> that follows the IETF RateLimit draft specification.</p> <p>To use the rate limit middleware, use the <code>RateLimitConfig</code>:</p> <pre><code>from starlite import MediaType, Starlite, get\nfrom starlite.middleware import RateLimitConfig\n\nrate_limit_config = RateLimitConfig(rate_limit=(\"minute\", 1), exclude=[\"/schema\"])\n\n\n@get(\"/\", media_type=MediaType.TEXT)\ndef handler() -&gt; str:\n    \"\"\"Handler which should not be accessed more than once per minute.\"\"\"\n    return \"ok\"\n\n\napp = Starlite(route_handlers=[handler], middleware=[rate_limit_config.middleware])\n</code></pre> <p>The only required configuration kwarg is <code>rate_limit</code>, which expects a tuple containing a time-unit (<code>second</code>, <code>minute</code> , <code>hour</code>, <code>day</code>) and a value for the request quota (integer). For the other configuration options, see the additional configuration options in the reference.</p>"},{"location":"usage/7-middleware/builtin-middlewares/#logging-middleware","title":"Logging Middleware","text":"<p>Starlite ships with a robust logging middleware that allows logging HTTP request and responses while building on the app level logging configuration:</p> Python 3.8+Python 3.9+   <pre><code>from typing import Dict\n\nfrom starlite import LoggingConfig, Starlite, get\nfrom starlite.middleware import LoggingMiddlewareConfig\n\nlogging_middleware_config = LoggingMiddlewareConfig()\n\n\n@get(\"/\")\ndef my_handler() -&gt; Dict[str, str]:\n    return {\"hello\": \"world\"}\n\n\napp = Starlite(\n    route_handlers=[my_handler],\n    logging_config=LoggingConfig(),\n    middleware=[logging_middleware_config.middleware],\n)\n</code></pre>   <pre><code>from starlite import LoggingConfig, Starlite, get\nfrom starlite.middleware import LoggingMiddlewareConfig\n\nlogging_middleware_config = LoggingMiddlewareConfig()\n\n\n@get(\"/\")\ndef my_handler() -&gt; dict[str, str]:\n    return {\"hello\": \"world\"}\n\n\napp = Starlite(\n    route_handlers=[my_handler],\n    logging_config=LoggingConfig(),\n    middleware=[logging_middleware_config.middleware],\n)\n</code></pre>    <p>The logging middleware uses the logger configuration defined on the application level, which allows for using both stdlib logging or structlog, depending on the configuration used ( see logging for more details).</p>"},{"location":"usage/7-middleware/builtin-middlewares/#obfuscating-logging-output","title":"Obfuscating Logging Output","text":"<p>Sometimes certain data, e.g. request or response headers, needs to be obfuscated. This is supported by the middleware configuration:</p> <pre><code>from starlite.middleware import LoggingMiddlewareConfig\n\nlogging_middleware_config = LoggingMiddlewareConfig(\n    request_cookies_to_obfuscate={\"my-custom-session-key\"},\n    response_cookies_to_obfuscate={\"my-custom-session-key\"},\n    request_headers_to_obfuscate={\"my-custom-header\"},\n    response_headers_to_obfuscate={\"my-custom-header\"},\n)\n</code></pre> <p>The middleware will obfuscate the headers <code>Authorization</code> and <code>X-API-KEY</code>, and the cookie <code>session</code> by default.</p> <p>You can read more about the configuration options in the api reference</p>"},{"location":"usage/7-middleware/builtin-middlewares/#compression-and-logging-of-response-body","title":"Compression and Logging of Response Body","text":"<p>If both <code>CompressionConfig</code> and <code>LoggingMiddleware</code> have been defined for the application, the response body will be omitted from response logging if it has been compressed, even if <code>\"body\"</code> has been included in <code>response_log_fields</code>. To force the body of compressed responses to be logged, set <code>include_compressed_body</code> to <code>True</code>, in addition to including <code>\"body\"</code> in <code>response_log_fields</code>.</p>"},{"location":"usage/7-middleware/builtin-middlewares/#session-middleware","title":"Session Middleware","text":"<p>Starlite includes a SessionMiddleware, offering client- and server-side sessions. Different storage mechanisms are available through SessionBackends, and include support for storing data in:</p> <ul> <li>Cookies</li> <li>Files</li> <li>Redis</li> <li>Memcached (through <code>aiomcache</code>)</li> <li>Databases (through <code>sqlalchemy</code>)</li> <li>Memory</li> </ul>  <p>Info</p> <p>The Starlite's <code>SesionMiddleware</code> is not based on the Starlette SessionMiddleware, although it is compatible with it, and it can act as a drop-in replacement.</p>"},{"location":"usage/7-middleware/builtin-middlewares/#setting-up-the-middleware","title":"Setting up the middleware","text":"<p>To start using sessions in your application all you have to do is create an instance of a configuration object and add its middleware to your application's middleware stack:</p> Python 3.8+Python 3.9+   Hello World<pre><code>from os import urandom\nfrom typing import Dict\n\nfrom starlite import Request, Starlite, delete, get, post\nfrom starlite.middleware.session.cookie_backend import CookieBackendConfig\n\n# we initialize to config with a 16 byte key, i.e. 128 a bit key.\n# in real world usage we should inject the secret from the environment\nsession_config = CookieBackendConfig(secret=urandom(16))  # type: ignore[arg-type]\n\n\n@get(\"/session\")\ndef check_session_handler(request: Request) -&gt; Dict[str, bool]:\n    \"\"\"Handler function that accesses request.session.\"\"\"\n    return {\"has_session\": request.session != {}}\n\n\n@post(\"/session\")\ndef create_session_handler(request: Request) -&gt; None:\n    \"\"\"Handler to set the session.\"\"\"\n    if not request.session:\n        # value can be a dictionary or pydantic model\n        request.set_session({\"username\": \"moishezuchmir\"})\n\n\n@delete(\"/session\")\ndef delete_session_handler(request: Request) -&gt; None:\n    \"\"\"Handler to clear the session.\"\"\"\n    if request.session:\n        request.clear_session()\n\n\napp = Starlite(\n    route_handlers=[check_session_handler, create_session_handler, delete_session_handler],\n    middleware=[session_config.middleware],\n)\n</code></pre>   Hello World<pre><code>from os import urandom\n\nfrom starlite import Request, Starlite, delete, get, post\nfrom starlite.middleware.session.cookie_backend import CookieBackendConfig\n\n# we initialize to config with a 16 byte key, i.e. 128 a bit key.\n# in real world usage we should inject the secret from the environment\nsession_config = CookieBackendConfig(secret=urandom(16))  # type: ignore[arg-type]\n\n\n@get(\"/session\")\ndef check_session_handler(request: Request) -&gt; dict[str, bool]:\n    \"\"\"Handler function that accesses request.session.\"\"\"\n    return {\"has_session\": request.session != {}}\n\n\n@post(\"/session\")\ndef create_session_handler(request: Request) -&gt; None:\n    \"\"\"Handler to set the session.\"\"\"\n    if not request.session:\n        # value can be a dictionary or pydantic model\n        request.set_session({\"username\": \"moishezuchmir\"})\n\n\n@delete(\"/session\")\ndef delete_session_handler(request: Request) -&gt; None:\n    \"\"\"Handler to clear the session.\"\"\"\n    if request.session:\n        request.clear_session()\n\n\napp = Starlite(\n    route_handlers=[check_session_handler, create_session_handler, delete_session_handler],\n    middleware=[session_config.middleware],\n)\n</code></pre>     <p>Note</p> <p>Since both client- and server-side sessions rely on cookies (one for storing the actual session data, the other for storing the session ID), they share most of the cookie configuration. A complete reference of the cookie configuration can be found at BaseBackendConfig.</p>"},{"location":"usage/7-middleware/builtin-middlewares/#client-side-sessions","title":"Client-side sessions","text":"<p>Client side sessions are available through the CookieBackend, which offers strong AES-CGM encryption security best practices while support cookie splitting.</p>  <p>Important</p> <p><code>CookieBackend</code> requires the cryptography library, which can be installed together with starlite as an extra using <code>pip install starlite[cryptography]</code></p>  cookie_backend.py<pre><code>from os import urandom\n\nfrom starlite import Starlite\nfrom starlite.middleware.session.cookie_backend import CookieBackendConfig\n\nsession_config = CookieBackendConfig(secret=urandom(16))  # type: ignore[arg-type]\n\napp = Starlite(route_handlers=[], middleware=[session_config.middleware])\n</code></pre>  <p>See also</p> <p>CookieBackendConfig</p>"},{"location":"usage/7-middleware/builtin-middlewares/#server-side-sessions","title":"Server-side sessions","text":"<p>Server side session store data - as the name suggests - on the server instead of the client. They use a cookie containing a session ID which is a randomly generated string to identify a client and load the appropriate data from the storage backend.</p>"},{"location":"usage/7-middleware/builtin-middlewares/#file-storage","title":"File storage","text":"<p>The FileBackend will store session data in files on disk, alongside some metadata. Files containing expired sessions will only be deleted when trying to access them. Expired session files can be manually deleted using the delete_expired method.</p> file_backend.py<pre><code>from pathlib import Path\n\nfrom starlite import Starlite\nfrom starlite.middleware.session.file_backend import FileBackendConfig\n\nsession_config = FileBackendConfig(storage_path=Path(\"/path/to/session/storage\"))\n\napp = Starlite(route_handlers=[], middleware=[session_config.middleware])\n</code></pre>  <p>See also</p> <ul> <li>Accessing the storage backend directly</li> <li>BaseBackendConfig</li> <li>ServerSideSessionConfig</li> <li>FileBackendConfig</li> </ul>"},{"location":"usage/7-middleware/builtin-middlewares/#redis-storage","title":"Redis storage","text":"<p>The Redis backend can store session data in redis. Session data stored in redis will expire automatically after its max_age has been passed.</p>  <p>Important</p> <p>This requires the <code>redis</code> package. To install it you can install starlite with <code>pip install starlite[redis]</code></p>  redis_backend.py<pre><code>from redis.asyncio import Redis\n\nfrom starlite import Starlite\nfrom starlite.middleware.session.redis_backend import RedisBackendConfig\n\nsession_config = RedisBackendConfig(redis=Redis(host=\"localhost\", port=6379, db=0))\n\napp = Starlite(route_handlers=[], middleware=[session_config.middleware])\n</code></pre>  <p>See also</p> <ul> <li>Accessing the storage backend directly</li> <li>BaseBackendConfig</li> <li>ServerSideSessionConfig</li> </ul>"},{"location":"usage/7-middleware/builtin-middlewares/#memcached-storage","title":"Memcached storage","text":"<p>The Memcached backend can store session data in memcached. Session data stored in memcached will expire automatically after its max_age has been passed.</p>  <p>Important</p> <p>This requires the <code>aiomemcache</code> package. To install it you can install starlite with <code>pip install starlite[memcached]</code></p>  memcached_backend.py<pre><code>from aiomcache import Client\n\nfrom starlite import Starlite\nfrom starlite.middleware.session.memcached_backend import MemcachedBackendConfig\n\nsession_config = MemcachedBackendConfig(memcached=Client(\"127.0.0.1\"))\n\napp = Starlite(route_handlers=[], middleware=[session_config.middleware])\n</code></pre>  <p>See also</p> <ul> <li>Accessing the storage backend directly</li> <li>BaseBackendConfig</li> <li>ServerSideSessionConfig</li> </ul>"},{"location":"usage/7-middleware/builtin-middlewares/#in-memory-storage","title":"In-memory storage","text":"<p>The Memory backend can store session data in memory.</p>  <p>Danger</p> <p>This should not be used in production. It primarily exists as a dummy backend for testing purposes. It is not process safe, and data will not be persisted.</p>  memory_backend.py<pre><code>from starlite import Starlite\nfrom starlite.middleware.session.memory_backend import MemoryBackendConfig\n\nsession_config = MemoryBackendConfig()\n\napp = Starlite(route_handlers=[], middleware=[session_config.middleware])\n</code></pre>"},{"location":"usage/7-middleware/builtin-middlewares/#database-storage","title":"Database storage","text":"<p>Database storage is currently offered through the SQLAlchemyBackend. It supports both sync and async-engines and integrates with the SQLAlchemyPlugin. Expired sessions will only be deleted when trying to access them. They can be manually deleted using the delete_expired method.</p> <p>There are two backends for SQLAlchemy:</p> <ul> <li>SQLAlchemyBackend for synchronous engines</li> <li>AsyncSQLAlchemyBackend for asynchronous engines</li> </ul> <p>When using the configuration object, it will automatically pick the correct backend to use based on the engine configuration.</p>  <p>Info</p> <p>This requires sqlalchemy. You can install it via <code>pip install sqlalchemy</code>.</p>  Synchronous engineAsynchronous engine   sqlalchemy_backend.py<pre><code>from sqlalchemy.orm import declarative_base\n\nfrom starlite import Starlite\nfrom starlite.middleware.session.sqlalchemy_backend import (\n    SQLAlchemyBackendConfig,\n    create_session_model,\n)\nfrom starlite.plugins.sql_alchemy import SQLAlchemyConfig, SQLAlchemyPlugin\n\nBase = declarative_base()\n\nsqlalchemy_config = SQLAlchemyConfig(connection_string=\"sqlite+pysqlite://\", use_async_engine=False)\nsqlalchemy_plugin = SQLAlchemyPlugin(config=sqlalchemy_config)\n\nSessionModel = create_session_model(Base)\n\nsession_config = SQLAlchemyBackendConfig(plugin=sqlalchemy_plugin, model=SessionModel)\n\n\ndef on_startup() -&gt; None:\n    \"\"\"Initialize the database.\"\"\"\n    Base.metadata.create_all(sqlalchemy_config.engine)  # type: ignore\n\n\napp = Starlite(\n    route_handlers=[],\n    middleware=[session_config.middleware],\n    plugins=[sqlalchemy_plugin],\n    on_startup=[on_startup],\n)\n</code></pre>   sqlalchemy_backend.py<pre><code>from sqlalchemy.orm import declarative_base\n\nfrom starlite import Starlite\nfrom starlite.middleware.session.sqlalchemy_backend import (\n    SQLAlchemyBackendConfig,\n    create_session_model,\n)\nfrom starlite.plugins.sql_alchemy import SQLAlchemyConfig, SQLAlchemyPlugin\n\nBase = declarative_base()\n\nSessionModel = create_session_model(Base)\n\nsqlalchemy_config = SQLAlchemyConfig(connection_string=\"sqlite+aiosqlite://\")\nsqlalchemy_plugin = SQLAlchemyPlugin(config=sqlalchemy_config)\nsession_config = SQLAlchemyBackendConfig(\n    plugin=sqlalchemy_plugin,\n    model=SessionModel,\n)\n\n\nasync def on_startup() -&gt; None:\n    \"\"\"Initialize the database.\"\"\"\n    async with sqlalchemy_config.engine.begin() as conn:  # type: ignore\n        await conn.run_sync(Base.metadata.create_all)  # pyright: ignore\n\n\napp = Starlite(\n    route_handlers=[], middleware=[session_config.middleware], plugins=[sqlalchemy_plugin], on_startup=[on_startup]\n)\n</code></pre>"},{"location":"usage/7-middleware/builtin-middlewares/#supplying-your-own-session-model","title":"Supplying your own session model","text":"<p>If you wish to extend the built-in session model, you can mixin the SessionModelMixin into your own classes:</p> sqlalchemy_backend_custom_model.py<pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import declarative_base\n\nfrom starlite import Starlite\nfrom starlite.middleware.session.sqlalchemy_backend import (\n    SessionModelMixin,\n    SQLAlchemyBackendConfig,\n)\nfrom starlite.plugins.sql_alchemy import SQLAlchemyConfig, SQLAlchemyPlugin\n\nBase = declarative_base()\n\n\nclass SessionModel(Base, SessionModelMixin):  # pyright: ignore [reportGeneralTypeIssues]\n    __tablename__ = \"my-session-table\"\n    id = Column(Integer, primary_key=True)\n    additional_data = Column(String)\n\n\nsqlalchemy_config = SQLAlchemyConfig(connection_string=\"sqlite+aiosqlite://\")\nsqlalchemy_plugin = SQLAlchemyPlugin(config=sqlalchemy_config)\nsession_config = SQLAlchemyBackendConfig(\n    plugin=sqlalchemy_plugin,\n    model=SessionModel,\n)\n\n\nasync def on_startup() -&gt; None:\n    \"\"\"Initialize the database.\"\"\"\n    async with sqlalchemy_config.engine.begin() as conn:  # type: ignore\n        await conn.run_sync(Base.metadata.create_all)  # pyright: ignore\n\n\napp = Starlite(\n    route_handlers=[], middleware=[session_config.middleware], plugins=[sqlalchemy_plugin], on_startup=[on_startup]\n)\n</code></pre>  <p>See also</p> <ul> <li>BaseBackendConfig</li> <li>ServerSideSessionConfig</li> </ul>"},{"location":"usage/7-middleware/builtin-middlewares/#accessing-the-storage-backend-directly","title":"Accessing the storage backend directly","text":"<p>In some situations you might want to access the storage backend directly, outside a request. For example to delete a specific session's data, or delete expired sessions from the database when using the SQLAlchemyBackend.</p> <pre><code>from pathlib import Path\n\nfrom starlite import Starlite\nfrom starlite.middleware.session.file_backend import FileBackend, FileBackendConfig\n\nsession_config = FileBackendConfig(storage_path=Path(\"/path/to/session/storage\"))\nsession_backend = FileBackend(config=session_config)\n\n\nasync def clear_expired_sessions() -&gt; None:\n    \"\"\"Delete all expired sessions.\"\"\"\n    await session_backend.delete_expired()\n\n\napp = Starlite(route_handlers=[], middleware=[session_backend.config.middleware])\n</code></pre>"},{"location":"usage/7-middleware/creating-middleware/","title":"Creating Middleware","text":"<p>As mentioned in the using middleware section, a middleware in Starlite is any callable that takes a kwarg called <code>app</code>, which is the next ASGI handler, i.e. an <code>ASGIApp</code>, and returns an <code>ASGIApp</code>.</p> <p>The example previously given was using a factory function, i.e.:</p> <pre><code>from starlite.types import ASGIApp, Scope, Receive, Send\n\n\ndef middleware_factory(app: ASGIApp) -&gt; ASGIApp:\n    async def my_middleware(scope: Scope, receive: Receive, send: Send) -&gt; None:\n        # do something here\n        ...\n        await app(scope, receive, send)\n\n    return my_middleware\n</code></pre> <p>While using functions is a perfectly viable approach, you can also use classes to do the same. See the next sections on two base classes you can use for this purpose - the MiddlewareProtocol, which gives a bare-bone type, or the AbstractMiddleware that offers a base class with some built in functionality.</p>"},{"location":"usage/7-middleware/creating-middleware/#using-middlewareprotocol","title":"Using MiddlewareProtocol","text":"<p>The <code>MiddlewareProtocol</code> class is a PEP 544 Protocol that specifies the minimal implementation of a middleware as follows:</p> <pre><code>from typing import Protocol, Any\nfrom starlite.types import ASGIApp, Scope, Receive, Send\n\n\nclass MiddlewareProtocol(Protocol):\n    def __init__(self, app: ASGIApp, **kwargs: Any) -&gt; None:\n        ...\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n        ...\n</code></pre> <p>The <code>__init__</code> method receives and sets \"app\". It's important to understand that app is not an instance of Starlite in this case, but rather the next middleware in the stack, which is also an ASGI app.</p> <p>The <code>__call__</code> method makes this class into a <code>callable</code>, i.e. once instantiated this class acts like a function, that has the signature of an ASGI app: The three parameters, <code>scope, receive, send</code> are specified by the ASGI specification, and their values originate with the ASGI server (e.g. uvicorn) used to run Starlite.</p> <p>To use this protocol as a basis, simply subclass it - as you would any other class, and implement the two methods it specifies:</p> <pre><code>import logging\n\nfrom starlite.types import ASGIApp, Receive, Scope, Send\nfrom starlite import Request\nfrom starlite.middleware.base import MiddlewareProtocol\n\nlogger = logging.getLogger(__name__)\n\n\nclass MyRequestLoggingMiddleware(MiddlewareProtocol):\n    def __init__(self, app: ASGIApp) -&gt; None:\n        super().__init__(app)\n        self.app = app\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n        if scope[\"type\"] == \"http\":\n            request = Request(scope)\n            logger.info(\"%s - %s\" % request.method, request.url)\n        await self.app(scope, receive, send)\n</code></pre>  <p>Important</p> <p>Although <code>scope</code> is used to create an instance of request by passing it to the <code>Request</code> constructor, which makes it simpler to access because it does some parsing for you already, the actual source of truth remains <code>scope</code> - not the request. If you need to modify the data of the request you must modify the scope object, not any ephemeral request objects created as in the above.</p>"},{"location":"usage/7-middleware/creating-middleware/#responding-using-the-middlewareprotocol","title":"Responding using the MiddlewareProtocol","text":"<p>Once a middleware finishes doing whatever its doing, it should pass <code>scope</code>, <code>receive</code> and <code>send</code> to an ASGI app and await it. This is what's happening in the above example with : <code>await self.app(scope, receive, send)</code>. Let's explore another example - redirecting the request to a different url from a middleware:</p> <pre><code>from starlite.types import ASGIApp, Receive, Scope, Send\n\nfrom starlite.response import RedirectResponse\nfrom starlite import Request\nfrom starlite.middleware.base import MiddlewareProtocol\n\n\nclass RedirectMiddleware(MiddlewareProtocol):\n    def __init__(self, app: ASGIApp) -&gt; None:\n        super().__init__(app)\n        self.app = app\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n        if Request(scope).session is None:\n            response = RedirectResponse(url=\"/login\")\n            await response(scope, receive, send)\n        else:\n            await self.app(scope, receive, send)\n</code></pre> <p>As you can see in the above, given some condition (request.session being None) we create a <code>RedirectResponse</code> and then await it. Otherwise, we await <code>self.app</code></p>"},{"location":"usage/7-middleware/creating-middleware/#modifying-asgi-requests-and-responses-using-the-middlewareprotocol","title":"Modifying ASGI Requests and Responses using the MiddlewareProtocol","text":"<p>Important</p> <p>If you'd like to modify a Response object after it was created for a route handler function but before the actual response message is transmitted, the correct place to do this is using the special life-cycle hook called After Request. The instructions in this section are for how to modify the ASGI response message itself, which is a step further in the response process.</p>  <p>Using the <code>MiddlewareProtocol</code> you can intercept and modifying both the incoming and outgoing data in a request / response cycle by \"wrapping\" that respective <code>receive</code> and <code>send</code> ASGI functions.</p> <p>To demonstrate this, lets say we want to append a header with a timestamp to all outgoing responses. We could achieve this by doing the following:</p> <pre><code>import time\n\nfrom starlite.datastructures import MutableScopeHeaders\nfrom starlite.types import Message, Receive, Scope, Send\nfrom starlite.middleware.base import MiddlewareProtocol\nfrom starlite.types import ASGIApp\n\n\nclass ProcessTimeHeader(MiddlewareProtocol):\n    def __init__(self, app: ASGIApp) -&gt; None:\n        super().__init__(app)\n        self.app = app\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -&gt; None:\n        if scope[\"type\"] == \"http\":\n            start_time = time.time()\n\n            async def send_wrapper(message: Message) -&gt; None:\n                if message[\"type\"] == \"http.response.start\":\n                    process_time = time.time() - start_time\n                    headers = MutableScopeHeaders.from_message(message=message)\n                    headers[\"X-Process-Time\"] = str(process_time)\n                await send(message)\n\n            await self.app(scope, receive, send_wrapper)\n        else:\n            await self.app(scope, receive, send)\n</code></pre>"},{"location":"usage/7-middleware/creating-middleware/#inheriting-abstractmiddleware","title":"Inheriting AbstractMiddleware","text":"<p>Starlite offers an <code>AbstractMiddleware</code> class that can be extended to create middleware:</p> <pre><code>from typing import TYPE_CHECKING\nfrom time import time\n\nfrom starlite import AbstractMiddleware, ScopeType\nfrom starlite.datastructures import MutableScopeHeaders\n\n\nif TYPE_CHECKING:\n    from starlite.types import Message, Receive, Scope, Send\n\n\nclass MyMiddleware(AbstractMiddleware):\n    scopes = {ScopeType.HTTP}\n    exclude = [\"first_path\", \"second_path\"]\n    exclude_opt_key = \"exclude_from_middleware\"\n\n    async def __call__(self, scope: \"Scope\", receive: \"Receive\", send: \"Send\") -&gt; None:\n        start_time = time()\n\n        async def send_wrapper(message: \"Message\") -&gt; None:\n            if message[\"type\"] == \"http.response.start\":\n                process_time = time() - start_time\n                headers = MutableScopeHeaders.from_message(message=message)\n                headers[\"X-Process-Time\"] = str(process_time)\n                await send(message)\n\n        await self.app(scope, receive, send_wrapper)\n</code></pre> <p>The three class variables defined in the above example <code>scopes</code>, <code>exclude</code> and <code>exclude_opt_key</code> can be used to fine-tune for which routes and request types the middleware is called:</p> <ol> <li>The scopes variable is a set that can include either or both<code>ScopeType.HTTP</code> and <code>ScopeType.WEBSOCKET</code>, with the default being both.</li> <li><code>exclude</code> accepts either a single string or list of strings that are compiled into a regex against which the request's <code>path</code> is checked.</li> <li><code>exclude_opt_key</code> is the key to use for in a route handler's <code>opt</code> dict for a boolean, whether to omit from the middleware.</li> </ol> <p>Thus, in the following example, the middleware will only run against the route handler called <code>not_excluded_handler</code>:</p> <pre><code>from time import time\nfrom typing import TYPE_CHECKING\n\nfrom starlite import AbstractMiddleware, ScopeType, Starlite, get, websocket\nfrom starlite.datastructures import MutableScopeHeaders\n\nif TYPE_CHECKING:\n    from starlite import WebSocket\n    from starlite.types import Message, Receive, Scope, Send\n\n\nclass MyMiddleware(AbstractMiddleware):\n    scopes = {ScopeType.HTTP}\n    exclude = [\"first_path\", \"second_path\"]\n    exclude_opt_key = \"exclude_from_middleware\"\n\n    async def __call__(\n        self,\n        scope: \"Scope\",\n        receive: \"Receive\",\n        send: \"Send\",\n    ) -&gt; None:\n        start_time = time()\n\n        async def send_wrapper(message: \"Message\") -&gt; None:\n            if message[\"type\"] == \"http.response.start\":\n                process_time = time() - start_time\n                headers = MutableScopeHeaders.from_message(message=message)\n                headers[\"X-Process-Time\"] = str(process_time)\n                await send(message)\n\n        await self.app(scope, receive, send_wrapper)\n\n\n@websocket(\"/my-websocket\")\nasync def websocket_handler(socket: \"WebSocket\") -&gt; None:\n    \"\"\"\n    Websocket handler - is excluded because the middleware scopes includes 'ScopeType.HTTP'\n    \"\"\"\n    await socket.accept()\n    await socket.send_json({\"hello websocket\"})\n    await socket.close()\n\n\n@get(\"/first_path\")\ndef first_handler() -&gt; dict[str, str]:\n    \"\"\"Handler is excluded due to regex pattern matching \"first_path\".\"\"\"\n    return {\"hello\": \"first\"}\n\n\n@get(\"/second_path\")\ndef second_handler() -&gt; dict[str, str]:\n    \"\"\"Handler is excluded due to regex pattern matching \"second_path\".\"\"\"\n    return {\"hello\": \"second\"}\n\n\n@get(\"/third_path\", exclude_from_middleware=True)\ndef third_handler() -&gt; dict[str, str]:\n    \"\"\"Handler is excluded due to the opt key 'exclude_from_middleware' matching the middleware 'exclude_opt_key'.\"\"\"\n    return {\"hello\": \"second\"}\n\n\n@get(\"/greet\")\ndef not_excluded_handler() -&gt; dict[str, str]:\n    \"\"\"This handler is not excluded, and thus the middleware will execute on every incoming request to it.\"\"\"\n    return {\"hello\": \"world\"}\n\n\napp = Starlite(\n    route_handlers=[websocket_handler, first_handler, second_handler, third_handler, not_excluded_handler],\n    middleware=[MyMiddleware],\n)\n</code></pre>"},{"location":"usage/7-middleware/creating-middleware/#using-definemiddleware-to-pass-arguments","title":"Using DefineMiddleware to pass arguments","text":"<p>Starlite offers a simple way to pass positional arguments (<code>*args</code>) and key-word arguments (<code>**kwargs</code>) to middleware using the <code>DefineMiddleware</code> class. Let's extend the factory function used in the examples above to take some args and kwargs and then use <code>DefineMiddleware</code> to pass these values to our middleware:</p> <pre><code>from starlite.types import ASGIApp, Scope, Receive, Send\nfrom starlite import Starlite, DefineMiddleware\n\n\ndef middleware_factory(my_arg: int, *, app: ASGIApp, my_kwarg: str) -&gt; ASGIApp:\n    async def my_middleware(scope: Scope, receive: Receive, send: Send) -&gt; None:\n        # here we can use my_arg and my_kwarg for some purpose\n        ...\n        await app(scope, receive, send)\n\n    return my_middleware\n\n\napp = Starlite(\n    route_handlers=[...],\n    middleware=[DefineMiddleware(middleware_factory, 1, my_kwarg=\"abc\")],\n)\n</code></pre> <p>The <code>DefineMiddleware</code> is a simple container - it takes a middleware callable as a first parameter, and then any positional arguments, followed by key word arguments. The middleware callable will be called with these values as well as the kwarg <code>app</code> as mentioned above.</p>"},{"location":"usage/7-middleware/middleware-intro/","title":"Introduction","text":"<p>Middlewares in Starlite are ASGI apps that are called \"in the middle\" between the application entrypoint and the route handler function.</p> <p>Starlite ships with several builtin middlewares that are easy to configure and use. See the documentation regarding these for more details.</p>  <p>Info</p> <p>If you're coming from Starlette / FastAPI, take a look at the section on middleware in the migration guide.</p>"},{"location":"usage/7-middleware/using-middleware/","title":"Using Middleware","text":"<p>A middleware in Starlite is any callable that receives at least one kwarg called <code>app</code> and returns an <code>ASGIApp</code>. An <code>ASGIApp</code> is nothing but an async function that receives the ASGI primitives <code>scope</code>, <code>receive</code> and<code>send</code>, and either calls the next <code>ASGIApp</code> or returns a response / handles the websocket connection.</p> <p>For example, the following function can be used as a middleware because it receives the <code>app</code> kwarg and returns an <code>ASGIApp</code>:</p> <pre><code>from starlite.types import ASGIApp, Scope, Receive, Send\n\n\ndef middleware_factory(app: ASGIApp) -&gt; ASGIApp:\n    async def my_middleware(scope: Scope, receive: Receive, send: Send) -&gt; None:\n        # do something here\n        ...\n        await app(scope, receive, send)\n\n    return my_middleware\n</code></pre> <p>We can then pass this middleware to the <code>Starlite</code> instance, where it will be called on every request:</p> <pre><code>from starlite.types import ASGIApp, Scope, Receive, Send\nfrom starlite import Starlite\n\n\ndef middleware_factory(app: ASGIApp) -&gt; ASGIApp:\n    async def my_middleware(scope: Scope, receive: Receive, send: Send) -&gt; None:\n        # do something here\n        ...\n        await app(scope, receive, send)\n\n    return my_middleware\n\n\napp = Starlite(route_handlers=[...], middleware=[middleware_factory])\n</code></pre> <p>In the above example, Starlite will call the <code>middleware_factory</code> function and pass to it <code>app</code>. It's important to understand that this kwarg does not designate the Starlite application but rather the next <code>ASGIApp</code> in the stack. It will then insert the returned <code>my_middleware</code> function into the stack of every route in the application - because we declared it on the application level.</p>  <p>Layered architecture</p> <p>Middlewares are part of Starlite's layered architecture* which means you can set them on every layer of the application.</p> <p>You can read more about this here: Layered architecture</p>"},{"location":"usage/7-middleware/using-middleware/#middleware-call-order","title":"Middleware Call Order","text":"<p>Since it's also possible to define multiple middlewares on every layer, the call order for middlewares will be top to bottom and left to right. This means for each layer, the middlewares will be called in the order they have been passed, while the layers will be traversed in the usual order:</p> <pre><code>flowchart LR\n    Application --&gt; Router --&gt; Controller --&gt; Handler</code></pre> Python 3.8+Python 3.9+   <pre><code>from typing import TYPE_CHECKING, List, Type\n\nfrom starlite import Controller, MiddlewareProtocol, Router, Starlite, State, get\n\nif TYPE_CHECKING:\n    from starlite.types import ASGIApp, Receive, Scope, Send\n\n\ndef create_test_middleware(middleware_id: int) -&gt; Type[MiddlewareProtocol]:\n    class TestMiddleware(MiddlewareProtocol):\n        def __init__(self, app: \"ASGIApp\") -&gt; None:\n            self.app = app\n\n        async def __call__(self, scope: \"Scope\", receive: \"Receive\", send: \"Send\") -&gt; None:\n            starlite_app = scope[\"app\"]\n            starlite_app.state.setdefault(\"middleware_calls\", [])\n            starlite_app.state[\"middleware_calls\"].append(middleware_id)\n            await self.app(scope, receive, send)\n\n    return TestMiddleware\n\n\nclass MyController(Controller):\n    path = \"/controller\"\n    middleware = [create_test_middleware(4), create_test_middleware(5)]\n\n    @get(\n        \"/handler\",\n        middleware=[create_test_middleware(6), create_test_middleware(7)],\n    )\n    async def my_handler(self, state: State) -&gt; List[int]:\n        return state[\"middleware_calls\"]  # type: ignore\n\n\nrouter = Router(\n    path=\"/router\",\n    route_handlers=[MyController],\n    middleware=[create_test_middleware(2), create_test_middleware(3)],\n)\n\napp = Starlite(\n    route_handlers=[router],\n    middleware=[create_test_middleware(0), create_test_middleware(1)],\n)\n</code></pre>   <pre><code>from typing import TYPE_CHECKING\n\nfrom starlite import Controller, MiddlewareProtocol, Router, Starlite, State, get\n\nif TYPE_CHECKING:\n    from starlite.types import ASGIApp, Receive, Scope, Send\n\n\ndef create_test_middleware(middleware_id: int) -&gt; type[MiddlewareProtocol]:\n    class TestMiddleware(MiddlewareProtocol):\n        def __init__(self, app: \"ASGIApp\") -&gt; None:\n            self.app = app\n\n        async def __call__(self, scope: \"Scope\", receive: \"Receive\", send: \"Send\") -&gt; None:\n            starlite_app = scope[\"app\"]\n            starlite_app.state.setdefault(\"middleware_calls\", [])\n            starlite_app.state[\"middleware_calls\"].append(middleware_id)\n            await self.app(scope, receive, send)\n\n    return TestMiddleware\n\n\nclass MyController(Controller):\n    path = \"/controller\"\n    middleware = [create_test_middleware(4), create_test_middleware(5)]\n\n    @get(\n        \"/handler\",\n        middleware=[create_test_middleware(6), create_test_middleware(7)],\n    )\n    async def my_handler(self, state: State) -&gt; list[int]:\n        return state[\"middleware_calls\"]  # type: ignore\n\n\nrouter = Router(\n    path=\"/router\",\n    route_handlers=[MyController],\n    middleware=[create_test_middleware(2), create_test_middleware(3)],\n)\n\napp = Starlite(\n    route_handlers=[router],\n    middleware=[create_test_middleware(0), create_test_middleware(1)],\n)\n</code></pre>     <p>Run it</p> <pre><code>&gt; curl http://127.0.0.1:8000/router/controller/handler\n[0,1,2,3,4,5,6,7]\n</code></pre>"},{"location":"usage/7-middleware/using-middleware/#middlewares-and-exceptions","title":"Middlewares and Exceptions","text":"<p>When an exception is raised by a route handler or a dependency it will be transformed into a response by an exception handler. This response will follow the normal \"flow\" of the application and therefore, middlewares are still applied to it.</p> <p>As with any good rule, there are exceptions to it. In this case they are two exceptions raised by Starlite's ASGI router:</p> <ul> <li><code>NotFoundException</code></li> <li><code>MethodNotAllowedException</code></li> </ul> <p>They are raised before the middleware stack is called and will only be handled by exception handlers defined on the <code>Starlite</code> instance itself. If you wish to modify error responses generated from these exception, you will have to use an application layer exception handler.</p>"},{"location":"usage/8-security/0-intro/","title":"Security","text":"<p>While Starlite is agnostic to the security scheme used - allowing users to use any standard and non-standard security scheme they deem necessary, it does include several builtin components that allow for easy implementation of authentication and authorization.</p>"},{"location":"usage/8-security/1-abstract-authentication-middleware/","title":"AbstractAuthenticationMiddleware","text":"<p>Starlite exports a class called <code>AbstractAuthenticationMiddleware</code>, which is an Abstract Base Class (ABC) that implements the <code>MiddlewareProtocol</code>. To add authentication to your app using this class as a basis, subclass it and implement the abstract method <code>authenticate_request</code>:</p> <pre><code>from starlite import (\n    AbstractAuthenticationMiddleware,\n    AuthenticationResult,\n    ASGIConnection,\n)\n\n\nclass MyAuthenticationMiddleware(AbstractAuthenticationMiddleware):\n    async def authenticate_request(\n        self, connection: ASGIConnection\n    ) -&gt; AuthenticationResult:\n        # do something here.\n        ...\n</code></pre> <p>As you can see, <code>authenticate_request</code> is an async function that receives a connection instance and is supposed to return an <code>AuthenticationResult</code> instance, which is a pydantic model that has two attributes:</p> <ol> <li><code>user</code>: a non-optional value representing a user. It's typed as <code>Any</code> so it receives any value, including <code>None</code>.</li> <li><code>auth</code>: an optional value representing the authentication scheme. Defaults to <code>None</code>.</li> </ol> <p>These values are then set as part of the \"scope\" dictionary, and they are made available as <code>Request.user</code> and <code>Request.auth</code> respectively, for HTTP route handlers, and <code>WebSocket.user</code> and <code>WebSocket.auth</code> for websocket route handlers.</p>"},{"location":"usage/8-security/1-abstract-authentication-middleware/#example-implementing-a-jwtauthenticationmiddleware","title":"Example: Implementing a JWTAuthenticationMiddleware","text":"<p>Since the above is quite hard to grasp in the abstract, lets see an example.</p> <p>We start off by creating a user model. It can be implemented using pydantic, and ODM, ORM etc. For the sake of the example here lets say it's a pydantic model:</p> my_app/db/models.py<pre><code>import uuid\n\nfrom sqlalchemy import Column\nfrom sqlalchemy.dialects.postgresql import UUID\nfrom sqlalchemy.orm import declarative_base\n\nBase = declarative_base()\n\n\nclass User(Base):\n    id: uuid.UUID | None = Column(\n        UUID(as_uuid=True), default=uuid.uuid4, primary_key=True\n    )\n    # ... other fields follow, but we only require id for this example\n</code></pre> <p>We will also need some utility methods to encode and decode tokens. To this end we will use the python-jose library. We will also create a pydantic model representing a JWT Token:</p> my_app/security/jwt.py<pre><code>from datetime import datetime, timedelta\nfrom uuid import UUID\n\nfrom jose import JWTError, jwt\nfrom pydantic import BaseModel, UUID4\nfrom starlite.exceptions import NotAuthorizedException\n\nfrom app.config import settings\n\nDEFAULT_TIME_DELTA = timedelta(days=1)\nALGORITHM = \"HS256\"\n\n\nclass Token(BaseModel):\n    exp: datetime\n    iat: datetime\n    sub: UUID4\n\n\ndef decode_jwt_token(encoded_token: str) -&gt; Token:\n    \"\"\"\n    Helper function that decodes a jwt token and returns the value stored under the 'sub' key\n\n    If the token is invalid or expired (i.e. the value stored under the exp key is in the past) an exception is raised\n    \"\"\"\n    try:\n        payload = jwt.decode(token=encoded_token, key=settings.JWT_SECRET, algorithms=[ALGORITHM])\n        return Token(**payload)\n    except JWTError as e:\n        raise NotAuthorizedException(\"Invalid token\") from e\n\n\ndef encode_jwt_token(user_id: UUID, expiration: timedelta = DEFAULT_TIME_DELTA) -&gt; str:\n    \"\"\"Helper function that encodes a JWT token with expiration and a given user_id\"\"\"\n    token = Token(\n        exp=datetime.now() + expiration,\n        iat=datetime.now(),\n        sub=user_id,\n    )\n    return jwt.encode(token.dict(), settings.JWT_SECRET, algorithm=ALGORITHM)\n</code></pre> <p>We can now create our authentication middleware:</p> my_app/security/authentication_middleware.py<pre><code>from typing import cast, TYPE_CHECKING\n\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom starlite import (\n    AbstractAuthenticationMiddleware,\n    AuthenticationResult,\n    NotAuthorizedException,\n    ASGIConnection,\n)\n\nfrom app.db.models import User\nfrom app.security.jwt import decode_jwt_token\n\nif TYPE_CHECKING:\n    from sqlalchemy.ext.asyncio import AsyncEngine\n\nAPI_KEY_HEADER = \"X-API-KEY\"\n\n\nclass JWTAuthenticationMiddleware(AbstractAuthenticationMiddleware):\n    async def authenticate_request(\n            self, connection: ASGIConnection\n    ) -&gt; AuthenticationResult:\n        \"\"\"\n        Given a request, parse the request api key stored in the header and retrieve the user correlating to the token from the DB\n\n        \"\"\"\n\n        # retrieve the auth header\n        auth_header = connection.headers.get(API_KEY_HEADER)\n        if not auth_header:\n            raise NotAuthorizedException()\n\n        # decode the token, the result is a 'Token' model instance\n        token = decode_jwt_token(encoded_token=auth_header)\n\n        engine = cast(\"AsyncEngine\", connection.app.state.postgres_connection)\n        async with AsyncSession(engine) as async_session:\n            async with async_session.begin():\n                user = await async_session.execute(\n                    select(User).where(User.id == token.sub)\n                )\n        if not user:\n            raise NotAuthorizedException()\n        return AuthenticationResult(user=user, auth=token)\n</code></pre> <p>Finally, we need to pass our middleware to the Starlite constructor:</p> my_app/main.py<pre><code>from starlite import Starlite\nfrom starlite.middleware.base import DefineMiddleware\n\nfrom my_app.security.authentication_middleware import JWTAuthenticationMiddleware\n# you can optionally exclude certain paths from authentication.\n# the following excludes all routes mounted at or under `/schema*`\nauth_mw = DefineMiddleware(JWTAuthenticationMiddleware, exclude=\"schema\")\n\napp = Starlite(request_handlers=[...], middleware=[auth_mw])\n</code></pre> <p>That's it. The <code>JWTAuthenticationMiddleware</code> will now run for every request, and we would be able to access these in a http route handler in the following way:</p> <pre><code>from starlite import Request, get\n\nfrom my_app.db.models import User\nfrom my_app.security.jwt import Token\n\n\n@get(\"/\")\ndef my_route_handler(request: Request[User, Token]) -&gt; None:\n    user = request.user  # correctly typed as User\n    auth = request.auth  # correctly typed as Token\n    assert isinstance(user, User)\n    assert isinstance(auth, Token)\n</code></pre> <p>Or for a websocket route:</p> <pre><code>from starlite import WebSocket, websocket\n\nfrom my_app.db.models import User\nfrom my_app.security.jwt import Token\n\n\n@websocket(\"/\")\nasync def my_route_handler(socket: WebSocket[User, Token]) -&gt; None:\n    user = socket.user  # correctly typed as User\n    auth = socket.auth  # correctly typed as Token\n    assert isinstance(user, User)\n    assert isinstance(auth, Token)\n</code></pre> <p>And if you'd like to exclude individual routes outside those configured:</p> <pre><code>import anyio\nfrom starlite import Starlite, MediaType, NotFoundException, Response, get\nfrom starlite.middleware.base import DefineMiddleware\n\nfrom my_app.security.authentication_middleware import JWTAuthenticationMiddleware\n\n# you can optionally exclude certain paths from authentication.\n# the following excludes all routes mounted at or under `/schema*`\n# additionally,\n# you can modify the default exclude key of \"exclude_from_auth\", by overriding the `exclude_from_auth_key` parameter on the Authentication Middleware\nauth_mw = DefineMiddleware(JWTAuthenticationMiddleware, exclude=\"schema\")\n\n\n@get(path=\"/\", exclude_from_auth=True)\nasync def site_index() -&gt; Response:\n    \"\"\"Site index\"\"\"\n    exists = await anyio.Path(\"index.html\").exists()\n    if exists:\n        async with await anyio.open_file(anyio.Path(\"index.html\")) as file:\n            content = await file.read()\n            return Response(content=content, status_code=200, media_type=MediaType.HTML)\n    raise NotFoundException(\"Site index was not found\")\n\n\napp = Starlite(route_handlers=[site_index], middleware=[auth_mw])\n</code></pre> <p>And of course use the same kind of mechanism for dependencies:</p> <pre><code>from typing import Any\n\nfrom starlite import Request, Provide, Router\n\nfrom my_app.db.models import User\nfrom my_app.security.jwt import Token\n\n\nasync def my_dependency(request: Request[User, Token]) -&gt; Any:\n    user = request.user  # correctly typed as User\n    auth = request.auth  # correctly typed as Token\n    assert isinstance(user, User)\n    assert isinstance(auth, Token)\n\n\nmy_router = Router(\n    path=\"sub-path/\", dependencies={\"some_dependency\": Provide(my_dependency)}\n)\n</code></pre>"},{"location":"usage/8-security/2-security-backends/","title":"Security Backends","text":""},{"location":"usage/8-security/2-security-backends/#abstractsecurityconfig","title":"AbstractSecurityConfig","text":"<p>The package <code>starlite.security</code> includes an <code>AbstractSecurityConfig</code> class that serves as a basis for all the security backends offered by Starlite, and is also meant to be used as a basis for custom security backends created by users. You can read more about this class in the API References.</p>"},{"location":"usage/8-security/2-security-backends/#session-auth-backend","title":"Session Auth Backend","text":"<p>Starlite offers a builtin session auth backend that can be used out of the box with any of the session backends supported by the Starlite session middleware.</p> Python 3.8+Python 3.9+Python 3.10+   Using Session Auth<pre><code>from typing import Any, Dict, Literal, Optional\nfrom uuid import UUID, uuid4\n\nfrom pydantic import BaseModel, EmailStr, SecretStr\n\nfrom starlite import (\n    ASGIConnection,\n    NotAuthorizedException,\n    OpenAPIConfig,\n    Request,\n    Starlite,\n    get,\n    post,\n)\nfrom starlite.middleware.session.memory_backend import MemoryBackendConfig\nfrom starlite.security.session_auth import SessionAuth\n\n\n# Let's assume we have a User model that is a pydantic model.\n# This though is not required - we need some sort of user class -\n# but it can be any arbitrary value, e.g. an SQLAlchemy model,\n# a representation of a MongoDB  etc.\nclass User(BaseModel):\n    id: UUID\n    name: str\n    email: EmailStr\n\n\n# we also have pydantic types for two different\n# kinds of POST request bodies: one for creating\n# a user, e.g. \"sign-up\", and the other for logging\n# an existing user in.\nclass UserCreatePayload(BaseModel):\n    name: str\n    email: EmailStr\n    password: SecretStr\n\n\nclass UserLoginPayload(BaseModel):\n    email: EmailStr\n    password: SecretStr\n\n\n# The SessionAuth class requires a handler callable\n# that takes the session dictionary, and returns the\n# 'User' instance correlating to it.\n#\n# The session dictionary itself is a value the user decides\n# upon. So for example, it might be a simple dictionary\n# that holds a user id, for example: { \"id\": \"abcd123\" }\n#\n# Note: The callable can be either sync or async - both will work.\nasync def retrieve_user_handler(session: Dict[str, Any], connection: ASGIConnection) -&gt; Optional[User]:\n    # we retrieve the user instance based on session data\n    value = await connection.cache.get(session.get(\"user_id\", \"\"))\n    if value:\n        return User(**value)\n    return None\n\n\n@post(\"/login\")\nasync def login(data: UserLoginPayload, request: Request) -&gt; User:\n    # we received log-in data via post.\n    # our login handler should retrieve from persistence (a db etc.)\n    # the user data and verify that the login details\n    # are correct. If we are using passwords, we should check that\n    # the password hashes match etc. We will simply assume that we\n    # have done all of that we now have a user value:\n    user_id = await request.cache.get(data.email)\n\n    if not user_id:\n        raise NotAuthorizedException\n\n    user_data = await request.cache.get(user_id)\n\n    # once verified we can create a session.\n    # to do this we simply need to call the Starlite\n    # 'Request.set_session' method, which accepts either dictionaries\n    # or pydantic models. In our case, we can simply record a\n    # simple dictionary with the user ID value:\n    request.set_session({\"user_id\": user_id})\n\n    # you can do whatever we want here. In this case, we will simply return the user data:\n    return User(**user_data)\n\n\n@post(\"/signup\")\nasync def signup(data: UserCreatePayload, request: Request) -&gt; User:\n    # this is similar to the login handler, except here we should\n    # insert into persistence - after doing whatever extra\n    # validation we might require. We will assume that this is done,\n    # and we now have a user instance with an assigned ID value:\n    user = User(name=data.name, email=data.email, id=uuid4())\n\n    await request.cache.set(data.email, str(user.id))\n    await request.cache.set(str(user.id), user.dict())\n    # we are creating a session the same as we do in the\n    # 'login_handler' above:\n    request.set_session({\"user_id\": str(user.id)})\n\n    # and again, you can add whatever logic is required here, we\n    # will simply return the user:\n    return user\n\n\n# the endpoint below requires the user to be already authenticated\n# to be able to access it.\n@get(\"/user\")\ndef get_user(request: Request[User, dict[Literal[\"user_id\"], str]]) -&gt; Any:\n    # because this route requires authentication, we can access\n    # `request.user`, which is the authenticated user returned\n    # by the 'retrieve_user_handler' function we passed to SessionAuth.\n    return request.user\n\n\n# We add the session security schema to the OpenAPI config.\nopenapi_config = OpenAPIConfig(\n    title=\"My API\",\n    version=\"1.0.0\",\n)\n\nsession_auth = SessionAuth[User](\n    retrieve_user_handler=retrieve_user_handler,\n    # we must pass a config for a session backend.\n    # all session backends are supported\n    session_backend_config=MemoryBackendConfig(),\n    # exclude any URLs that should not have authentication.\n    # We exclude the documentation URLs, signup and login.\n    exclude=[\"/login\", \"/signup\", \"/schema\"],\n)\n\n\n# We initialize the app instance, passing to it the 'session_auth.on_app_init' and the 'openapi_config'.\napp = Starlite(\n    route_handlers=[login, signup, get_user],\n    on_app_init=[session_auth.on_app_init],\n    openapi_config=openapi_config,\n)\n</code></pre>   Using Session Auth<pre><code>from typing import Any, Literal, Optional\nfrom uuid import UUID, uuid4\n\nfrom pydantic import BaseModel, EmailStr, SecretStr\n\nfrom starlite import (\n    ASGIConnection,\n    NotAuthorizedException,\n    OpenAPIConfig,\n    Request,\n    Starlite,\n    get,\n    post,\n)\nfrom starlite.middleware.session.memory_backend import MemoryBackendConfig\nfrom starlite.security.session_auth import SessionAuth\n\n\n# Let's assume we have a User model that is a pydantic model.\n# This though is not required - we need some sort of user class -\n# but it can be any arbitrary value, e.g. an SQLAlchemy model,\n# a representation of a MongoDB  etc.\nclass User(BaseModel):\n    id: UUID\n    name: str\n    email: EmailStr\n\n\n# we also have pydantic types for two different\n# kinds of POST request bodies: one for creating\n# a user, e.g. \"sign-up\", and the other for logging\n# an existing user in.\nclass UserCreatePayload(BaseModel):\n    name: str\n    email: EmailStr\n    password: SecretStr\n\n\nclass UserLoginPayload(BaseModel):\n    email: EmailStr\n    password: SecretStr\n\n\n# The SessionAuth class requires a handler callable\n# that takes the session dictionary, and returns the\n# 'User' instance correlating to it.\n#\n# The session dictionary itself is a value the user decides\n# upon. So for example, it might be a simple dictionary\n# that holds a user id, for example: { \"id\": \"abcd123\" }\n#\n# Note: The callable can be either sync or async - both will work.\nasync def retrieve_user_handler(session: dict[str, Any], connection: ASGIConnection) -&gt; Optional[User]:\n    # we retrieve the user instance based on session data\n    value = await connection.cache.get(session.get(\"user_id\", \"\"))\n    if value:\n        return User(**value)\n    return None\n\n\n@post(\"/login\")\nasync def login(data: UserLoginPayload, request: Request) -&gt; User:\n    # we received log-in data via post.\n    # our login handler should retrieve from persistence (a db etc.)\n    # the user data and verify that the login details\n    # are correct. If we are using passwords, we should check that\n    # the password hashes match etc. We will simply assume that we\n    # have done all of that we now have a user value:\n    user_id = await request.cache.get(data.email)\n\n    if not user_id:\n        raise NotAuthorizedException\n\n    user_data = await request.cache.get(user_id)\n\n    # once verified we can create a session.\n    # to do this we simply need to call the Starlite\n    # 'Request.set_session' method, which accepts either dictionaries\n    # or pydantic models. In our case, we can simply record a\n    # simple dictionary with the user ID value:\n    request.set_session({\"user_id\": user_id})\n\n    # you can do whatever we want here. In this case, we will simply return the user data:\n    return User(**user_data)\n\n\n@post(\"/signup\")\nasync def signup(data: UserCreatePayload, request: Request) -&gt; User:\n    # this is similar to the login handler, except here we should\n    # insert into persistence - after doing whatever extra\n    # validation we might require. We will assume that this is done,\n    # and we now have a user instance with an assigned ID value:\n    user = User(name=data.name, email=data.email, id=uuid4())\n\n    await request.cache.set(data.email, str(user.id))\n    await request.cache.set(str(user.id), user.dict())\n    # we are creating a session the same as we do in the\n    # 'login_handler' above:\n    request.set_session({\"user_id\": str(user.id)})\n\n    # and again, you can add whatever logic is required here, we\n    # will simply return the user:\n    return user\n\n\n# the endpoint below requires the user to be already authenticated\n# to be able to access it.\n@get(\"/user\")\ndef get_user(request: Request[User, dict[Literal[\"user_id\"], str]]) -&gt; Any:\n    # because this route requires authentication, we can access\n    # `request.user`, which is the authenticated user returned\n    # by the 'retrieve_user_handler' function we passed to SessionAuth.\n    return request.user\n\n\n# We add the session security schema to the OpenAPI config.\nopenapi_config = OpenAPIConfig(\n    title=\"My API\",\n    version=\"1.0.0\",\n)\n\nsession_auth = SessionAuth[User](\n    retrieve_user_handler=retrieve_user_handler,\n    # we must pass a config for a session backend.\n    # all session backends are supported\n    session_backend_config=MemoryBackendConfig(),\n    # exclude any URLs that should not have authentication.\n    # We exclude the documentation URLs, signup and login.\n    exclude=[\"/login\", \"/signup\", \"/schema\"],\n)\n\n\n# We initialize the app instance, passing to it the 'session_auth.on_app_init' and the 'openapi_config'.\napp = Starlite(\n    route_handlers=[login, signup, get_user],\n    on_app_init=[session_auth.on_app_init],\n    openapi_config=openapi_config,\n)\n</code></pre>   Using Session Auth<pre><code>from typing import Any, Literal\nfrom uuid import UUID, uuid4\n\nfrom pydantic import BaseModel, EmailStr, SecretStr\n\nfrom starlite import (\n    ASGIConnection,\n    NotAuthorizedException,\n    OpenAPIConfig,\n    Request,\n    Starlite,\n    get,\n    post,\n)\nfrom starlite.middleware.session.memory_backend import MemoryBackendConfig\nfrom starlite.security.session_auth import SessionAuth\n\n\n# Let's assume we have a User model that is a pydantic model.\n# This though is not required - we need some sort of user class -\n# but it can be any arbitrary value, e.g. an SQLAlchemy model,\n# a representation of a MongoDB  etc.\nclass User(BaseModel):\n    id: UUID\n    name: str\n    email: EmailStr\n\n\n# we also have pydantic types for two different\n# kinds of POST request bodies: one for creating\n# a user, e.g. \"sign-up\", and the other for logging\n# an existing user in.\nclass UserCreatePayload(BaseModel):\n    name: str\n    email: EmailStr\n    password: SecretStr\n\n\nclass UserLoginPayload(BaseModel):\n    email: EmailStr\n    password: SecretStr\n\n\n# The SessionAuth class requires a handler callable\n# that takes the session dictionary, and returns the\n# 'User' instance correlating to it.\n#\n# The session dictionary itself is a value the user decides\n# upon. So for example, it might be a simple dictionary\n# that holds a user id, for example: { \"id\": \"abcd123\" }\n#\n# Note: The callable can be either sync or async - both will work.\nasync def retrieve_user_handler(session: dict[str, Any], connection: ASGIConnection) -&gt; User | None:\n    # we retrieve the user instance based on session data\n    value = await connection.cache.get(session.get(\"user_id\", \"\"))\n    if value:\n        return User(**value)\n    return None\n\n\n@post(\"/login\")\nasync def login(data: UserLoginPayload, request: Request) -&gt; User:\n    # we received log-in data via post.\n    # our login handler should retrieve from persistence (a db etc.)\n    # the user data and verify that the login details\n    # are correct. If we are using passwords, we should check that\n    # the password hashes match etc. We will simply assume that we\n    # have done all of that we now have a user value:\n    user_id = await request.cache.get(data.email)\n\n    if not user_id:\n        raise NotAuthorizedException\n\n    user_data = await request.cache.get(user_id)\n\n    # once verified we can create a session.\n    # to do this we simply need to call the Starlite\n    # 'Request.set_session' method, which accepts either dictionaries\n    # or pydantic models. In our case, we can simply record a\n    # simple dictionary with the user ID value:\n    request.set_session({\"user_id\": user_id})\n\n    # you can do whatever we want here. In this case, we will simply return the user data:\n    return User(**user_data)\n\n\n@post(\"/signup\")\nasync def signup(data: UserCreatePayload, request: Request) -&gt; User:\n    # this is similar to the login handler, except here we should\n    # insert into persistence - after doing whatever extra\n    # validation we might require. We will assume that this is done,\n    # and we now have a user instance with an assigned ID value:\n    user = User(name=data.name, email=data.email, id=uuid4())\n\n    await request.cache.set(data.email, str(user.id))\n    await request.cache.set(str(user.id), user.dict())\n    # we are creating a session the same as we do in the\n    # 'login_handler' above:\n    request.set_session({\"user_id\": str(user.id)})\n\n    # and again, you can add whatever logic is required here, we\n    # will simply return the user:\n    return user\n\n\n# the endpoint below requires the user to be already authenticated\n# to be able to access it.\n@get(\"/user\")\ndef get_user(request: Request[User, dict[Literal[\"user_id\"], str]]) -&gt; Any:\n    # because this route requires authentication, we can access\n    # `request.user`, which is the authenticated user returned\n    # by the 'retrieve_user_handler' function we passed to SessionAuth.\n    return request.user\n\n\n# We add the session security schema to the OpenAPI config.\nopenapi_config = OpenAPIConfig(\n    title=\"My API\",\n    version=\"1.0.0\",\n)\n\nsession_auth = SessionAuth[User](\n    retrieve_user_handler=retrieve_user_handler,\n    # we must pass a config for a session backend.\n    # all session backends are supported\n    session_backend_config=MemoryBackendConfig(),\n    # exclude any URLs that should not have authentication.\n    # We exclude the documentation URLs, signup and login.\n    exclude=[\"/login\", \"/signup\", \"/schema\"],\n)\n\n\n# We initialize the app instance, passing to it the 'session_auth.on_app_init' and the 'openapi_config'.\napp = Starlite(\n    route_handlers=[login, signup, get_user],\n    on_app_init=[session_auth.on_app_init],\n    openapi_config=openapi_config,\n)\n</code></pre>"},{"location":"usage/8-security/2-security-backends/#jwt-auth","title":"JWT Auth","text":"<p>Starlite also includes several JWT security backends under the contrib package, checkout the jwt contrib documentation for more details.</p>"},{"location":"usage/8-security/3-guards/","title":"Guards","text":"<p>Guards are callables that receive two arguments - <code>connection</code>, which is the <code>ASGIConnection</code> instance, and <code>route_handler</code>, which is a copy of the <code>BaseRouteHandler</code>. Their role is to authorize the request by verifying that the connection is allowed to reach the endpoint handler in question. If verification fails, the guard should raise an HTTPException, usually a <code>NotAuthorizedException</code> with a <code>status_code</code> of 401.</p> <p>To illustrate this we will implement a rudimentary role based authorization system in our Starlite app. As we have done for <code>authentication</code>, we will assume that we added some sort of persistence layer without actually specifying it in the example.</p> <p>We begin by creating an <code>Enum</code> with two roles - <code>consumer</code> and <code>admin</code>:</p> <pre><code>from enum import Enum\n\n\nclass UserRole(str, Enum):\n    CONSUMER = \"consumer\"\n    ADMIN = \"admin\"\n</code></pre> <p>Our <code>User</code> model will now look like this:</p> <pre><code>from pydantic import BaseModel, UUID4\nfrom enum import Enum\n\n\nclass UserRole(str, Enum):\n    CONSUMER = \"consumer\"\n    ADMIN = \"admin\"\n\n\nclass User(BaseModel):\n    id: UUID4\n    role: UserRole\n\n    @property\n    def is_admin(self) -&gt; bool:\n        \"\"\"Determines whether the user is an admin user\"\"\"\n        return self.role == UserRole.ADMIN\n</code></pre> <p>Given that the User model has a \"role\" property we can use it to authorize a request. Let's create a guard that only allows admin users to access certain route handlers and then add it to a route handler function:</p> <pre><code>from starlite import ASGIConnection, BaseRouteHandler, NotAuthorizedException\nfrom pydantic import BaseModel, UUID4\nfrom starlite import post\nfrom enum import Enum\n\n\nclass UserRole(str, Enum):\n    CONSUMER = \"consumer\"\n    ADMIN = \"admin\"\n\n\nclass User(BaseModel):\n    id: UUID4\n    role: UserRole\n\n    @property\n    def is_admin(self) -&gt; bool:\n        \"\"\"Determines whether the user is an admin user\"\"\"\n        return self.role == UserRole.ADMIN\n\n\ndef admin_user_guard(connection: ASGIConnection, _: BaseRouteHandler) -&gt; None:\n    if not connection.user.is_admin:\n        raise NotAuthorizedException()\n\n\n@post(path=\"/user\", guards=[admin_user_guard])\ndef create_user(data: User) -&gt; User:\n    ...\n</code></pre> <p>Thus, only an admin user would be able to send a post request to the <code>create_user</code> handler.</p>"},{"location":"usage/8-security/3-guards/#guard-scopes","title":"Guard Scopes","text":"<p>Guards can be declared on all levels of the app - the Starlite instance, routers, controllers and individual route handlers:</p> <pre><code>from starlite import ASGIConnection, Controller, Router, Starlite, BaseRouteHandler\n\n\ndef my_guard(connection: ASGIConnection, handler: BaseRouteHandler) -&gt; None:\n    ...\n\n\n# controller\nclass UserController(Controller):\n    path = \"/user\"\n    guards = [my_guard]\n\n    ...\n\n\n# router\nadmin_router = Router(path=\"admin\", route_handlers=[UserController], guards=[my_guard])\n\n# app\napp = Starlite(route_handlers=[admin_router], guards=[my_guard])\n</code></pre> <p>The deciding factor on where to place a guard is on the kind of access restriction that are required: do only specific route handlers need to be restricted? An entire controller? All the paths under a specific router? Or the entire app?</p> <p>As you can see in the above examples - <code>guards</code> is a list. This means you can add multiple guards at every layer. Unlike <code>dependencies</code>, guards do not override each other but are rather cumulative. This means that you can define guards on different levels of your app, and they will combine.</p>"},{"location":"usage/8-security/3-guards/#the-route-handler-opt-key","title":"The Route Handler \"opt\" Key","text":"<p>Occasionally there might be a need to set some values on the route handler itself - these can be permissions, or some other flag. This can be achieved with <code>opts</code> kwarg of route handler</p> <p>To illustrate this lets say we want to have an endpoint that is guarded by a \"secret\" token, to which end we create the following guard:</p> <pre><code>from starlite import ASGIConnection, BaseRouteHandler, NotAuthorizedException, get\nfrom os import environ\n\n\ndef secret_token_guard(\n    connection: ASGIConnection, route_handler: BaseRouteHandler\n) -&gt; None:\n    if (\n        route_handler.opt.get(\"secret\")\n        and not connection.headers.get(\"Secret-Header\", \"\")\n        == route_handler.opt[\"secret\"]\n    ):\n        raise NotAuthorizedException()\n\n\n@get(path=\"/secret\", guards=[secret_token_guard], opt={\"secret\": environ.get(\"SECRET\")})\ndef secret_endpoint() -&gt; None:\n    ...\n</code></pre>"},{"location":"usage/9-testing/0-intro/","title":"Testing","text":"<p>Testing is a first class citizen in Starlite, which offers several powerful testing utilities out of the box.</p>"},{"location":"usage/9-testing/1-test-client/","title":"Test Client","text":"<p>Starlite's test client is built on top of the httpx library. To use the test client you should pass to it an instance of Starlite as the <code>app</code> kwarg.</p> <p>Let's say we have a very simple app with a health check endpoint:</p> my_app/main.py<pre><code>from starlite import Starlite, MediaType, get\n\n\n@get(path=\"/health-check\", media_type=MediaType.TEXT)\ndef health_check() -&gt; str:\n    return \"healthy\"\n\n\napp = Starlite(route_handlers=[health_check])\n</code></pre> <p>We would then test it using the test client like so:</p> tests/test_health_check.py<pre><code>from starlite.status_codes import HTTP_200_OK\nfrom starlite.testing import TestClient\n\nfrom my_app.main import app\n\n\ndef test_health_check():\n    with TestClient(app=app) as client:\n        response = client.get(\"/health-check\")\n        assert response.status_code == HTTP_200_OK\n        assert response.text == \"healthy\"\n</code></pre> <p>Since we would probably need to use the client in multiple places, it's better to make it into a pytest fixture:</p> tests/conftest.py<pre><code>import pytest\n\nfrom starlite.testing import TestClient\n\nfrom my_app.main import app\n\n\n@pytest.fixture(scope=\"function\")\ndef test_client() -&gt; TestClient:\n    return TestClient(app=app)\n</code></pre> <p>We would then be able to rewrite our test like so:</p> tests/test_health_check.py<pre><code>from starlite.status_codes import HTTP_200_OK\nfrom starlite.testing import TestClient\n\n\ndef test_health_check(test_client: TestClient):\n    with test_client as client:\n        response = client.get(\"/health-check\")\n        assert response.status_code == HTTP_200_OK\n        assert response.text == \"healthy\"\n</code></pre>"},{"location":"usage/9-testing/1-test-client/#using-sessions","title":"Using sessions","text":"<p>If you are using Session Middleware for session persistence across requests, then you might want to inject or inspect session data outside a request. For this, <code>TestClient</code> provides two methods:</p> <ul> <li>set_session_data</li> <li>get_session_data</li> </ul>  <p>Important</p> <ul> <li>The Session Middleware must be enabled in Starlite app provided to the TestClient to use sessions.</li> <li>If you are using the CookieBackend you need   to install the <code>cryptography</code> package. You can do so by installing starlite with e.g. <code>pip install starlite[cryptography]</code>   or <code>poetry install starlite[cryptography]</code></li> </ul>  Python 3.8+Python 3.9+   Setting session data<pre><code>from typing import Any, Dict\n\nfrom starlite import Request, Starlite, get\nfrom starlite.middleware.session.memory_backend import MemoryBackendConfig\nfrom starlite.testing import TestClient\n\nsession_config = MemoryBackendConfig()\n\n\n@get(path=\"/test\")\ndef get_session_data(request: Request) -&gt; Dict[str, Any]:\n    return request.session\n\n\napp = Starlite(route_handlers=[get_session_data], middleware=[session_config.middleware])\n\nwith TestClient(app=app, session_config=session_config) as client:\n    client.set_session_data({\"foo\": \"bar\"})\n    assert client.get(\"/test\").json() == {\"foo\": \"bar\"}\n</code></pre>   Setting session data<pre><code>from typing import Any\n\nfrom starlite import Request, Starlite, get\nfrom starlite.middleware.session.memory_backend import MemoryBackendConfig\nfrom starlite.testing import TestClient\n\nsession_config = MemoryBackendConfig()\n\n\n@get(path=\"/test\")\ndef get_session_data(request: Request) -&gt; dict[str, Any]:\n    return request.session\n\n\napp = Starlite(route_handlers=[get_session_data], middleware=[session_config.middleware])\n\nwith TestClient(app=app, session_config=session_config) as client:\n    client.set_session_data({\"foo\": \"bar\"})\n    assert client.get(\"/test\").json() == {\"foo\": \"bar\"}\n</code></pre>    Getting session data<pre><code>from starlite import Request, Starlite, post\nfrom starlite.middleware.session.memory_backend import MemoryBackendConfig\nfrom starlite.testing import TestClient\n\nsession_config = MemoryBackendConfig()\n\n\n@post(path=\"/test\")\ndef set_session_data(request: Request) -&gt; None:\n    request.session[\"foo\"] = \"bar\"\n\n\napp = Starlite(route_handlers=[set_session_data], middleware=[session_config.middleware])\n\nwith TestClient(app=app, session_config=session_config) as client:\n    client.post(\"/test\").json()\n    assert client.get_session_data() == {\"foo\": \"bar\"}\n</code></pre>"},{"location":"usage/9-testing/1-test-client/#using-a-blocking-portal","title":"Using a blocking portal","text":"<p>The <code>TestClient</code> uses a feature of anyio called a Blocking Portal.</p> <p>The anyio.abc.BlockingPortal allows <code>TestClient</code> to execute asynchronous functions using a synchronous call. <code>TestClient</code> creates a blocking portal to manage <code>Starlite</code>'s async logic, and it allows <code>TestClient</code>'s API to remain fully synchronous.</p> <p>Any tests that are using an instance of <code>TestClient</code> can also make use of the blocking portal to execute asynchronous functions without the test itself being asynchronous.</p> Using a blocking portal<pre><code>from concurrent.futures import Future, wait\n\nimport anyio\n\nfrom starlite.testing import create_test_client\n\n\ndef test_with_portal() -&gt; None:\n    \"\"\"This example shows how to manage asynchronous tasks using a portal.\n\n    The test function itself is not async. Asynchronous functions are executed and awaited using the portal.\n    \"\"\"\n\n    async def get_float(value: float) -&gt; float:\n        await anyio.sleep(value)\n        return value\n\n    with create_test_client(route_handlers=[]) as test_client, test_client.portal() as portal:\n        # start a background task with the portal\n        future: Future[float] = portal.start_task_soon(get_float, 0.25)\n        # do other work\n        assert portal.call(get_float, 0.1) == 0.1\n        # wait for the background task to complete\n        wait([future])\n        assert future.done()\n        assert future.result() == 0.25\n</code></pre>"},{"location":"usage/9-testing/2-create-test-app/","title":"Creating a Test App","text":"<p>Starlite also offers a helper function called <code>create_test_client</code> which first creates an instance of Starlite and then a test client using it. There are multiple use cases for this helper - when you need to check generic logic that is decoupled from a specific Starlite app, or when you want to test endpoints in isolation.</p> <p>You can pass to this helper all the kwargs accepted by the starlite constructor, with the <code>route_handlers</code> kwarg being required. Yet unlike the Starlite app, which expects <code>route_handlers</code> to be a list, here you can also pass individual values.</p> <p>For example, you can do this:</p> my_app/tests/test_health_check.py<pre><code>from starlite.status_codes import HTTP_200_OK\nfrom starlite.testing import create_test_client\n\nfrom my_app.main import health_check\n\n\ndef test_health_check():\n    with create_test_client(route_handlers=[health_check]) as client:\n        response = client.get(\"/health-check\")\n        assert response.status_code == HTTP_200_OK\n        assert response.text == \"healthy\"\n</code></pre> <p>But also this:</p> my_app/tests/test_health_check.py<pre><code>from starlite.status_codes import HTTP_200_OK\nfrom starlite.testing import create_test_client\n\nfrom my_app.main import health_check\n\n\ndef test_health_check():\n    with create_test_client(route_handlers=health_check) as client:\n        response = client.get(\"/health-check\")\n        assert response.status_code == HTTP_200_OK\n        assert response.text == \"healthy\"\n</code></pre>"},{"location":"usage/9-testing/3-request-factory/","title":"Request Factory","text":"<p>Another helper is the <code>RequestFactory</code> class, which creates instances of <code>starlite.connection.request.Request</code>. The use case for this helper is when you need to test logic that expects to receive a request object.</p> <p>For example, lets say we wanted to unit test a guard function in isolation, to which end we'll reuse the examples from the route guards documentation:</p> my_app/guards.py<pre><code>from starlite import Request, RouteHandler, NotAuthorizedException\n\n\ndef secret_token_guard(request: Request, route_handler: RouteHandler) -&gt; None:\n    if route_handler.opt.get(\"secret\") and not request.headers.get(\"Secret-Header\", \"\") == route_handler.opt[\"secret\"]:\n        raise NotAuthorizedException()\n</code></pre> <p>We already have our route handler in place:</p> my_app/secret.py<pre><code>from os import environ\n\nfrom starlite import get\n\nfrom my_app.guards import secret_token_guard\n\n\n@get(path=\"/secret\", guards=[secret_token_guard], opt={\"secret\": environ.get(\"SECRET\")})\ndef secret_endpoint() -&gt; None:\n    ...\n</code></pre> <p>We could thus test the guard function like so:</p> tests/guards/test_secret_token_guard.py<pre><code>import pytest\n\nfrom starlite import NotAuthorizedException\nfrom starlite.testing import RequestFactory\n\nfrom my_app.guards import secret_token_guard\nfrom my_app.secret import secret_endpoint\n\n\nrequest = RequestFactory().get(\"/\")\n\n\ndef test_secret_token_guard_failure_scenario():\n    copied_endpoint_handler = secret_endpoint.copy()\n    copied_endpoint_handler.opt[\"secret\"] = None\n    with pytest.raises(NotAuthorizedException):\n        secret_token_guard(request=request, route_handler=copied_endpoint_handler)\n\n\ndef test_secret_token_guard_success_scenario():\n    copied_endpoint_handler = secret_endpoint.copy()\n    copied_endpoint_handler.opt[\"secret\"] = \"super-secret\"\n    secret_token_guard(request=request, route_handler=copied_endpoint_handler)\n</code></pre> <p>The <code>RequestFactory</code> constructor accepts the following parameters:</p> <ul> <li><code>app</code>: An instance of the <code>Starlite</code> class.</li> <li><code>server</code>: The server's domain. Defaults to <code>test.org</code>.</li> <li><code>port</code>: The server's port. Defaults to <code>3000</code>.</li> <li><code>root_path</code>: Root path for the server. Defaults to <code>/</code>.</li> <li><code>scheme</code>: Scheme for the server. Defaults to <code>\"http\"</code>.</li> </ul> <p>It exposes methods for all supported HTTP methods:</p> <ul> <li><code>RequestFactory().get()</code></li> <li><code>RequestFactory().post()</code></li> <li><code>RequestFactory().put()</code></li> <li><code>RequestFactory().patch()</code></li> <li><code>RequestFactory().delete()</code></li> </ul> <p>All of these methods accept the following parameters:</p> <ul> <li><code>path</code>: The request's path. This parameter is required.</li> <li><code>headers</code>: A dictionary of headers. Defaults to <code>None</code>.</li> <li><code>cookies</code>: A string representing the cookie header or a list of <code>Cookie</code> instances.   This value can include multiple cookies. Defaults to <code>None</code>.</li> <li><code>session</code>: A dictionary of session data. Defaults to <code>None</code>.</li> <li><code>user</code>: A value for <code>request.scope[\"user\"]</code>. Defaults to <code>None</code>.</li> <li><code>auth</code>: A value for <code>request.scope[\"auth\"]</code>. Defaults to <code>None</code>.</li> <li><code>state</code>: Arbitrary request state.</li> <li><code>path_params</code>: A string keyed dictionary of path parameter values.</li> <li><code>http_version</code>: HTTP version. Defaults to \"1.1\".</li> <li><code>route_handler</code>: A route handler instance or method. If not provided a default handler is set.</li> </ul> <p>In addition, the following methods accepts a few more parameters:</p> <ul> <li><code>RequestFactory().get()</code>:</li> <li><code>query_params</code>: A dictionary of values from which the request's query will be generated.   Defaults to <code>None</code>.</li> <li><code>RequestFactory().post()</code>, <code>RequestFactory().put()</code>, <code>RequestFactory().patch()</code>:</li> <li><code>request_media_type</code>: The 'Content-Type' header of the request. Defaults to <code>None</code>.</li> <li><code>data</code>: A value for the request's body. Can be either a pydantic model instance   or a string keyed dictionary. Defaults to <code>None</code>.</li> </ul>"},{"location":"usage/9-testing/4-pydantic-factories/","title":"Using pydantic-factories","text":"<p>Pydantic-factories offers an easy and powerful way to generate mock data from pydantic models and dataclasses.</p> <p>Let's say we have an API that talks to an external service and retrieves some data:</p> main.py<pre><code>from typing import Protocol, runtime_checkable\n\nfrom pydantic import BaseModel\nfrom starlite import get\n\n\nclass Item(BaseModel):\n    name: str\n\n\n@runtime_checkable\nclass Service(Protocol):\n    def get(self) -&gt; Item:\n        ...\n\n\n@get(path=\"/item\")\ndef get_item(service: Service) -&gt; Item:\n    return service.get()\n</code></pre> <p>We could test the <code>/item</code> route like so:</p> tests/conftest.py<pre><code>import pytest\n\nfrom starlite.status_codes import HTTP_200_OK\nfrom starlite import Provide, create_test_client\n\nfrom my_app.main import Service, Item, get_item\n\n\n@pytest.fixture()\ndef item():\n    return Item(name=\"Chair\")\n\n\ndef test_get_item(item: Item):\n    class MyService(Service):\n        def get_one(self) -&gt; Item:\n            return item\n\n    with create_test_client(route_handlers=get_item, dependencies={\"service\": Provide(lambda: MyService())}) as client:\n        response = client.get(\"/item\")\n        assert response.status_code == HTTP_200_OK\n        assert response.json() == item.dict()\n</code></pre> <p>While we can define the test data manually, as is done in the above, this can be quite cumbersome. That's where pydantic-factories library comes in. It generates mock data for pydantic models and dataclasses based on type annotations. With it, we could rewrite the above example like so:</p> main.py<pre><code>from typing import Protocol, runtime_checkable\n\nimport pytest\nfrom pydantic import BaseModel\nfrom pydantic_factories import ModelFactory\nfrom starlite.status_codes import HTTP_200_OK\nfrom starlite import Provide, get\nfrom starlite.testing import create_test_client\n\n\nclass Item(BaseModel):\n    name: str\n\n\n@runtime_checkable\nclass Service(Protocol):\n    def get_one(self) -&gt; Item:\n        ...\n\n\n@get(path=\"/item\")\ndef get_item(service: Service) -&gt; Item:\n    return service.get_one()\n\n\nclass ItemFactory(ModelFactory[Item]):\n    __model__ = Item\n\n\n@pytest.fixture()\ndef item():\n    return ItemFactory.build()\n\n\ndef test_get_item(item: Item):\n    class MyService(Service):\n        def get_one(self) -&gt; Item:\n            return item\n\n    with create_test_client(route_handlers=get_item, dependencies={\"service\": Provide(lambda: MyService())}) as client:\n        response = client.get(\"/item\")\n        assert response.status_code == HTTP_200_OK\n        assert response.json() == item.dict()\n</code></pre>"}]}